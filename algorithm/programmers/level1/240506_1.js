// 연습문제 - 문자열 내 마음대로 정렬하기

function solution(strings, n) {
  return strings
    .map((str) => str[n] + str)
    .sort()
    .map((str) => str.replace(str[0], ""));
}

// 다른 사람의 풀이 1
function solution(strings, n) {
  return strings.sort((s1, s2) =>
    s1[n] === s2[n] ? s1.localeCompare(s2) : s1[n].localeCompare(s2[n])
  );
}
// 1. strings 배열을 sort() 메서드를 사용하여 정렬함. 이때, 비교 함수를 제공함
// - sort() 메서드는 비교 함수의 반환값이 음수이면 첫 번째 인자를 먼저 놓고, 양수이면 두 번째 인자를 먼저 놓게 됨
// - 만약 반환값이 0이라면 두 인자의 순서를 변경하지 않음
// 2. 두 문자열의 n번째 문자(s1[n]과 s2[n])을 비교함
// 3. 만약 두 문자열의 n번째 문자가 동일하다면, localeCompare() 메서드를 사용하여 두 문자열을 사전순으로 비교함
// - localeCompare() 메서드는 두 문자열을 사전 순으로 비교하여 결과를 반환함
// - 만약 s1이 s2보다 앞에 온다면 음수를, 뒤에 온다면 양수를, 동일하다면 0을 반환함
// 4. 만약 두 문자열이 n번째 문자가 동일하지 않다면, 두 문자열의 n번째 문자를 직접 비교하여 정렬함
// 5. 정렬된 배열을 반환함

// 다른 사람의 풀이 2
function solution(strings, n) {
  return strings.sort((a, b) => {
    const chr1 = a.charAt(n);
    const chr2 = b.charAt(n);

    if (chr1 == chr2) {
      return (a > b) - (a < b);
    } else {
      return (chr1 > chr2) - (chr1 < chr2);
    }
  });
}
// 1. strings 배열을 sort() 메서드를 사용하여 정렬함. 이때, 비교 함수를 제공함
// - sort() 메서드는 비교 함수의 반환값이 음수이면 첫 번째 인자를 먼저 놓고, 양수이면 두 번째 인자를 먼저 놓게 됨
// 2. 비교 함수는 두 문자열 a과 b를 인자로 받아서 정렬 순서를 결정함
// 3. 먼저, 각 문자열에서 n번째 문자를 가져와서 이를 chr1과 chr2에 저장함
// 4. 두 문자열의 n번째 문자가 동일한 경우, 두 문자열 전체를 비교하여 사전 순서로 정렬함. 이를 위해 (a > b) - (b < a)를 반환함
// - a > b가 참이면 1, 거짓이면 0을 반환하고, b < a가 참이면 1, 거짓이면 0을 반환함
// - 만약 a가 b보다 크면 a > b는 참(1), a < b는 거짓(0)이므로 1-0 = 1(양수)이 반환됨
// - 만약 a와 b가 같으면 a > b는 거짓(0), a < b도 거짓(0)이므로 0-0 = 0이 반환됨
// - 만약 a가 b보다 작으면 a > b는 거짓(0), a < b는 참(1)이므로 0-1 = -1(음수)이 반환됨
// 5. 두 문자열의 n번째 문자가 다른 경우, chr1과 chr2를 비교하여 정렬함. 이를 위해 (chr1 > chr2) - (chr1 < chr2)를 반환함
// - chr1 > chr2가 참이면 1, 거짓이면 0을 반환하고, chr1 < chr2가 참이면 1, 거짓이면 0을 반환함
// - 만약 chr1가 chr2보다 크면 chr1 > chr2는 참(1), chr2 < chr1는 거짓(0)이므로 1-0 = 1(양수)이 반환됨
// - 만약 chr1가 chr2보다 작으면 chr1 > chr2는 거짓(0), chr2 > chr1는 참(1)이므로 0-1 = -1(음수)이 반환됨
// - 두 문자열의 n번째 문자(chr1, chr2)가 다른 경우에 실행되는 리턴문이므로 chr1와 chr2가 같은 경우는 존재할 수 없음
// 6. 최종적으로, 정렬된 배열을 반환함