// 연습문제 - 가장 가까운 같은 글자

// 받은 문자열을 문자 하나 하나씩 분리하여 배열 요소로 집어넣고
// 배열을 순회하면서 현재 값보다 이전에 있는 요소를 보면서 값을 넣어야 함
// ["b", "a", "n", "a", "n", "a"]

function solution(s) {
  let splittedStr = s.split("");
  let answer = splittedStr.map((cur, idx) => {
    let newArr = splittedStr.slice(0, idx).reverse();
    let index = newArr.indexOf(cur);
    return index === -1 ? -1 : index + 1;
  });
  return answer;
}

// 다른 사람의 풀이 1
function solution(s) {
  const hash = {};

  return [...s].map((v, i) => {
    let result = hash[v] !== undefined ? i - hash[v] : -1;
    hash[v] = i;
    return result;
  });
}
// 1. 빈 객체 hash를 생성함. 이 객체는 문자열 s의 각 문자가 마지막으로 등장한 위치를 저장하는 용도로 사용됨
// 2. 문자열 s를 배열로 변환한 후, map() 메서드를 사용하여 각 문자와 인덱스에 대해 다음을 수행함
// - hash 객체에서 현재 문자 v가 가리키는 인덱스를 확인함
// - 만약 해당 문자가 이전에 등장했던 적이 있다면, 해당 문자의 마지막 등장 위치를 나타내는 인덱스가 hash[v]에 저장되어 있음
// - 현재 문자가 이전에 등장한 적이 없다면 -1을 반환하고, 그렇지 않은 경우 현재 위치 i와 이전 등장 위치 hash[v]의 차를 반환함
// 3. 현재 문자의 위치를 hash 객체에 저장함. 이렇게 하면 해당 문자의 마지막 등장 위치가 항상 최신으로 유지됨
// 4. 마지막으로 map() 메서드에 의해 반환된 각 문자의 등장 거리를 담은 배열을 반환함

// 다른 사람의 풀이 2
const solution = (s) =>
  [...s].map((char, i) => {
    const count = s.slice(0, i).lastIndexOf(char);
    return count < 0 ? count : i - count;
  });
// 1. [...s]를 사용하여 각 문자를 원소로 갖는 배열을 생성함
// 2. 이 배열을 map() 메서드를 사용하여 각 문자와 해당 인덱스에 대해 처리함
// 3. 각 문자와 해당 인덱스에 대해 다음을 수행함
// (3-1) slice() 메서드를 사용하여 현재 문자를 제외한 이전 부분 문자열을 가져옴
// - 즉, 현재 문자 이전에 등장한 모든 문자들을 포함한 부분 문자열을 생성함
// (3-2) lastIndexOf() 메서드를 사용하여 현재 문자의 이전 등장 위치를 찾음
// - 이전 등장 위치를 찾기 위해 현재 문자 이전 부분 문자열에서 현재 문자가 마지막으로 등장한 인덱스를 찾음
// (3-3) 현재 인덱스와 이전 등장 위치 사이의 거리를 계산하여 반환함
// - 현재 인덱스에서 이전 등장 위치를 빼면서, 이전 등장 위치와 현재 위치 사이의 거리를 구함
// 4. 마지막으로 각 문자에 대해 구한 거리를 요소로 갖는 배열을 반환함