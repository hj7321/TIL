## 0516_Day23

자바스크립트 문법 정리 부분

## 1. `append()` 메서드와 `appendChild()` 메서드의 차이점

- 공부 계기

  - <JavaScript 문법 종합반> 5주차 강의를 재수강하는데 선생님께서 `append()` 메서드를 사용하여 특정 노드를 자식 요소로 추가하였다.
  - 나는 그동안 특정 노드를 자식 요소로 추가할 때 `appendChild()` 메서드를 사용했었는데, `append()` 메서드도 똑같이 자식 요소로 추가되어서 두 메서드의 차이점이 뭔지 알아보기로 했다.

- `append()` 메서드와 `appendChild()` 메서드는 둘 다 DOM 요소를 다른 요소에 추가하는 메서드이다.

- **`append()` 메서드**

  - 기능: DOM 노드의 마지막 자식으로 **하나 이상의 새로운 노드 또는 DOMString 객체**를 추가한다.
  - 특징
    - **여러 개의 요소나 텍스트를 한 번에 추가**할 수 있다.
    - **다수의 매개변수**를 받을 수 있으며, 각각의 매개변수는 마지막 자식으로 추가된다.
    - 추가하려는 요소나 텍스트가 **이미 DOM에 존재**하는 요소인 경우, **해당 요소를 이동시킨다.**
  - 예제
    ```javascript
    parentElement.append(child1, child2, ..., childN);
    ```

- **`appendChild()` 메서드**
  - 기능: DOM 노드의 마지막 자식으로 **하나의 새로운 노드**를 추가한다.
  - 특징
    - **한 번에 하나의 요소만 추가**할 수 있다.
    - 매개변수로는 **추가할 하나의 요소**만을 받는다.
    - 추가하려는 요소가 **이미 DOM에 존재**하는 요소인 경우, **해당 요소를 이동시키지 않고 새로운 노드를 추가한다.**
  - 예제
    ```javascript
    parentElement.appendChild(newChild);
    ```

## 2. 클래스의 생성자와 인스턴스

- 공부 계기

  - <JavaScript 문법 종합반> 5주차 강의를 재수강하다 보니, 클래스의 생성자를 정의하는 방식에서 궁금한 점이 생겼다.
  - 클래스에서 생성자를 정의할 때 `this.name = name;`과 같은 형식으로 쓰는데, 외부에서 `name`을 지정하기 전까지는 `this.name`이 없는 셈이라고 할 수 있는데 왜 오류가 나지 않는 것인지 궁금해졌다.
  - 클래스의 생성자에 대해서 공부하다 보니, 클래스의 인스턴스의 특징에 대해서도 배우게 되어서 클래스의 인스턴스에 대해서도 정리해보기로 했다.

- 자바스크립트에서 **클래스의 생성자는 객체가 생성될 때 자동으로 호출**된다.

- 따라서 **클래스의 인스턴스를 생성할 때 생성자가 실행되며, 해당 인스턴스의 프로퍼티(`this.name` 등)가 생성된다.**

- 생성자 내부에서 `this.name = name`과 같이 프로퍼티를 할당할 때, 생성자가 실행될 때 받은 매개변수 `name`을 해당 프로퍼티에 할당한다. 이것이 클래스의 생성자의 주요 역할 중 하나이다.

  - 프로퍼티라는 말을 사용한 것에서 알 수 있듯이, **클래스의 인스턴스는 객체**이다.

    ```javascript
    class Person {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }
    }

    const person1 = new Person("안유진", 20);
    console.log(person1); // Person { name: '안유진', age: 20 }
    ```

    - person1이라는 인스턴스를 생성한 후, person1을 콘솔창에 출력해보면 객체 형태로 값이 나오는 것을 볼 수 있다.

  - 객체는 데이터와 해당 데이터에 접근할 수 있는 메서드(함수)를 포함하는 개체를 나타낸다.
  - 자바스크립트에서 클래스를 사용하여 객체를 만들 때, 그 클래스의 인스턴스를 생성한다.
  - 이 인스턴스는 해당 클래스의 정의에 따라서 데이터와 메서드를 가진다.

- 따라서 클래스의 인스턴스를 생성할 때 생성자에 매개변수를 전달하지 않으면, 해당 프로퍼티에는 `undefined`가 할당된다. 따라서 오류는 발생하지 않는다.

- 이후에 외부에서 해당 프로퍼티에 값을 할당하거나, 해당 프로퍼티를 사용할 때에만 오류가 발생한다.

- 즉, **클래스의 생성자에서 프로퍼티를 초기화하는 것은 해당 클래스의 인스턴스를 생성할 때 호출되므로**, 그 이전에 외부에서 해당 프로퍼티에 값을 주지 않아도 오류가 발생하지 않는다.

## 3. 오버로딩과 오버라이딩의 차이점

- 공부 계기

  - <JavaScript 문법 종합반> 5주차 강의를 재수강하는데 클래스의 상속 부분에서 '오버라이딩'이라는 개념이 언급되었다.
  - 대학교에서 Java 강의를 들을 때 '오버로딩'과 '오버라이딩'의 개념을 함께 배웠었는데, 두 개념의 정확한 정의와 차이점을 잘 모르겠어서 이번 기회를 통해 두 개념을 정리해보기로 했다.

- **오버로딩(Overloading)**

  - 정의: **같은 이름의 메서드나 함수를 여러 개 정의**하고, **매개변수의 타입, 개수, 순서 등을 다르게 하여** 다양한 형태로 호출할 수 있도록 하는 기술
  - 특징
    - 다형성의 한 형태로, 같은 이름의 메서드나 함수를 다른 시그니처로 여러 번 정의한다.
    - 오버로딩된 메서드나 함수는 컴파일러나 인터프리터가 매개변수를 보고 실행될 때 어떤 버전을 호출할지 결정한다.
    - **자바스크립트와 같은 동적 타입 언어에서는 오버로딩이 명시적으로 지원되지 않는다.**

- **오버라이딩(Overriding)**
  - 정의: **상위 클래스의 메서드를 하위 클래스에서 재정의**하여, **하위 클래스에서 해당 메서드를 호출할 때 상위 클래스의 메서드 대신 하위 클래스의 메서드가 실행**되도록 하는 기술
  - 특징
    - 상속 관게에서 발생한다. 즉, 하위 클래스가 상위 클래스의 메서드를 재정의한다.
    - 메서드의 시그니처는 동일해야 한다. 즉, 메서드의 이름과 매개변수의 타입 및 개수가 같아야 한다.
    - 오버라이딩된 메서드는 상위 클래스의 메서드 대신 호출된다.

<br>
<hr>
<br>
리액트 문법 정리 부분

## 4. `useState`의 비동기성

- 공부 계기

  - 리액트 입문 개인 과제 해설을 보니, `useState`의 set함수를 다음과 같이 사용하였다.
    ```jsx
    // TodoForm.jsx
    setTodos((todos) => [...todos, newTodos]);
    ```
    ```jsx
    // TodoItem.jsx의 deleteTodo() 함수 내용 일부
    setTodos((todos) => todos.filter((todo) => todo.id !== id));
    ```
    ```jsx
    // TodoItem.jsx의 toggleTodo() 함수 내용 일부
    setTodos((todos) =>
      todos.map((todo) =>
        todo.id === id ? { ...todo, isDone: !todo.isDone } : todo
      )
    );
    ```
  - 과제 해설을 해 주시는 선생님께서 set 함수 안에 특정 값이 아닌 콜백함수를 사용하는 것이 **`useState`의 비동기성**과 관련이 있다고 해서, "`useState`의 비동기성"에 대해서 공부해보기로 했다.

- 리액트의 `useState` 훅은 **상태를 업데이트할 때 비동기적으로 동작**한다.

  - 이것은 리액트가 **상태 업데이트를 예약**하고, **다음 렌더링 사이클에서 해당 상태를 적용**한다는 것을 의미한다.
  - 따라서 `setTodos()` 함수를 호출하여 상태를 업데이트할 때, **해당 상태가 즉시 업데이트되는 것이 아니라**, 리액트가 상태 업데이트를 예약하고, 나중에 다음 렌더링 사이클에서 적용된다.

- `setTodos((todos) => [...todos, newTodos]);`와 같은 코드에서는 이전 상태를 가져와서 새로운 항목을 추가한 후, 그것을 새로운 상태로 추가한다.

  - 이 과정에서 **이전 상태의 변경 여부와 관계없이 항상 최신의 상태를 사용**한다.
  - 이러한 방식으로 리액트는 **상태의 일관성을 유지**하고, **예상치 못한 동작을 방지**한다.

- 따라서 `setTodos()` 함수를 사용할 때 **함수형 업데이트**를 사용하여 이전 상태를 기반으로 새로운 상태를 설정하는 것은 리액트의 상태 업데이트 메커니즘과 관련이 있다.

  - 이를 통해 비동기적으로 상태가 업데이트되는 동작이 보장된다.

- `setTodos()` 함수를 사용하는 두 가지 방식의 차이점

  - 코드 1
    ```jsx
    setTodos([...todos, newTodo]);
    ```
    - **이전 상태에 새로운 요소를 직접 추가**한다.
    - `todos` 배열을 펼친 후 새로운 요소 `newTodo`를 추가하여 새로운 배열을 만들어 `setTodos()` 함수를 통해 상태를 업데이트한다.
    - **기존 상태를 변경**하고 **새로운 배열을 반환**하는 방식으로 동작한다.
  - 코드 2
    ```jsx
    setTodos((todos) => [...todos, newTodo]);
    ```
    - 함수를 인자로 전달하여 **이전 상태를 받아 새로운 상태를 게산하고 반환하는 함수**를 사용한다.
    - 이전 상태를 받아와 새로운 요소 `newTodo`를 추가한 새로운 배열을 만들어 반환하는 함수를 전달한다.
    - 리액트의 **함수형 업데이트** 메커니즘을 활용하여 상태 업데이트를 처리한다.
  - 두 가지 방식의 주요 차이점
    - **상태 참조 방식**
      - 코드 1: `todos` 상태를 직접 참조한다. 이 경우, 상태가 최신이 아닐 가능성이 있으며, 특히 비동기적으로 상태가 업데이트될 때 문제가 발생할 수 있다.
      - 코드 2: 함수형 업데이트를 사용하여 리액트가 제공하는 최신 상태 값을 참조한다. 이는 항상 최신 상태를 기반으로 새로운 상태를 계산할 수 있도록 한다.
    - **동기화**
      - 코드 1: 여러 상태 업데이트가 연속적으로 발생할 경우, 이전 상태를 기반으로 하여 정확하지 않은 업데이트가 이루어질 수 있다.
      - 코드 2: 각 상태 업데이트가 독립적으로 최신 상태 값을 기반으로 하기 때문에, 동기화 문제가 발생하지 않는다.
    - **안전성**
      - 코드 1: 상태 값이 비동기적으로 변경되는 상황에서 안전하지 않을 수 있다.
      - 코드 2: 함수형 업데이트는 이러한 비동기 상태 변경 상황에서도 안전하게 작동한다.
    - 결론
      - 코드 2를 사용하면 상태 업데이트 시 최신 상태 값을 안전하게 참조할 수 있으며, 동기화 문제를 방지할 수 있어 더 안정적이고 예측 가능한 상태 관리를 할 수 있다.
      - 따라서, 리액트에서 상태 업데이트를 할 때 함수형 업데이트 패턴을 사용하는 것이 더 좋다.

- `useState`의 특징
  - **비동기 업데이트**
    - `useState`로 상태를 업데이트할 때 리액트는 즉시 해당 상태를 업데이트하지 않고, 업데이트가 예약된 작업을 수행한다.
    - 이러한 작업은 리액트의 내부 메커니즘에 의해 관리되며, 업데이트된 상태를 컴포넌트에 반영하기 위해 다음 렌더링 사이에 예약된다.
  - **일괄 처리**
    - 리액트는 여러 상태 업데이트를 일괄 처리하여 성능을 최적화한다.
    - 여러 `useState` 호출로 인한 여러 상태 업데이트가 있더라도 리액트는 이를 하나의 업데이트로 결합하여 처리한다.
    - 이렇게 함으로써 여러 번의 렌더링이 발생하지 않고, 한 번의 렌더링 사이클에 모든 업데이트가 적용된다.
  - **큐잉 메커니즘**
    - 리액트는 상태 업데이트를 큐에 넣어두고, 이벤트 루프의 다음 사이클에서 처리한다.
    - 이러한 큐잉 메커니즘은 리액트가 다양한 업데이트를 효율적으로 관리하고, 컴포넌트으 불필요한 재렌더링을 방지한다.
  - **비동기 처리 순서**
    - `useState`로 상태를 업데이트할 때의 순서는 비동기적이다.
    - 예를 들어, 여러 개의 `useState` 호출이 있을 때, 각 호출이 즉시 상태를 업데이트하지 않고, 다음 렌더링 사이클에서 일괄 처리된다.
  - **최신 상태 보장**
    - 리액트는 이전 상태를 보장하기 위해 새로운 상태를 결정하는 과정에서 최신 상태를 고려한다.
    - 이를 통해 다양한 비동기 작업이 있더라도 상태의 일관성을 유지할 수 있다.
  - 따라서 리액트에서의 `useState`는 상태 업데이트가 비동기적으로 처리되며, 일괄 처리되어 효율적으로 관리된다.
  - 이를 통해 리액트는 성능을 향상키시고, 컴포넌트의 동작을 예측 가능하게 한다.

## 5. 제어 컴포넌트와 비제어 컴포넌트

- 공부 계기

  - 리액트 입문 개인 과제 해설에서 제어 컴포넌트보다 비제어 컴포넌트 방식을 사용하는 게 코드를 더 간결하게 할 수 있다고 설명하시면서 비제어 컴포넌트 방식으로 코드를 쓰셨다.

    ```jsx
    // TodoForm.jsx 파일 내용 일부

    return (
      <form onSubmit={addTodoBox}>
        <label>
          제목&ensp;
          <input type="text" name="title" />
        </label>
        <label>
          내용&ensp;
          <input type="text" name="content" />
        </label>
        <button type="submit" className="add-btn">
          추가하기
        </button>
      </form>
    );
    ```

    ```jsx
    // TodoForm.jsx 파일 내용 일부

    const formData = new FormData(e.target);
    const title = formData.get("title");
    const content = formData.get("content");
    ```

  - 제어 컴포넌트와 비제어 컴포넌트의 의미와 그 차이점을 잘 몰라서 이번 기회를 통해 제대로 정리해보기로 했다.

- 리액트에서 폼 요소를 처리할 때는 제어 컴포넌트와 비제어 컴포넌트 두 가지 접근 방식이 있다.
  - **제어 컴포넌트**
    - 폼 요소의 상태를 **리액트 컴포넌트 상태로 관리**하는 방식
    - 폼 요소의 값(`value`)과 변경 핸들러(`onChange`)를 리액트 상태와 연결하여, **폼 요소의 상태가 리액트 상태와 항상 동기화**되도록 한다.
    - 특징
      - 폼 요소의 상태를 **리액트 상태로 관리**한다.
      - 폼 데이터는 **`value`와 `onChange` 핸들러**를 통해 관리한다.
    - 장점
      - 폼 요소의 상태를 리액트 상태로 관리하므로 일관성이 높다.
      - 상태 변경을 즉시 반영하고 조작할 수 있다.
      - 폼 요소의 상태를 더 쉽게 추적하고 디버깅할 수 있다.
    - 단점
      - 코드가 더 복잡해질 수 있다.
      - 작은 폼이라도 상태와 핸들러를 모두 작성해야 하므로 초기 설정이 더 필요하다.
  - **비제어 컴포넌트**
    - 폼 요소의 상태를 리액트가 아닌 **DOM 자체에서 관리**하는 방식
    - 리액트에서 폼 요소의 `value`와 `onChange` 핸들러를 사용하지 않고, 폼 데이터는 **필요할 때 직접 DOM에서 읽어온다.**
    - 전통적인 HTML 폼 방식과 비슷하다.
    - 특징
      - 폼 요소는 **자체 상태를 관리**한다.
      - **`ref`나 `FormData` 객체**를 사용하여 폼 데이터를 읽어온다.
      - 코드가 간단하고 빠르게 작성할 수 있다.
    - 장점
      - 초기 학습 곡선이 낮고, 기존 HTML 폼과 유사하여 이해하기 쉽다.
      - 간단한 폼에서 구현이 더 쉽다.
    - 단점
      - 폼 요소의 현재 상태를 즉시 확인하거나 조작하기 어렵다.
      - 리액트의 상태 관리와는 별도로 동작하므로 일관된 상태 관리를 위해 추가 코드가 필요할 수 있다.
  - 결론
    - 제어 컴포넌트는 더 복잡하지만, 폼 상태를 더 잘 관리하고 추적할 수 있다.
    - 비제어 컴포넌트는 더 간단하고 빠르게 작성할 수 있지만, 상태를 추적하고 조작하는 데 제약이 있을 수 있다.

## 6. `FormData` 객체

- 공부 계기

  - 리액트 입문 개인 과제 해설에서 폼 요소를 처리할 때 비제어 컴포넌트를 사용하면서 `FormData` 객체를 사용하였다.
  - `FormData` 객체는 처음 들어봐서 `FormData` 객체에 대해서 자세히 공부해보기로 했다.

- `FormData` 객체는 웹 개발에서 HTML 폼 데이터를 쉽게 다루기 위해 사용되는 인터페이스이다.

- 이 객체를 사용하면 **폼 데이터를 키-값 쌍으로 저장**하고, 이를 쉽게 전송하거나 처리할 수 있다.

- 주요 특징과 기능

  - **폼 데이터 수집** : `FormData` 객체는 HTML 폼의 데이터를 자동으로 수집하여 저장할 수 있다. 이는 폼 데이터가 대량일 때 매우 유용하다.
  - **키-값 쌍으로 저장** : 각 입력 필드의 이름(`name`)과 값을 키-값 쌍으로 저장한다. 이는 전송이나 처리 시 매우 편리하다.
  - **파일 업로드 지원** : 파일 입력 필드의 데이터를 포함하여, 파일을 쉽게 업로드할 수 있다.
  - **동적 데이터 추가** : 폼 외부에서도 데이터를 추가할 수 있다.

- 주요 메서드와 속성
  - **생성자** : `formElement`는 `<form>` 요소를 참조하여, 해당 폼의 모든 데이터를 `FormData` 객체로 가져온다.
    ```jsx
    const formData = new FormData(formElement);
    ```
  - **`append()` 메서드** : 새로운 데이터를 추가한다.
    ```jsx
    formData.append("key", "value");
    formData.append("file", fileInput, files[0]);
    ```
  - **`delete()` 메서드** : 특정 키의 데이터를 삭제한다.
    ```jsx
    formData.delete("key");
    ```
  - **`get()` 메서드** : 특정 키의 첫 번째 값을 반환한다.
    ```jsx
    const value = formData.get("key");
    ```
  - **`getAll()` 메서드** : 특정 키의 모든 값을 배열로 반환한다.
    ```jsx
    const values = formData.getAll("key");
    ```
  - **`has()` 메서드** : 특정 키가 존재하는지 확인한다.
    ```jsx
    const exists = formData.has("key");
    ```
  - **`set()` 메서드** : 특정 키의 데이터를 설정한다. 기존 값이 있으면 덮어쓴다.
    ```jsx
    formData.set("key", "newValue");
    ```
  - **`entries()` 메서드** : 모든 키-값 쌍을 iterator 객체로 반환한다.
    ```jsx
    for (const [key, value] of formData.entries()) {
      console.log(key, value);
    }
    ```
  - **`keys()` 메서드** : 모든 키를 Iterator 객체로 반환한다.
    ```jsx
    for (const key of formData.keys()) {
      console.log(key);
    }
    ```
  - **`values()` 메서드** : 모든 값을 Iterator 객체로 반환한다.
    ```jsx
    for (const value of formData.values()) {
      console.log(value);
    }
    ```
