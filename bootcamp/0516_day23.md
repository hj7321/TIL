## 0516_Day23

자바스크립트 문법 정리 부분

## 1. `append()` 메서드와 `appendChild()` 메서드의 차이점

- 공부 계기

  - <JavaScript 문법 종합반> 5주차 강의를 재수강하는데 선생님께서 `append()` 메서드를 사용하여 특정 노드를 자식 요소로 추가하였다.
  - 나는 그동안 특정 노드를 자식 요소로 추가할 때 `appendChild()` 메서드를 사용했었는데, `append()` 메서드도 똑같이 자식 요소로 추가되어서 두 메서드의 차이점이 뭔지 알아보기로 했다.

- `append()` 메서드와 `appendChild()` 메서드는 둘 다 DOM 요소를 다른 요소에 추가하는 메서드이다.

- **`append()` 메서드**

  - 기능: DOM 노드의 마지막 자식으로 **하나 이상의 새로운 노드 또는 DOMString 객체**를 추가한다.
  - 특징
    - **여러 개의 요소나 텍스트를 한 번에 추가**할 수 있다.
    - **다수의 매개변수**를 받을 수 있으며, 각각의 매개변수는 마지막 자식으로 추가된다.
    - 추가하려는 요소나 텍스트가 **이미 DOM에 존재**하는 요소인 경우, **해당 요소를 이동시킨다.**
  - 예제
    ```javascript
    parentElement.append(child1, child2, ..., childN);
    ```

- **`appendChild()` 메서드**
  - 기능: DOM 노드의 마지막 자식으로 **하나의 새로운 노드**를 추가한다.
  - 특징
    - **한 번에 하나의 요소만 추가**할 수 있다.
    - 매개변수로는 **추가할 하나의 요소**만을 받는다.
    - 추가하려는 요소가 **이미 DOM에 존재**하는 요소인 경우, **해당 요소를 이동시키지 않고 새로운 노드를 추가한다.**
  - 예제
    ```javascript
    parentElement.appendChild(newChild);
    ```

## 2. 클래스의 생성자와 인스턴스

- 공부 계기

  - <JavaScript 문법 종합반> 5주차 강의를 재수강하다 보니, 클래스의 생성자를 정의하는 방식에서 궁금한 점이 생겼다.
  - 클래스에서 생성자를 정의할 때 `this.name = name;`과 같은 형식으로 쓰는데, 외부에서 `name`을 지정하기 전까지는 `this.name`이 없는 셈이라고 할 수 있는데 왜 오류가 나지 않는 것인지 궁금해졌다.
  - 클래스의 생성자에 대해서 공부하다 보니, 클래스의 인스턴스의 특징에 대해서도 배우게 되어서 클래스의 인스턴스에 대해서도 정리해보기로 했다.

- 자바스크립트에서 **클래스의 생성자는 객체가 생성될 때 자동으로 호출**된다.

- 따라서 **클래스의 인스턴스를 생성할 때 생성자가 실행되며, 해당 인스턴스의 프로퍼티(`this.name` 등)가 생성된다.**

- 생성자 내부에서 `this.name = name`과 같이 프로퍼티를 할당할 때, 생성자가 실행될 때 받은 매개변수 `name`을 해당 프로퍼티에 할당한다. 이것이 클래스의 생성자의 주요 역할 중 하나이다.

  - 프로퍼티라는 말을 사용한 것에서 알 수 있듯이, **클래스의 인스턴스는 객체**이다.

    ```javascript
    class Person {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }
    }

    const person1 = new Person("안유진", 20);
    console.log(person1); // Person { name: '안유진', age: 20 }
    ```

    - person1이라는 인스턴스를 생성한 후, person1을 콘솔창에 출력해보면 객체 형태로 값이 나오는 것을 볼 수 있다.

  - 객체는 데이터와 해당 데이터에 접근할 수 있는 메서드(함수)를 포함하는 개체를 나타낸다.
  - 자바스크립트에서 클래스를 사용하여 객체를 만들 때, 그 클래스의 인스턴스를 생성한다.
  - 이 인스턴스는 해당 클래스의 정의에 따라서 데이터와 메서드를 가진다.

- 따라서 클래스의 인스턴스를 생성할 때 생성자에 매개변수를 전달하지 않으면, 해당 프로퍼티에는 `undefined`가 할당된다. 따라서 오류는 발생하지 않는다.

- 이후에 외부에서 해당 프로퍼티에 값을 할당하거나, 해당 프로퍼티를 사용할 때에만 오류가 발생한다.

- 즉, **클래스의 생성자에서 프로퍼티를 초기화하는 것은 해당 클래스의 인스턴스를 생성할 때 호출되므로**, 그 이전에 외부에서 해당 프로퍼티에 값을 주지 않아도 오류가 발생하지 않는다.

## 3. 오버로딩과 오버라이딩의 차이점

- 공부 계기

  - <JavaScript 문법 종합반> 5주차 강의를 재수강하는데 클래스의 상속 부분에서 '오버라이딩'이라는 개념이 언급되었다.
  - 대학교에서 Java 강의를 들을 때 '오버로딩'과 '오버라이딩'의 개념을 함께 배웠었는데, 두 개념의 정확한 정의와 차이점을 잘 모르겠어서 이번 기회를 통해 두 개념을 정리해보기로 했다.

- **오버로딩(Overloading)**

  - 정의: **같은 이름의 메서드나 함수를 여러 개 정의**하고, **매개변수의 타입, 개수, 순서 등을 다르게 하여** 다양한 형태로 호출할 수 있도록 하는 기술
  - 특징
    - 다형성의 한 형태로, 같은 이름의 메서드나 함수를 다른 시그니처로 여러 번 정의한다.
    - 오버로딩된 메서드나 함수는 컴파일러나 인터프리터가 매개변수를 보고 실행될 때 어떤 버전을 호출할지 결정한다.
    - **자바스크립트와 같은 동적 타입 언어에서는 오버로딩이 명시적으로 지원되지 않는다.**

- **오버라이딩(Overriding)**
  - 정의: **상위 클래스의 메서드를 하위 클래스에서 재정의**하여, **하위 클래스에서 해당 메서드를 호출할 때 상위 클래스의 메서드 대신 하위 클래스의 메서드가 실행**되도록 하는 기술
  - 특징
    - 상속 관게에서 발생한다. 즉, 하위 클래스가 상위 클래스의 메서드를 재정의한다.
    - 메서드의 시그니처는 동일해야 한다. 즉, 메서드의 이름과 매개변수의 타입 및 개수가 같아야 한다.
    - 오버라이딩된 메서드는 상위 클래스의 메서드 대신 호출된다.

<br>
<hr>
<br>
리액트 문법 정리 부분

## 4. `useState`의 비동기성

- 공부 계기

  - 리액트 입문 개인 과제 해설을 보니, `useState`의 set함수를 다음과 같이 사용하였다.
    ```jsx
    // TodoForm.jsx
    setTodos((todos) => [...todos, newTodos]);
    ```
    ```jsx
    // TodoItem.jsx의 deleteTodo() 함수 내용 일부
    setTodos((todos) => todos.filter((todo) => todo.id !== id));
    ```
    ```jsx
    // TodoItem.jsx의 toggleTodo() 함수 내용 일부
    setTodos((todos) =>
      todos.map((todo) =>
        todo.id === id ? { ...todo, isDone: !todo.isDone } : todo
      )
    );
    ```
  - 과제 해설을 해 주시는 선생님께서 set 함수 안에 특정 값이 아닌 콜백함수를 사용하는 것이 **`useState`의 비동기성**과 관련이 있다고 해서, "`useState`의 비동기성"에 대해서 공부해보기로 했다.

- 리액트의 `useState` 훅은 **상태를 업데이트할 때 비동기적으로 동작**한다.

  - 이것은 리액트가 **상태 업데이트를 예약**하고, **다음 렌더링 사이클에서 해당 상태를 적용**한다는 것을 의미한다.
  - 따라서 `setTodos()` 함수를 호출하여 상태를 업데이트할 때, **해당 상태가 즉시 업데이트되는 것이 아니라**, 리액트가 상태 업데이트를 예약하고, 나중에 다음 렌더링 사이클에서 적용된다.

- `setTodos((todos) => [...todos, newTodos]);`와 같은 코드에서는 이전 상태를 가져와서 새로운 항목을 추가한 후, 그것을 새로운 상태로 추가한다.

  - 이 과정에서 **이전 상태의 변경 여부와 관계없이 항상 최신의 상태를 사용**한다.
  - 이러한 방식으로 리액트는 **상태의 일관성을 유지**하고, **예상치 못한 동작을 방지**한다.

- 따라서 `setTodos()` 함수를 사용할 때 **함수형 업데이트**를 사용하여 이전 상태를 기반으로 새로운 상태를 설정하는 것은 리액트의 상태 업데이트 메커니즘과 관련이 있다.

  - 이를 통해 비동기적으로 상태가 업데이트되는 동작이 보장된다.

- `setTodos()` 함수를 사용하는 두 가지 방식의 차이점

  - 코드 1
    ```jsx
    setTodos([...todos, newTodo]);
    ```
    - **이전 상태에 새로운 요소를 직접 추가**한다.
    - `todos` 배열을 펼친 후 새로운 요소 `newTodo`를 추가하여 새로운 배열을 만들어 `setTodos()` 함수를 통해 상태를 업데이트한다.
    - **기존 상태를 변경**하고 **새로운 배열을 반환**하는 방식으로 동작한다.
  - 코드 2
    ```jsx
    setTodos((todos) => [...todos, newTodo]);
    ```
    - 함수를 인자로 전달하여 **이전 상태를 받아 새로운 상태를 게산하고 반환하는 함수**를 사용한다.
    - 이전 상태를 받아와 새로운 요소 `newTodo`를 추가한 새로운 배열을 만들어 반환하는 함수를 전달한다.
    - 리액트의 **함수형 업데이트** 메커니즘을 활용하여 상태 업데이트를 처리한다.
  - 두 가지 방식의 주요 차이점
    - **동기/비동기 업데이트**
      - 첫 번째 방식은 **동기적**으로 상태를 업데이트하며, **즉시 새로운 상태가 반영**된다.
      - 반면에 두 번째 방식은 함수를 통해 상태를 업데이트하므로 리액트는 해당 함수를 나중에 실행하여 상태를 업데이트한다.
      - 따라서 두 번째 방식은 **비동기적**으로 상태를 업데이트하며, **이전 상태에 대한 최신 값을 보장**한다.
    - **이전 상태 보장**
      - 두 번째 방식은 이전 상태를 보장하는 것에 중점을 둔다.
      - 리액트는 이전 상태를 인자로 받아온 함수를 실행하여 ~~~

- `useState`의 비동기성의 특징
  - **비동기 업데이트**
    - `useState`로 상태를 업데이트할 때 리액트는 즉시 해당 상태를 업데이트하지 않고, 업데이트가 예약된 작업을 수행한다.
    - 이러한 작업은 리액트의 내부 메커니즘에 의해 관리되며, 업데이트된 상태를 컴포넌트에 반영하기 위해 다음 렌더링 사이에 예약된다.
  - **일괄 처리**
    - 리액트는 여러 상태 업데이트를 일괄 처리하여 성능을 최적화한다.
    - 여러 `useState` 호출로 인한 여러 상태 업데이트가 있더라도 리액트는 이를 하나의 업데이트로 결합하여 처리한다.
    - 이렇게 함으로써 여러 번의 렌더링이 발생하지 않고, 한 번의 렌더링 사이클에 모든 업데이트가 적용된다.
  - **큐잉 메커니즘**
    - 리액트는 상태 업데이트를 큐에 넣어두고, 이벤트 루프의 다음 사이클에서 처리한다.
    - 이러한 큐잉 메커니즘은 리액트가 다양한 업데이트를 효율적으로 관리하고, 컴포넌트으 불필요한 재렌더링을 방지한다.
  - **비동기 처리 순서**
    - `useState`로 상태를 업데이트할 때의 순서는 비동기적이다.
    - 예를 들어, 여러 개의 `useState` 호출이 있을 때, 각 호출이 즉시 상태를 업데이트하지 않고, 다음 렌더링 사이클에서 일괄 처리된다.
  - **최신 상태 보장**
    - 리액트는 이전 상태를 보장하기 위해 새로운 상태를 결정하는 과정에서 최신 상태를 고려한다.
    - 이를 통해 다양한 비동기 작업이 있더라도 상태의 일관성을 유지할 수 있다.
  - 따라서 리액트에서의 `useState`는 상태 업데이트가 비동기적으로 처리되며, 일괄 처리되어 효율적으로 관리된다.
  - 이를 통해 리액트는 성능을 향상키시고, 컴포넌트의 동작을 예측 가능하게 한다.

## 5. 제어 컴포넌트와 비제어 컴포넌트
