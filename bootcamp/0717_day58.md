## 0717_Day58

리액트 스탠다드 16일차 강의 내용 정리

## 1. Next.js의 개념

- 리액트 프레임워크로, 개발자가 보다 쉽게 웹 애플리케이션을 만들 수 있도록 도와준다.

  - 프레임워크 vs. 라이브러리

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fdfefd765-c2d8-4ef1-84a2-385753944636%2FUntitled.png?table=block&id=a6971072-c5f3-4d23-82d3-b83a4b13a4f8&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=700&userId=&cache=v2)

    - 프레임워크를 설명할 때 핵심 단어는 **제어의 역전(Inversion Of Control)** 이다.

    - 리액트를 사용할 때는 개발자가 라이브러리를 직접 호출하고 제어하지만, Next.js에서는 프레임워크가 주도적으로 애플리케이션의 흐름을 관리하며 필요한 라이브러리를 호출한다.

    - Next.js에서는 별도로 개발자가 라우팅 설정이나 렌더링 설정을 위해 코딩할 필요없이 **Next.js에서 제공하는 규칙과 구조를 따르기만 하면 된다.**

## 2. Next.js의 폴더 기반 라우팅

- **`app` 폴더 아래**에서의 **폴더명 URL PATH**로 동작한다.

- URL 구조

  ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fccc90ddf-4a82-494f-a153-ad4037dc7925%2FUntitled.png?table=block&id=4870317f-e7b3-4249-8031-599c2db143b1&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

  ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F9eabb60a-2a73-46e7-b2f2-d6ee9a20f397%2FUntitled.png?table=block&id=9f5af859-5a88-4d68-bfd7-29afba3cc1c2&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

- 레이아웃

  - **`layout.tsx` 파일**이 있으면 **같은 디렉터리에 있는 `page.tsx`와 그 하위에 있는 `page.tsx` 파일에 모두 레이아웃이 적용**된다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fe01cb5b4-fc82-412f-9909-ac6e4d6a383d%2FUntitled.png?table=block&id=c2a8fd2f-22d4-43fc-b8bc-39f0042bd6b0&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1000&userId=&cache=v2)

- 동적 라우팅

  - 별도의 라우터 컴포넌트와 `useParams` 훅을 사용할 필요 없이 간단하게 **상세 컴포넌트의 props로 params 접근이 가능**하다.

    ```tsx
    // src/app/detail/[id]/page.tsx

    const DetailPage = ({ params }: { params: { id: string } }) => {
      return <div>Detail 페이지: {params.id}</div>;
    };

    export default DetailPage;
    ```

- Link 컴포넌트

  - 일반 리액트와 동일하게 **Client Side Navigation** 방식으로 페이지가 이동한다.

    ```tsx
    <Link href="/detail" />
    ```

- `(routeGroup)`

  - URL PATH에 포함되지 않지만 그 **하위의 폴더들은 PATH에 포함**된다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F8caa05b9-8cc3-4a47-9e0c-ea7cb007c039%2FUntitled.png?table=block&id=57c48771-2afc-499c-b311-063728838c55&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1000&userId=&cache=v2)

  - `(routeGroup)` 폴더별로 **별도의 `layout.tsx`를 가질 수 있다.**

- `_privateFolder`

  - **URL PATH에서 완전히 제외**된다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fd33243aa-9d5c-4be5-bbb6-abb5b06710e8%2FUntitled.png?table=block&id=3fac5af4-8b6b-4a64-87ce-88dd67c28923&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1000&userId=&cache=v2)

  - **특정 도메인(폴더) 내에서만 사용하는 컴포넌트들을 정리**하고 싶을 때 유용하다.

## 3. Next.js의 4가지 렌더링 방식

### 1. SSG (Static Site Generation)

- Next.js의 기본 렌더링 방식

- 바뀌지 않는 정적인 컴포넌트에 적합한 렌더링 방식

- **빌드 시 해당 컴포넌트를 100% 프리렌더링** 해놓고 클라이언트에 제공한다.

- 빌드 시에 미리 페이지를 만들어 놓고, 사용자가 해당 라우트에 들어왔을 때 바로 화면에 보여줄 수 있는 HTML 파일을 클라이언트에 줘서 화면을 그리는 렌더링 방식

- **개발 모드(`yarn dev`)에서는 SSG를 확인할 수 없다.**

  - **SSG를 확인하려면 빌드(`yarn build`)를 별도로 진행해야 한다.**

  - 참고로 GitHub를 통해서 vercel에 배포 진행 시 빌드가 동작한다.

### 2. ISR

- **빌드 시 해당 컴포넌트를 100% 프리렌더링** 해놓고, **일정 시간이 지나면 사용자 요청에 따라 페이지를 재생성**하는 렌더링 방식

- 두 가지 ISR 적용 방법

  1. Route Segment Config

     - `layout.tsx` 파일 또는 `page.tsx` 파일 또는 `route.ts` 파일에 다음 코드를 추가한다.

       ```tsx
       export const revalidate = 5; // 5초 간격의 ISR
       ```

  2. `fetch` 옵션

     - `page.tsx` 파일에서 `fetch()` 메서드를 사용할 때, 옵션을 다음과 같이 추가한다.

       ```tsx
       fetch("https://jsonplaceholder.typicode.com/todos/1", {
         next: { revalidate: 5 },
       });
       ```

### 3. SSR

- **사용자 요청마다 매번 서버 컴포넌트가 실행**되면서 **완성한 HTML을 브라우저에 제공**한다.

- **동적 라우팅**(예: 홈->상세화면 이동)인 경우, **기본 렌더링 방식**이 SSG가 아닌 **SSR**이 된다.

- 두 가지 SSR 적용 방법

  1. Route Segment Config

     - `layout.tsx` 파일 또는 `page.tsx` 파일 또는 `route.ts` 파일에 다음 코드를 추가한다.

       ```tsx
       export const dynamic = "force-dynamic";
       ```

  2. `fetch` 옵션

     - `page.tsx` 파일에서 `fetch()` 메서드를 사용할 때, 옵션을 다음과 같이 추가한다.

       ```tsx
       fetch("https://jsonplaceholder.typicode.com/todos/1", {
         cache: "no-store",
       });
       ```

       - "no-cache" 옵션은 "no-store"와 동일한 방식으로 작동한다.

### 4. CSR

- 컴포넌트 최상단에 `"use client"`를 넣어주면 브라우저에서 동작할 수 있는 클라이언트 컴포넌트로 인식한다.

- `"use client"`

  - 해당 컴포넌트를 **클라이언트 컴포넌트**로 사용하겠다는 뜻이다.

  - 즉, **브라우저에서 동작할 수 있는 컴포넌트**임을 의미한다.

    - `useState`, `useEffect` 등의 **리액트 훅**들을 대부분 브라우저 환경에서만 동작한다.

    - `onClick`, `onChange`, `onSubmit`과 같은 **이벤트 핸들러**는 브라우저 환경에서만 동작한다.

    - `window.addEventListener`, `window.setTimeout`과 같이 **브라우저 전역 객체인 `window`** 는 브라우저 환경에서만 동작한다.

  - `"use client"`로 선언되어도 **서버 사이드 렌더링이 가능한 부분은 프리렌더링이 된다.** 그러나 그렇다고 무분별하게 `"use client"`를 사용하는 것은 지양해야 한다.

## 4. 페이지 이동 방식

- Link 컴포넌트

- `useRouter`

## 5. 라우트 핸들러 (Route Handler)

## 6. `<Image />` 컴포넌트

## 7. 환경변수 처리

## 8. Next.js 스타일링 시 tailwind css를 권장하는 이유

## 9. SEO를 고려한 metadata
