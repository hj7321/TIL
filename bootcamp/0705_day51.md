## 0705_Day51

<TypeScript 문법 종합반> 1주차(TypeScript를 시작하기 전에 알아야 할 것들) 강의 내용 정리 부분

## 1. JavaScript의 약점

- JavaScript와 Node.js

  - JavaScript가 나온 이유

    - 자바스크립트는 원래 웹페이지에 동적인 효과를 주기 위해 만들어진 스크립트 언어이다.

    - 웹페이지의 부드러운 상호작용을 위해 HTML, CSS와 함께 사용되었다.

  - JavaScript의 발전

    - 시간이 지나면서 웹 브라우저 내에서 실행되는 자바스크립트의 성능을 높이고자 하는 니즈가 있었고, 구글에서 V8 엔진이라는 것을 만들어서 세상에 공개했다.

  - Node.js의 등장

    - 이것에 그치지 않고 V8 엔진의 우수한 성능을 기반으로 Node.js라는 플랫폼이 나왔다.

    - 이제 자바스크립트로도 백엔드를 작성할 수 있게 되었다.

    - 그래서 많은 자바스크립트 기반 프론트엔드 개발자들이 백엔드 개발을 할 수 있게 되었다.

- Node.js의 잠재적 위험성

  - 프론트엔드 에러가 발생시키는 부작용

    - 프론트엔드의 에러는 사용자들이 보는 뷰의 일관성을 해칠 수는 있어도, 전반적인 동작에 피해를 끼치는 경우는 많지 않다.

  - 백엔드 에러가 발생시키는 잠재적 위험성

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3c133911-209f-455d-ad1b-3ea0be6c876b%2FUntitled.png?table=block&id=53a51067-e502-4d62-9e99-39a55f3d54f4&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=200&userId=&cache=v2)

    - 하지만, 예외 처리가 제대로 되지 않은 백엔드의 단순한 에러 하나로 인해 서버가 다운될 수 있다.

    - 즉, 웹페이지에 접속을 시도해도 접속을 할 수 없는 상태가 되어버린다.

- JavaScript의 약점

  1. **실행 시간에 결정되는 변수 타입**

     - 자바스크립트는 변수의 타입이 실행 시간에 결정된다.

     - 이에 따라 개발자의 실수로 인한 오류가 발생하기 쉽고 찾기도 까다롭다.

     - 예를 들면, 변수에 잘못된 타입의 값이 할당되어 발생한 오류를 찾기 위해서는 실행 시간에 변수의 값과 타입을 모두 확인해야 하는 번거로움이 있다.

  2. **약한 타입 체크**

     - 자바스크립트는 `let`, `const`와 같이 변수/상수를 구분하는 정도의 키워드만 지원된다.

     - 예를 들면, `let a = 1; a = "Hello";`와 같이 변수의 타입을 마음대로 바꿀 수 있고, 이렇게 되면 약간의 실수로 예상하지 않은 동작이 발생할 수 있다.

  3. **너무나도 물렁물렁한 객체**

     - 자바스크립트에서는 개발자가 객체의 성질을 수시로 변화시킬 수 있다.

     - 잘못된 코드 예시

       ```javascript
       const obj = { latitude: 11.5, longitude: 47.1 };
       const result = obj.latitude * obj.lonitute; // 오타로 인한 에러
       console.log(result); // NaN이라는 엉뚱한 값이 나온다.
       ```

## 2. TypeScript의 등장

- TypeScript는 Microsoft에서 개발한 오픈 소스 프로그래밍 언어이다.

- TypeScript는 자바스크립트의 단점을 상쇄하기 위해 개발되었다.

- TypeScript가 등장한 후 바뀐 내용

  1. **컴파일 시간에 변수의 타입을 체크**한다.

     - 자바스크립트 코드의 문제점

       ```javascript
       function add(a, b) {
         return a + b;
       }

       const result = add(1, "2");
       console.log(result); // "12"
       console.log(typeof result); // string
       ```

       - 덧셈 함수를 만들었으니 숫자 결과를 받아야 하는데, 문자열이 결과로 나온다.

       - 이러한 예상치 않은 코드들이 쌓이면 실제 서비스를 운영할 때 디버깅을 매우 힘들게 할 수 있다.

     - 타입스크립트 코드를 도입하고 난 후 달라진 점

       - **VSCode에서 오류 캐치**

         ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F973fc0be-71a5-4773-beaa-bfb56c162570%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.01.00.png?table=block&id=353dff43-f3aa-4235-820a-2d8069a96713&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=600&userId=&cache=v2)

         - VSCode에서는 코드를 입력하는 순간 에러 메시지를 발생시킨다.

       - **컴파일 시간에 오류 캐치**

         ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7bc448c0-d3d5-41a2-a0ce-45a4bea6d638%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.05.45.png?table=block&id=9e26eeda-7762-48b6-9a87-57247ed56923&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=600&userId=&cache=v2)

         - 편집기에서 코드 편집을 하지 않아도 문제가 없다.

         - 실제로 실행을 시키면 **컴파일 시간에 변수의 타입을 체크하기 때문에 실행이 되지 못하고 컴파일 에러를 발생시켜서 쓸데없는 에러 걱정을 하지 않아도 된다.**

  2. **VSCode에 코드를 입력하는 순간 에러 메시지가 발생한다.**

     - 서버가 실행되기 전에는 막연히 두려웠던 부분에 대해 걱정하지 않아도 된다.

       ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc59a61f0-d545-4bc6-bf3f-3a3692d99233%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.49.11.png?table=block&id=11bc97d4-9967-42db-a8b8-355f52211e24&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=600&userId=&cache=v2)

     - 정의되지 않은 프로퍼티를 연산하여 NaN이 되는 현상을 미연에 방지할 수 있다.

       ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4721db26-b5f4-47aa-a965-2e9002c67a22%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.55.46.png?table=block&id=f335066c-acf3-4f0b-8e1e-648ba3eb04ee&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=600&userId=&cache=v2)

- 타입스크립트의 장점

  - 객체 지향 프로그래밍(OOP)을 할 때 자바스크립트에 비해 타입스크립트가 가지는 이점

    - 자바스크립트 객체 지향 프로그래밍 예시

      ```javascript
      class Person {
        constructor(name, age) {
          this.name = name;
          this.age = age;
        }

        growOlder() {
          this.age += 1;
        }
      }

      const spartan = new Person("Spartan", 30);
      spartan.age = 25; // 외부에서 age 속성을 마음대로 조작할 수 있다.
      spartan.growOlder();
      console.log(spartan.age); // 26
      ```

      - 객체 지향 프로그래밍 언어(C++, Java, C# 등)에서는 다양한 접근 제어자를 통해서 클래스를 구성하는 프로퍼티의 캡슐화를 보장하고 함수의 호출 범위를 조정할 수 있다.

      - 그런데 위의 예제에서는 아무나 속성에 직접 접근을 할 수 있고 마음대로 속성의 값을 변경할 수 있다.

      - 클래스 내의 속성 값을 마음대로 변경할 수 있으면 시스템의 근간을 해칠 수 있기 때문에 위험하다.

    - 타입스크립트 객체 지향 프로그래밍 예시

      ```typescript
      class Person {
        private name: string;
        private age: number; // age가 private이다.

        constructor(name: string, age: number) {
          this.name = name;
          this.age = age;
        }

        public growOlder(): void {
          this.age += 1;
        }
      }

      const spartan = new Person("Spartan", 30);
      spartan.age = 25; // Error: Property 'age' is private and only accessible within class 'Person'.
      spartan.growOlder();
      console.log(spartan.age); // Error: Property 'age' is private and only accessible within class 'Person'.
      ```

      - age 속성이 private이기 때문에 에러가 난다.

- 외부 모듈의 타입 정보 제공

  - 타입스크립트는 `.d.ts`라는 확장자를 가진 선언 파일을 통해서 외부 모듈 타입 정보를 제공할 수 있다.

  - 이렇게 선언 파일을 설치하면 자바스크립트 라이브러리도 타입스크립트에서 안전하게 사용할 수 있다.

## 3. TypeScript를 배우면 할 수 있는 것

1. 취업 시장에서 필수 기술 스택 보유하기

   - 타입스크립트 개발자에 대한 수요 증가

     - 타입스크립트는 최근 몇 년동안 인기와 수요가 꾸준히 증가하고 있다.

     - 이로 인해, 타입스크립트는 프론트엔드, 백엔드를 가리지 않고 꼭 알아야 하는 기술 스택이 되었다.

   - 자바스크립트 -> 타입스크립트로 옮겨가는 흐름

     - 이제 순수 자바스크립트 기반 프로젝트를 진행하는 회사는 많이 없다.

     - 기존 자바스크립트 프로젝트는 타입스크립트로 전환하는 추세이고, 새로운 프로젝트는 대부분 타입스크립트를 사용해 개발하고 있다.

     - 타입스크립트를 능숙하게 다루는 개발자들에게 높은 수요가 있고, 이를 통해 취업 기회가 늘어난다.

2. 더 높아지는 생산성 & 안전성 경험하기

   - 향상되는 생산성

     - 처음에는 익숙하지 않아서 자바스크립트를 쓸 때보다 시간이 더 걸릴 수 있다.

     - 하지만 조금만 익숙해지면 타입스크립트로 작성하는 것이 더 편해진다.

   - 높아지는 안전성

     - 타입스크립트 코드는 안전성과 가독성이 높아져 개발 및 유지 보수 과정에서 시간과 노력을 절약할 수 있다.

     - 정적 언어에 익숙한 프로그래머들과의 협업도 더 빠르고 원활하게 할 수 있다.

3. 자연스러운 고급 프로그래밍 개념 학습하기

   - 타입스크립트를 통해 경험할 수 있는 것

     - **정적 타입 시스템, 객체 지향 프로그래밍, 디자인 패턴** 등 다양한 고급 프로그래밍 개념들을 학습할 수 있다.

   - 코어 개발자로 성장하는 지름길

     - 이를 통해 전문성이 높은 개발자로 성장하고, 다양한 프로젝트에서 활용 가능한 지식을 쌓을 수 있다.

4. 줄어드는 테스트 코드

   - 자바스크립트에 비해 언어에서 보장되는 안전성을 바탕으로 테스트 코드는 줄어든다.

   - 타입스크립트는 자바스크립트에 비해 테스트 코드보다 비지니스 로직 작성에 집중할 수 있다.

<br>
<hr>
<br>

<TypeScript 문법 종합반> 2주차(TypeScript 입문하기) 강의 내용 정리 부분

## 4. 컴파일러와 tsc

- **컴파일러**

  - **프로그래밍 언어로 작성된 소스 코드를 다른 프로그래밍 언어로 변환하는 도구**이다.

  - 이러한 변환 과정에서 컴파일러는 소스 코드의 구문과 구조를 검사하여 문제가 없는지 확인한다.

  - 이를 통해 개발자가 작성한 코드에 오류가 있는 경우 미리 알려주어 문제를 해결할 수 있다.

- 컴파일러의 근본적인 역할

  1. **타입 검사**

     - 타입스크립트 컴파일러는 **소스 코드의 정적 타입 검사**를 수행한다.

     - 이를 통해 개발자는 코드에서 타입 관련 오류를 미리 발견하고 수정할 수 있게 된다.

  2. **코드 변환**

     - 타입스크립트 컴파일러인 tsc는 **타입스크립트를 자바스크립트로 코드 변환**을 해준다.

     - C언어 컴파일러는 C언어를 기계어로 코드 변환을 해준다.

     - 컴파일러를 이해하면 변환된 코드가 어떻게 실행되는지 예측할 수 있고, 이는 디버깅 과정에서 큰 도움이 된다.

- 컴파일러의 장점

  - **에러 메시지를 해석할 때 도움**을 받을 수 있다.

    - 컴파일러는 소스 코드에서 문제가 발견되면 에러 메시지를 출력한다.

    - 컴파일러를 이해하면 에러 메시지를 보다 정확하게 해석하고 문제를 신속하게 해결할 수 있다.

  - **최적화**가 가능하다.

    - 코드가 최적화되면 **전반적인 애플리케이션 실행 시간이 더 빨라진다.**

    - 컴파일러는 이러한 것들을 자동으로 도와주는 매우 유익한 도구이다.

- 컴파일러 등장 배경

  - 컴퓨터는 기본적으로 기계어로 작성된 프로그램만 이해할 수 있다.

  - 그런데 기계어는 사람이 이해하기 어렵다.

  - 따라서 C언어와 같은 고수준 프로그래밍 언어가 등장한 것이다.

  - 그런데 C언어로 작성된 코드를 컴퓨터가 이해하려면 기계어로 변환을 하는 도구가 필요하게 되었고, 그 도구가 바로 컴파일러이다.

- 타입스크립트 컴파일러: **tsc**

  - **자바스크립트는 동적 언어(인터프리터 언어)이기 때문에, 기계어로 변환될 필요가 없다.**

    - Node.js나 Chrome 환경에서 자바스크립트를 실행할 때는 V8 엔진이 코드 해석 및 실행을 한다.

    - Firefox 환경에서 자바스크립트를 실행할 때는 SpiderMonkey가 코드 해석 및 실행을 한다.

  - 따라서 **정적 언어(컴파일 언어)는 기계어로 변환**이 되어야 하지만, **동적 언어(인터프리터 언어)는 엔진이 코드를 한 줄씩 실행하면서 동적으로 해석**한다.

  - tsc의 주요 명령어

    - `tsc --init` : `tsconfig.json`이 생성된다.

    - `tsc index.ts` : `index.ts` 파일을 컴파일한다.

    - `tsc src/*.ts` : src 디렉토리 안에 있는 모든 타입스크립트 파일을 컴파일한다.

    - `tsc index.js --declaration --emitDeclarationOnly` : @types 패키지를 위한 `.d.ts` 파일 생성을 하는 명령어이다. 이는 타입스크립트로 작성된 모듈이 아니라 자바스크립트로 작성된 모듈에 타입 선언을 제공할 때 유용하게 쓰인다.

## 5. `tsconfig.json` 파일

> - `compilerOptions - strict` 옵션은 `true`로 설정하는 것을 권장한다.
> - `compilerOptions - sourceMap` 옵션은 개발 환경에서 `true`로 설정하는 것을 권장한다.

- `tsc --init` 명령을 실행하면 생성되는 파일

- 타입스크립트 **프로젝트 설정 파일**

- 주로 프로젝트의 **컴파일 옵션** 및 **입력 파일**들을 정의하는 데 사용된다.

- 주요 옵션

  1. `compilerOptions - target` 옵션

     - 해당 **타입스크립트 프로젝트 내 코드들이 어떤 자바스크립트 버전으로 변환할지** 정하는 옵션이다.

       - 자바스크립트 버전 타임라인

         ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3fee88ad-58da-49cb-93ed-5af7b684d9c8%2FUntitled.png?table=block&id=bec3f887-1397-4ab0-a429-69e98000335d&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=600&userId=&cache=v2)

     - `es5`로 설정하면 CommonJS 버전으로 컴파일되고, `es2016(=es7)`로 설정하면 ES2016 버전으로 컴파일된다.

     - 최신 브라우저는 보통 ES2016을 지원하니 `es2016(=es7)`로 설정하는 것을 권장한다.

     - 단, 이것을 정할 때는 타입스크립트가 어느 환경에서 실행되어야 하는지 고려해야 한다.

       - 프로젝트가 레거시한 환경에서 동작해야 한다면 `es5`로 설정하고, 그렇지 않으면 `es2016`으로 설정한다.

  2. `compilerOptions - module` 옵션

     - 타입스크립트 파일을 컴파일한 후 생성되는 **자바스크립트 모듈의 형식을 지정**한다.

     - **모듈을 가져오고 내보내는 방식**을 결정하는 옵션이다.

     - `target` 옵션과는 서로 독립적인 관계이니, 프로젝트의 요구사항에 따라 옵션을 설정하면 된다.

  3. `compilerOptions - outDir` 옵션

     - **컴파일된 자바스크립트 파일이 저장될 출력 디렉터리를 지정**한다.

     - 예를 들어, `"outDir": "dist"`로 설정하면 컴파일된 파일들이 ` dist` 폴더에 저장된다.

  4. `compilerOptions - strict` 옵션

     - **엄격한 타입 검사 옵션을 모두 활성화**하는 옵션이다.

     - 타입스크립트 컴파일러가 보다 엄격한 타입 검사를 수행해 코드의 실수를 미리 찾아낼 수 있다.

     - 이 옵션을 `true`로 설정하면 아래의 옵션들이 자동으로 `true`로 설정된다.

       - `strictNullChecks` : 잠재적으로 `null`(`undefined`)이 될 수 있는 값들에 대해서 엄격하게 확인하는 옵션
       - `strictFunctionTypes`
       - `strictBindCallApply`
       - `strictPropertyInitialization`
       - `noImplicitAny` : 함수의 인자 또는 변수의 타입이 명시적으로 선언되지 않은 경우에 컴파일러가 자동으로 `any` 타입을 부여하지 않도록 하는 옵션
       - `noImplicitThis`
       - `alwaysStrict`

  5. `compilerOptions - sourceMap` 옵션

     - **컴파일된 자바스크립트 파일에 대한 소스맵을 생성**하는 옵션이다.

     - 소스맵을 사용하면 실행 중에 에러가 발생했을 때 원래 타입스크립트 소스 코드의 위치를 확인할 수 있다.

     - **코드 디버깅에 매우 큰 도움이 되기 때문에 개발 환경에서 꼭 `true`로 설정하는 것을 권장**한다.

     - 프로덕션 환경에서는 용량이나 성능상의 이유로 소스맵을 사용하지 않는 것이 더 나을 수도 있다.

  6. `include`, `exclude` 옵션

     - **tsc가 컴파일을 할 때 포함하거나 제외할 파일이나 디렉터리를 지정**하는 옵션이다.

     - `"include": ["src/**/*"]` : `src` 디렉터리 밑의 파일(디렉터리)들을 모두 컴파일한다.

     - `"exclude": ["node_modulees", "dist"]` : `node_modules`, `dist` 디렉터리 밑의 파일(디렉터리)들은 컴파일 대상에서 제외한다.

## 6. `.d.ts` 파일

- 타입스크립트가 나오기 전에는 자바스크립트로만 코드를 작성했기 때문에, 타입스크립트 코드의 양보다 자바스크립트 코드의 양이 많은 상태이다.

- 따라서 타입스크립트 코드는 이미 작성된 다양한 자바스크립트 라이브러리와 **호환성을 유지**할 수 있어야 한다.

- @types 라이브러리의 등장

  ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbcf59311-0dc6-4cf5-9a42-30ed3dd2a774%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-05-03_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.21.17.png?table=block&id=7d07184d-20e0-4677-98a8-f11eacbd1daf&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=300&userId=&cache=v2)

  - 타입스크립트는 **@types 라이브러리를 통해 외부 라이브러리에 대한 타입 정보를 제공**한다.

  - 해당 디렉토리를 들어가 보면 `.d.ts` 파일들이 많이 있는 것을 확인할 수 있다.

- `.d.ts` 파일

  - **타입스크립트 타입 정의 파일**

  - **자바스크립트 라이브러리에 대한 타입 정보를 제공**한다.

  - `.d.ts` 파일로 타입스크립트 컴파일러는 **외부 라이브러리의 함수 타입, 클래스 타입, 객체 타입 정보**를 알 수 있다.

  - 뿐만 아니라, `.d.ts` 파일로 **외부 라이브러리의 타입 추론**도 할 수 있다.

    - 타입 추론은 타입이 명시가 되지 않았을 때 컴파일러가 알아서 해당 타입에 대해 추론을 하는 것이다.

  - **자바스크립트 라이브러리를 타입스크립트에서 쓰려면 해당 라이브러리에 대한 `.d.ts` 파일만 제공하면 된다.**

  - 타입스크립트 프로젝트에서도 자바스크립트 라이브러리를 한 줄도 수정하지 않고 그대로 쓸 수 있다.

- 실습 - 자바스크립트 라이브러리를 타입스크립트 프로젝트에서 사용해보기

  1. 터미널에 다음 명령을 입력하여 Node.js 프로젝트를 생성한다.

     ```
     npm init -y
     ```

  2. 터미널에 다음 명령을 입력하여 `tsconfig.json` 파일을 생성하여 타입스크립트 프로젝트로 변환한다.

     ```
     tsc --init
     ```

  3. `tsconfig.json` 파일을 열어서 아래의 옵션을 주석 해제하여 `true`로 설정한다.

     ```JSON
     "allowJs": true // 타입스크립트 프로젝트에 자바스크립트 파일을 허용함
     "checkJs": true // 자바스크립트 파일 타입을 체크함
     ```

  4. `test.js` 파일을 생성하여 타입스크립트에서 사용하고 싶은 커스텀 자바스크립트 라이브러리를 만든다.

     ```javascript
     /**
      * @param {number} a
      * @param {number} b
      * @returns {number}
      */
     export function add(a, b) {
       return a + b;
     }
     ```

     - 위의 주석문은 **JSDoc**으로, **API의 시그니처(인자, 리턴 타입)를 설명하는 HTML 문서 생성기**이다.

     - **JSDoc으로 자바스크립트 소스 코드에 대한 타입 힌트를 제공**할 수 있다.

  5. 터미널에 다음 명령을 입력하여 JSDoc으로 타입 힌트가 제공된 `test.js`의 `.d.ts` 파일을 만든다.

     ```
     npx tsc test.js --declaration --allowJs --emitDeclarationOnly
     ```

  6. `types/test.d.ts` 파일을 확인하면 다음과 같이 생성되어 있다.

     ```typescript
     /**
      * @param {number} a
      * @param {number} b
      * @returns {number}
      */
     export function add(a: number, b: number): number;
     ```

  7. `test.js` 파일을 참조할 `foo.ts` 파일을 새로 만든다.

     ```typescript
     import { add } from "./test";
     console.log(add(1, 2));
     ```

  8. 터미널에 다음 명령을 입력하여 `foo.ts` 파일을 실행시킨다. 실행하면 3이라는 숫자가 뜨며 정상적으로 실행이 됨을 확인할 수 있다.

     ```
     npx ts-node foo.ts
     ```

## 7. 실습 - 성적표 프로그램 만들기

- 프로그램 기능

  - 학생 정보 및 시험 점수 입력 기능

  - 평균 점수 및 학점 계산 기능

- 프로젝트 세팅

  1. 프로그램이 위치할 프로젝트 디렉토리를 새로 만든다.

  2. 해당 디렉토리로 이동해서 터미널에 다음 명령을 입력하여 Node.js 프로젝트를 생성한다.

     ```
     npm init -y
     ```

  3. 터미널에 다음 명령을 입력하여 `tsconfig.json` 파일을 생성하여 타입스크립트 프로젝트로 변환한다.

     ```
     tsc --init --rootDir ./src --outDir ./dist --esModuleInterop --module commonjs --strict true --allowJs true --checkJs true
     ```

     - `--rootDir ./src` : 프로그램의 소스 파일이 들어가는 경로는 `src` 디렉토리이다.

     - `--outDir ./dist` : 컴파일된 파일들이 들어가는 디렉토리는 `dist` 디렉토리이다.

     - `--esModuleInterop` : CommonJs 방식의 모듈을 ES 모듈 방식의 import 구문으로 가져올 수 있다.

  4. `package.json`의 "scripts" 항목을 다음과 같이 변경하여 타입스크립트 프로젝트 실행을 편하게 만든다.

     ```JSON
     "scripts": {
        "start": "tsc && node ./dist/index.js",
        "build": "tsc --build",
        "clean": "tsc --build --clean"
     }
     ```

  5. `src` 디렉토리를 생성한다.

- 프로그램 코딩

  1. `src` 디렉토리 안에 `index.ts`라는 파일을 만들고, 평균 점수에 따라서 학점을 부여하는 `assignGrade()` 함수를 만든다.

     ```typescript
     function assignGrade(avarage: number): string {}
     ```

     - 평균이 90점 이상이면 "A", 80점 이상이면 "B", 70점 이상이면 "C", 60점 이상이면 "D", 그 이하면 "F"를 주는 로직으로 코드를 작성한다.

     <details>
     <summary>assignGrade() 함수 코드</summary>

     ```typescript
     function assignGrade(average: number): string {
       if (average >= 90) return "A";
       else if (average >= 80) return "B";
       else if (average >= 70) return "C";
       else if (average >= 60) return "D";
       else return "F";
     }
     ```

     </details>

  2. 학생이 가져야 될 속성들을 정의해서 객체로 만든다.

     - **`interface`는 객체의 구조를 정의하는 방법**이다.

     - **객체가 특정 인터페이스를 구현하려면 인터페이스에 정의된 모든 속성을 가져야 한다.**

     <details>
     <summary>Student 인터페이스 코드</summary>

     ```typescript
     interface Student {
       name: string;
       age: number;
       scores: {
         korean: number;
         math: number;
         society: number;
         science: number;
         english: number;
       };
     }
     ```

     </details>

  3. Student라는 타입의 객체를 받아서 평균을 계산하는 `calculateAverage()` 함수를 만든다.

     ```typescript
     function calculateAverage(student: Student): number {}
     ```

     - Student 타입의 객체인 학생의 각 과목 점수를 합산해서 평균을 낸다.

     <details>
     <summary>calculateAverage() 함수 코드</summary>

     ```typescript
     function calculateAverage(student: Student): number {
       const sum =
         student.scores.korean +
         student.scores.math +
         student.scores.society +
         student.scores.science +
         studnet.scores.english;
       const avearge = sum / Object.keys(student.scores).length;
       return average;
     }
     ```

     </details>

  4. Student를 생성하는 `createStudent()` 함수를 만든다.

     <details>
     <summary>createStudent() 함수 코드</summary>

     ```typescript
     function createStudent(
       name: string,
       age: number,
       korean: number,
       math: number,
       society: number,
       science: number,
       english: number
     ): Student {
       return {
         name,
         age,
         scores: {
           korean,
           math,
           society,
           science,
           english,
         },
       };
     }
     ```

     </details>

  5. 성적을 출력하는 `printResult()` 함수를 만든다.

     <details>
     <summary>printResult() 함수 코드</summary>

     ```typescript
     function printResult(student: Student): void {
       const average = calculateAverage(student);
       const grade = assignGrade(average);
       console.log(
         `${studnet.name} (${student.age}세) - 평균: ${average.toFixed(
           2
         )}, 학점: ${grade} `
       );
     }
     ```

     </details>

  6. 프로그램을 실행시키기 위한 `main()` 함수를 만든다.

     <details>
     <summary>main() 함수 코드</summary>

     ```typescript
     function main(): void {
       const spartan = createStudent("Spartan", 30, 95, 89, 76, 90, 97);
       printResult(spartan);
     }
     ```

     </details>

  7. 프로그램(`index.ts` 파일) 전체 코드는 다음과 같다.

     <details>
     <summary>index.ts</summary>

     ```typescript
     interface Student {
       name: string;
       age: number;
       scores: {
         korean: number;
         math: number;
         society: number;
         science: number;
         english: number;
       };
     }

     function createStudent(
       name: string,
       age: number,
       korean: number,
       math: number,
       society: number,
       science: number,
       english: number
     ): Student {
       return {
         name,
         age,
         scores: {
           korean,
           math,
           society,
           science,
           english,
         },
       };
     }

     function calculateAverage(student: Student): number {
       const sum =
         student.scores.korean +
         student.scores.math +
         student.scores.society +
         student.scores.science +
         student.scores.english;
       const avearge = sum / Object.keys(student.scores).length;
       return average;
     }

     function assignGrade(average: number): string {
       if (average >= 90) return "A";
       else if (average >= 80) return "B";
       else if (average >= 70) return "C";
       else if (average >= 60) return "E";
       else return "F";
     }

     function printResult(student: Student): void {
       const average = calculateAverage(student);
       const grade = assignGrade(average);
       console.log(
         `${student.name} (${student.age}세) - 평균: ${average.toFixed(
           2
         )}, 학점: ${grade}`
       );
     }

     function main(): void {
       const spartan = createStudent("Spartan", 30, 95, 89, 76, 90, 97);
       printResult(spartan);
     }

     main();
     ```

     </details>

  8. 터미널에 다음 명령을 입력하여 `index.ts` 파일을 빌드한다.

     ```
     npm run build
     ```

     - 컴파일 에러가 있으면 이 과정에서 에러가 난다.

     - `index.ts` 파일은 반드시 `src` 디렉토리 밑에 있어야 한다.

       ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F83aa79bb-977d-4b6a-9673-d56fa48428e8%2F%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-05-04_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.53.44.png?table=block&id=02f0d18b-28bc-48b7-8c7d-af7eb85d9f85&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=150&userId=&cache=v2)

  9. 컴파일이 완료되면 터미널에 다음 명령을 입력하여 `index.ts` 파일을 실행한다.

     ```
     npm run start
     ```

  10. 터미널에 아래와 같이 결과가 출력되면 성적표 프로그램이 성공적으로 실행된 것이다.

      ```
      Spartan (30세) - 평균: 89.40, 학점: B
      ```

<br>
<hr>
<br>

<TypeScript 문법 종합반> 3주차(기본 타입 익혀보기) 강의 내용 정리 부분

## 8. 타입을 제대로 알아야 하는 이유

- 변수와 타입

  - 변수: 데이터를 저장하는 공간

  - 변수에 저장되는 데이터는 숫자, 문자열, 논리값, 배열, 객체 등 여러 가지 타입이 있을 수 있다.

  - 타입을 이해하고 올바르게 사용하면 코드의 가독성과 안전성이 향상된다.

- 잘못된 타입을 사용하거나 예상치 못한 타입이 사용될 경우에는 오류가 발생할 수 있다.

  - 이러한 오류는 컴파일 타임에 발생하지 않고, 실행 시간에 발생한다.

  - 코드가 복잡해질수록 오류를 찾기 어려워진다.

  - 타입을 제대로 이해하면 이런 오류들을 미리 방지할 수 있다.

- **타입 안전성**

  - 타입 안전성은 **코드가 예상한 타입대로 동작함을 보장**하는 것이다.

  - 타입 안전성이 높을수록 코드 품질이 좋아지며 실행 시간에 발생할 수 있는 오류를 줄일 수 있다.

  - 타입을 제대로 이해하고 활용하면 코드의 안전성이 향상되며, 테스트와 디버깅 시간을 줄일 수 있다.

- **원활한 협업**

  - 타입을 명확하게 명시하고 사용하면 **코드의 가독성**이 높아진다.

  - 이는 곧 다른 개발자들이 코드를 이해하기 쉬워서 **유지보수가 용이**하다는 것을 의미한다.

- 타입스크립트는 정적 타입 시스템을 도입함으로써 이러한 이점들을 제공하고 있다.

- 개발자들이 더 안정적이고 효율적인 코드를 작성할 수 있게 도와준다.

- 이를 통해 프로젝트의 전반적인 품질이 향상되고, 더 나은 소프트웨어 개발 경험을 제공할 수 있다.

## 9. 기본 타입 훑어보기

1. boolean

   - 참(`true`) 또는 거짓(`false`) 값을 나타낸다.

   - 조건문, 비교 연산 등에서 주로 사용된다.

   - 2가지의 상태(켜짐/꺼짐, 유효함/유효하지 않음)를 표현하고 싶은 경우에는 boolean을 사용한다.

   - **3가지 이상의 상태를 표현**하고 싶은 경우에는 **enum이나 string을 사용**한다.

2. number

   - 타입스크립트에서 사용하는 모든 숫자를 나타낸다.

   - 보통 일반적인 프로그래밍 언어에서는 각 숫자의 유형마다 타입이 다르게 있다.

   - 하지만, 타입스크립트에서는 number 타입으로 정수, 실수뿐 아니라 2, 8, 16진수까지 표현할 수 있다.

   - 모든 수치 연산에 사용되는 값은 number 타입으로 명시한다.

3. string

   - 텍스트 데이터를 나타낸다.

   - 작은 따옴표, 큰 따옴표, 백틱을 사용하여 문자열을 표현할 수 있다.

   - 텍스트를 조작하거나 출력할 때 사용한다.

4. 배열

   - 기본 타입에 `[]`가 붙은 형태의 타입

5. **tuple (튜플)**

   - **서로 다른 타입의 원소를 순서에 맞게 가질 수 있는 특수한 형태의 배열**이다.

   - 튜플과 배열의 차이

     - 배열은 `number[]`, `string[]`처럼 **같은 타입의 원소**만 가질 수 있다.

       ```typescript
       const testScores: number[] = [90, 85, 78, 92, "88"]; // 에러
       ```

       - 위의 코드처럼 마지막 원소를 string 타입으로 넣으면 에러가 발생한다.

     - 튜플은 **어떤 타입의 원소를 허용할 것인지 정의만 해주면 된다.**

       ```typescript
       const person: [string, number, boolean] = ["Spartan", 25, false];
       const person2: [string, number, boolean] = [25, "Spartan", false]; // 에러
       ```

       - string, number, boolean이라는 3개의 각각 다른 타입의 데이터를 보관하도록 정의했다.

       - 원칙적으로는 데이터를 더 저장하는 것은 타입 안정성에 위배가 되는 행위이다.

       - 따라서 **정의된 데이터 타입의 개수와 순서에 맞추어 저장**을 하는 것이 필수이다.

         - `person` 튜플은 정의된 데이터 타입의 순서에 맞추어 저장했기 때문에 잘 저장된다.

         - `person2` 튜플은 정의된 데이터 타입의 순서에 맞추어 저장하지 않았기 때문에 에러가 발생한다.

       - 튜플에서도 배열의 메서드인 `push()`를 사용하여 정의된 데이터 타입의 개수보다 더 저장할 수는 있다.

         - 하지만 이렇게 억지로 데이터를 넣으면 튜플 구조가 내부적으로 변경되니 좋은 선택은 아니다.

6. **enum**

   - **열거형 데이터 타입**이다.

   - 다양한 상수를 보다 더 이해하기 쉬운 문자열 이름으로 접근하고 사용할 수 있게 하는 타입이다.

   - enum 안에 있는 각 요소는 값이 설정되어 있지 않으면 **기본적으로 숫자 0부터 시작**한다.

   - enum 안에 있는 요소에는 **number 또는 string 타입의 값만을 할당**할 수 있다.

   - enum은 **명확하게 관련된 상수 값들을 그룹화하고자 할 때 사용**하는 것이 좋다.

   - 값의 수가 많지 않고, 값들 사이의 관계가 뚜렷하지 않으면 enum을 사용하지 않는 것이 좋다.

   - 예제

     ```typescript
     enum UserRole {
      ADMIN = "ADMIN"
      EDITOR = "EDITOR"
      USER = "USER"
     }

     enum UserLevel {
      NOT_OPERATOR, // 0
      OPERATOR // 1
     }

     function checkPermission(userRole: UserRole, userLevel: UserLevel): void {
      if (userLevel === UserLevel.NOT_OPERATOR) console.log("당신은 일반 사용자 레벨이에요.");
      else console.log("당신은 운영자 레벨이에요.");

      if (userRole === UserRole.ADMIN) console.log("당신은 어드민입니다.");
      else if (userRole === UserRole.EDITOR) console.log("당신은 에디터입니다.");
      else console.log("당신은 사용자입니다.");
     }

     const userRole: UserRole = UserRole.EDITOR;
     const userLevel: UserLevel = UserLevel.NOT_OPERATOR;
     checkPermission(userRole, userLevel);
     ```

## 10. `const`와 `readonly`

1. `let`

   - `let` 키워드를 사용하여 선언하면 변수가 된다.

   - 변수는 값을 변경할 수 있다.

2. `const`

   - `const` 키워드를 사용하여 선언하면 상수가 된다.

   - 상수는 값을 변경할 수 없다.

   - 값을 변경할 수 없다는 의미는 할당 연산자(`=`)로 다시 할당이 불가능하다는 뜻이다.

3. **`readonly`**

   - 타입스크립트에서 등장한 키워드이다.

   - 타입스크립트에서 **객체의 속성을 불변**으로 만드는 데 사용되는 키워드이다.

   - 즉, **클래스의 속성이나 인터페이스의 속성을 변경할 수 없게 만든다.**

   - 예제

     ```typescript
     class Person {
       readonly name: string;
       readonly age: number;

       constructor(name: string, age: number) {
         this.name = name;
         this.age = age;
       }
     }

     const person = new Person("Spartan", 30);

     console.log(person.name); // "Spartan"
     console.log(person.age); // 30

     person.name = "Jane"; // 에러
     person.age = 25; // 에러
     ```

     - **`name`과 `age`는 `readonly` 속성이므로 다시 할당할 수 없다.**

     - 클래스의 속성에 `const` 키워드를 사용할 수 없다.

     - `const` 키워드는 일반 변수를 상수화할 때 사용한다.

## 11. any, unknown, union

1. **any**

   - **모든 타입의 슈퍼 타입**이다.

   - **어떤 타입의 값이든 저장**할 수 있다.

   - 자바스크립트의 `object` 타입과 같은 최상위 타입이라고 생각하면 된다.

   - 예제

     ```typescript
     let anything: any;
     anything = 5; // 최초에는 숫자를 넣었지만
     anything = "hello"; // 문자열도 들어간다.
     anything = { id: 1, name: "John" }; // JSON도 들어간다.
     ```

   - 타입스크립트를 사용하는 주된 이유 중 하나는 프로그램의 타입 안정성을 확보하기 위한 것이다.

   - 그런데, any 타입은 코드의 안정성과 유지보수성을 저해할 수 있으므로, 가급적 사용하지 말아야 한다.

2. **unknown**

   - **any 타입과 비슷한 역할**을 하지만 **더 안전한 방식**으로 동작한다.

   - any 타입과 마찬가지로 **어떤 타입의 값이든 저장**할 수 있다.

   - 하지만, **그 값을 다른 타입의 변수에 할당하려면 명시적으로 타입을 확인**해야 한다. (**타입 단언**)

   - 예제

     ```typescript
     let unknownValue: unknown = "문자열입니다.";
     console.log(unknownValue); // 문자열입니다.

     let stringValue: string;
     stringValue = unknownValue; // 에러: unknownValue가 string 타입임이 보장되지 않기 때문
     stringValue = unknownValue as string; // 타입 단언
     console.log(stringValue); // 문자열입니다.
     ```

   - **unknown 타입의 변수를 다른 곳에서 사용하려면 타입 단언(Type Assertion)을 통해 타입 보장을 하여 사용할 수 있다.**

   - **`typeof` 키워드를 이용하여 타입 체크를 미리 한 후 unknown 타입의 변수를 string 타입의 변수에 할당할 수도 있다.**

     ```typescript
     let unknownValue: unknown = "문자열입니다.";
     let stringValue: string;

     if (typeof unknownValue === "string") {
       stringValue = unknownValue;
       console.log("unknownValue는 문자열입니다.");
     } else {
       console.log("unknownValue는 문자열이 아닙니다.");
     }
     ```

   - 한계점: **재할당이 일어나지 않으면 타입 안전성이 보장되지 않는다.**

3. **union**

   - unknown 타입의 한계점을 극복하기 위해 union 타입이 사용된다.

   - **여러 타입 중 하나를 가질 수 있는 변수를 선언**할 때 사용한다.

   - `|` 연산자를 사용하여 **여러 타입을 결합하여 표현**한다.

   - 예제

     ```typescript
     type StringOrNumber = string | number;

     function processValue(value: StringOrNumber) {
       if (typeof value === "string") {
         // value는 여기서 string 타입으로 간주된다.
         console.log("String value: ", value);
       } else if (typeof value === "number") {
         // value는 여기서 number 타입으로 간주된다.
         console.log("Number value: ", value);
       }
     }

     processValue("Hello"); // String value: Hello
     processValue(42); // Number value: 42
     ```

- 타입스크립트를 사용하면서 **여러 타입을 하나의 변수로 해결하겠다는 생각은 가급적 지양**해야 한다.

<br>
<hr>
<br>

<TypeScript 문법 종합반> 4주차(고급 타입 활용하기) 강의 내용 정리 부분

## 12. enum과 object literal 비교하기

- object literal(객체 리터럴)의 형태

  ```typescript
  const obj = {
    a: [1, 2, 3],
    b: "b",
    c: 4,
  };
  ```

  - 겉으로 보면 enum과 매우 흡사하지만, `enum`이라는 키워드 대신 `const`, `let` 키워드를 사용한다.

  - 객체 리터럴은 **키, 값의 쌍(pair)으로 구성된 객체를 정의**하는 방식이다.

  - 위의 예제 코드에서는 a, b, c라는 키가 있고 각각 [1, 2, 3], "b", 4라는 값으로 바인딩이 되어 있다.

- enum에 비해 object literal이 가지는 장점

  - enum의 각 멤버는 상수이기 때문에 number, string 타입의 값만 대입할 수 있다.

  - object literal은 **어떤 타입의 값도 대입할 수 있다.**

  - 즉, 객체 리터럴은 **다양한 데이터 타입을 지원**하며 **유연한 구조**를 가진다.

  - 또한, 객체 리터럴은 코드 내에서 **사용하기 전에 값이 할당**되어야 하므로 **런타임 에러를 방지**할 수 있다.

- enum을 쓰면 좋은 경우

  - **간단한 상수 값을 그룹화**해서 관리할 때 적합하다.

  - enum은 상수 값이기 때문에 **각 멤버의 값이 변하면 안 될 때** 적합하다.

- object literal을 쓰면 좋은 경우

  - **멤버의 값이나 데이터 타입을 마음대로 변경**해야 할 때 적합하다.

  - **복잡한 구조와 다양한 데이터 타입을 사용**해야 할 때 적합하다.

## 13. 유틸리티 타입

1. **Partial&lt;T&gt;**

   - 타입 T의 모든 속성을 **선택적**으로 만든다.

   - 이를 통해 **기존 타입의 일부 속성**만 제공하는 객체를 쉽게 생성할 수 있다.

   - 예제

     ```typescript
     interface Person {
       name: string;
       age: number;
     }

     const updatePerson = (person: Person, fields: Partial<Person>): Person => {
       return { ...person, ...fields };
     };

     const person: Person = { name: "Spartan", age: 30 };
     const changedPerson = updatePerson(person, { age: 31 });
     ```

     - Person이라는 인터페이스는 `name`, `age`라는 두 개의 속성으로 구성되어 있다.

     - `updaetPerson()` 함수의 두 번째 인자로 `Partial<Person>` 타입의 `fields`를 받고 있다.

     - 이 `fields`라는 인자가 구성이 될 수 있는 경우의 수는 다음과 같다.

       1. `name`이라는 속성만 있어도 된다.

       2. `age`라는 속성만 있어도 된다.

       3. `name`, `age` 속성이 둘 다 있어도 된다.

       - `{ name, gender }`와 같이 기존에 없는 속성을 넣는 것은 허용하지 않는다.

2. **Required&lt;T&gt;**

   - 타입 T의 모든 속성을 **필수적**으로 만든다.

   - **T 타입 객체에 정의된 모든 속성**이 반드시 전부 제공이 되는 객체를 생성해야 할 때 사용된다.

   - 예제

     ```typescript
     interface Person {
       name: string;
       age: number;
       address?: string;
     }

     type RequiredPerson = Required<Person>;
     ```

     - Person 인터페이스의 `address` 속성에 `?`라는 문자가 붙어 있다.

       - 이는 **선택적 속성**임을 의미한다.

       - 즉, Person 인터페이스를 사용할 때 있어도 되고 없어도 되는 속성이다.

     - 하지만, **`address` 속성을 필수적으로 받아야 하는 제약사항**이 있을 때 위와 같이 `Required<Person>` 타입을 사용하면 된다.

3. **Readonly&lt;T&gt;**

   - 타입 T의 모든 속성을 **읽기 전용**(read-only)으로 만든다.

   - 이를 통해 `readonly` 타입의 속성들로 구성된 객체가 아니어도 **완전한 불변 객체로 취급**할 수 있다.

   - 예제

     ```typescript
     interface DatabaseConfig {
       host: string;
       readonly port: number; // 인터페이스에서도 readonly 타입 사용이 가능하다.
     }

     const mutableConfig: DatabaseConfig = {
       host: "localhost",
       port: 3306,
     };

     const immutableConfig: Readonly<DatabaseConfig> = {
       host: "localhost",
       port: 3306,
     };

     mutableConfig.host = "somewhere";
     immutableConfig.host = "somewhere"; // 에러
     ```

     - DatabaseConfig는 `host` 속성이 `readonly`가 아니기 때문에 불변 객체가 아니다.

     - 하지만, `ReadOnly<DatabaseConfig>` 타입으로 불변 객체로 만들 수 있다.

4. **Pick<T, K>**

   - **타입 T에서 K 속성들만 선택**하여 새로운 타입을 만든다.

   - 이를 통해 타입의 일부 속성만을 포함한 새로운 타입을 쉽게 생성할 수 있다.

   - 예제

     ```typescript
     interface Person {
       name: string;
       age: number;
       address: string;
     }

     type SubsetPerson = Pick<Person, "name" | "age">;

     const person: SubsetPerson = { name: "Spartan", age: 30 };
     ```

     - SubsetPerson은 Person이라는 인터페이스에서 `name`, `age` 속성만 선택해서 구성된 새로운 타입이다.

5. **Omit<T, K>**

   - **타입 T에서 K 속성들만 제외**하여 새로운 타입을 만든다.

   - 이를 통해 타입의 특정 속성만을 제외한 새로운 타입을 쉽게 생성할 수 있다.

   - 예제

     ```typescript
     interface Person {
       name: string;
       age: number;
       address: string;
     }

     type SubsetPerson = Omit<Person, "address">;

     const person: SubsetPerson = { name: "Alice", age: 30 };
     ```

     - SubsetPerson은 Person이라는 인터페이스에서 `address` 속성만 제외해서 구성된 새로운 타입이다.

## 14. 실습 - 별다방 프로그램 만들기

- 프로그램 기능

  - 음료 등록 기능 (어드민)

  - 음료 삭제 기능 (어드민)

  - 음료 조회 기능 (어드민, 고객)

  - 음료 주문 기능 (고객)

  - 음료 준비 완료 기능 (어드민)

  - 음료 수령 기능 (고객)

- 프로젝트 세팅

  1. 프로그램이 위치할 프로젝트 디렉토리를 새로 만든다.

  2. 해당 디렉토리로 이동해서 터미널에 다음 명령을 입력하여 Node.js 프로젝트를 생성한다.

     ```
     npm init -y
     ```

  3. 터미널에 다음 명령을 입력하여 `tsconfig.json` 파일을 생성하여 타입스크립트 프로젝트로 변환한다.

     ```
     tsc --init --rootDir ./src --outDir ./dist --esModuleInterop --module commonjs --strict true --allowJs true --checkJs true
     ```

     - `--rootDir ./src` : 프로그램의 소스 파일이 들어가는 경로는 `src` 디렉토리이다.

     - `--outDir ./dist` : 컴파일이 된 파일들이 들어가는 디렉토리는 `dist` 디렉토리이다.

     - `--esModuleInterop` : CommonJS 방식의 모듈을 ES 모듈 방식의 import 구문으로 가져올 수 있다.

  4. `package.json`의 "scripts" 항목을 다음과 같이 변경하여 타입스크립트 프로젝트 실행을 편하게 만든다.

     ```JSON
     "scripts": {
        "start": "tsc && node ./dist/index.js",
        "build": "tsc --build",
        "clean": "tsc --build --clean"
     }
     ```

  5. `src` 디렉토리를 생성한다.

- 프로그램 코딩 - 인터페이스, 데이터 정의하기

  1. `src` 디렉토리 안에 `index.ts`라는 파일을 만들고, 유저에 대한 인터페이스를 정의한다. 유저는 어드민이나 고객 중 하나여야 한다.

     <details>
     <summary>유저 인터페이스 코드</summary>

     ```typescript
     interface User {
       id: number;
       name: string;
       role: "admin" | "customer";
     }
     ```

     </details>

  2. 음료에 대한 인터페이스를 정의한다. 음료는 이름, 가격 속성을 갖고 있어야 한다.

     <details>
     <summary>음료 인터페이스 코드</summary>

     ```typescript
     interface Beverage {
       name: string;
       price: number;
     }
     ```

     </details>

  3. 주문에 대한 인터페이스를 정의한다. 주문은 주문 ID, 주문한 고객의 ID, 주문한 고객 이름, 음료 이름, 상태 속성을 갖고 있어야 한다. 상태는 "placed"(주문), "completed"(제작 완료), "picked-up"(수취 완료)가 있다.

     <details>
     <summary>주문 인터페이스 코드</summary>

     ```typescript
     interface Order {
       orderId: number;
       customerId: number;
       customerName: string;
       beverageName: string;
       status: "placed" | "completed" | "picked-up";
     }
     ```

     </details>

  4. 어드민이 만든 음료들의 목록과, 고객이 주문한 내용 목록을 관리할 수 있는 데이터를 정의한다.

     <details>
     <summary>데이터 정의 코드</summary>

     ```typescript
     let beverages: Beverage[] = [];
     let orders: Order[] = [];
     ```

     </details>

- 프로그램 코딩 - 함수 구현하기

  1. 유저가 어드민인지 체크하는 `isAdmin()` 함수와 고객인지 체크하는 `isCustomer()` 함수 2개를 만든다.

     <details>
     <summary>isAdmin() 함수</summary>

     ```typescript
     function isAdmin(user: User): boolean {
       return user.role === "admin";
     }
     ```

     </details>

     <details>
     <summary>isCustomer() 함수</summary>

     ```typescript
     function isCustomer(user: User): boolean {
       return user.role === "customer";
     }
     ```

     </details>

  2. 음료 목록에 음료를 새롭게 등록하는 `addBeverage()` 함수를 만든다.

     ```typescript
     function addBeverage(user: User, name: string, price: number): void {}
     ```

     - 이 함수는 어드민만 호출할 수 있어야 한다.

     <details>
     <summary>addBeverage() 함수</summary>

     ```typescript
     function addBeverage(user: User, name: string, price: number): void {
       if (!isAdmin(user)) {
         console.log("권한이 없습니다.");
         return;
       }

       const newBeverage: Beverage = { name, price };
       beverages.push(newBeverage);
     }
     ```

     </details>

  3. 음료 목록에서 음료를 삭제하는 `removeBevearge()` 함수를 만든다.

     ```typescript
     function removeBeverage(user: User, beverageName: string): void {}
     ```

     - 이 함수는 어드민만 호출할 수 있어야 한다.

     <details>
     <summary>removeBeverage() 함수</summary>

     ```typescript
     function removeBeverage(user: User, beverageName: string): void {
       if (!isAdmin(user)) {
         console.log("권한이 없습니다.");
         return;
       }

       beverages = beverages.filter(
         (beverage) => beverage.name !== beverageName
       );
     }
     ```

     </details>

  4. 음료를 조회하는 `getBeverages()` 함수를 만든다.

     ```typescript
     function getBeverages(user: User): Beverage[] {}
     ```

     - 이 함수는 어드민 혹은 고객이면 호출할 수 있다.

     <details>
     <summary>getBeverages() 함수</summary>

     ```typescript
     function getBeverages(user: User): Beverage[] {
       if (!user) return [];
       return beverages;
     }
     ```

     </details>

  5. 음료를 찾는 `findBeverage()` 함수를 만든다.

     ```typescript
     function findBeverage(beverageName: string): Beverage | undefined {}
     ```

     - 이 함수가 있는 이유는 고객이 음료를 주문할 때 판매하지 않는 음료를 사는 것을 막기 위해서이다.

     <details>
     <summary>findBeverage() 함수</summary>

     ```typescript
     function findBeverage(beverageName: string): Beverage | undefined {
       return beverages.find((beverage) => beverage.name === beverageName);
     }
     ```

     </details>

  6. 음료를 주문하는 `placeOrder()` 함수를 만든다.

     ```typescript
     function placeOrder(user: User, beverageName: string): number {}
     ```

     - 이 함수는 고객만 호출할 수 있어야 하고, 엉뚱한 커피 주문은 막아야 한다.

     - 주문 ID를 리턴해야 한다.

     <details>
     <summary>placeOrder() 함수</summary>

     ```typescript
     function placeOrder(user: User, beverageName: string): number {
       if (!isCustomer(user)) {
         console.log("권한이 없습니다.");
         return -1;
       }

       if (!findBeverage(beverageName)) {
         console.log("해당 음료를 찾을 수 없습니다.");
         return -1;
       }

       const newOrder: Order = {
         orderId: orders.length + 1,
         customerId: user.id,
         customerName: user.name,
         beverageName,
         status: "placed",
       };
       orders.push(newOrder);
       return newOrder.orderId;
     }
     ```

     </details>

  7. 고객이 주문한 음료가 준비가 완료되었다는 동작을 담당하는 `completeOrder()` 함수를 만든다.

     ```typescript
     function completeOrder(user: User, orderId: number): void {}
     ```

     - 이 함수는 어드민만 호출할 수 있어야 한다.

     <details>
     <summary>completeOrder() 함수</summary>

     ```typescript
     function completeOrder(user: User, orderId: number): void {
       if (!isAdmin(user)) {
         console.log("권한이 없습니다.");
         return;
       }

       const order = orders.find((order) => order.orderId === orderId);

       if (order) {
         order.status = "completed";
         console.log(
           `[고객 메시지] ${order.customerName}님~ 주문하신 ${order.beverageName} 1잔 나왔습니다!`
         );
       }
     }
     ```

     </details>

  8. 음료를 수령하는 `pickUpOrder()` 함수를 만든다.

     ```typescript
     function pickUpOrder(user: User, orderId: number): void {}
     ```

     - 이 함수는 고객만 호출할 수 있어야 한다.

     <details>
     <summary>pickUpOrder() 함수</summary>

     ```typescript
     function pickUpOrder(user: User, orderId: number): void {
       if (!isCustomer(user)) {
         console.log("권한이 없습니다.");
         return;
       }

       const order = orders.find(
         (order) => order.orderId === orderId && order.customerId === user.id
       );

       if (order && order.status === "completed") {
         order.status = "picked-up";
         console.log(
           `[어드민 메시지] 고객 ID[${order.customerId}]님이 주문 ID[${orderId}]를 수령했습니다.`
         );
       }
     }
     ```

     </details>

- 테스트 코드를 포함한 별다방 프로그램(`index.ts`) 전체 코드

  <details>
  <summary>index.ts</summary>

  ```typescript
  interface Beverage {
    name: string;
    price: number;
  }

  interface User {
    id: number;
    name: string;
    role: "admin" | "customer";
  }

  interface Order {
    orderId: number;
    customerId: number;
    customerName: string;
    beverageName: string;
    status: "placed" | "completed" | "picked-up";
  }

  let beverages: Beverage[] = [];
  let orders: Order[] = [];

  function isAdmin(user: User): boolean {
    return user.role === "admin";
  }

  function isCustomer(user: User): boolean {
    return user.role === "customer";
  }

  function addBeverage(user: User, name: string, price: number): void {
    if (!isAdmin(user)) {
      console.log("권한이 없습니다.");
      return;
    }

    const newBeverage: Beverage = { name, price };
    beverages.push(newBeverage);
  }

  function removeBeverage(user: User, beverageName: string): void {
    if (!isAdmin(user)) {
      console.log("권한이 없습니다.");
      return;
    }

    beverages = beverages.filter((beverage) => beverage.name !== beverageName);
  }

  function getBeverages(user: User): Beverage[] {
    if (!user) return [];
    return beverages;
  }

  function findBeverages(beverageName: string): Beverage | undefined {
    return beverages.find((beverage) => beverage.name === beverageName);
  }

  function placeOrder(user: User, beverageName: string): number {
    if (!isCustomer(user)) {
      console.log("권한이 없습니다.");
      return -1;
    }

    if (!findBeverages(beverageName)) {
      console.log("해당 음료를 찾을 수 없습니다.");
      return -1;
    }

    const newOrder: Order = {
      orderId: orders.length + 1,
      customerId: user.id,
      customerName: user.name,
      beverageName,
      status: "placed",
    };
    orders.push(newOrder);
    return newOrder.orderId;
  }

  function completeOrder(user: User, orderId: number): void {
    if (!isAdmin(user)) {
      console.log("권한이 없습니다.");
      return;
    }

    const order = orders.find((order) => order.orderId === orderId);

    if (order) {
      order.status = "completed";
      console.log(
        `[고객 메시지] ${order.customerName}님~ 주문하신 ${order.beverageName} 1잔 나왔습니다!`
      );
    }
  }

  function pickUpOrder(user: User, orderId: number): void {
    if (!isCustomer(user)) {
      console.log("권한이 없습니다.");
      return;
    }

    const order = orders.find(
      (order) => order.orderId === orderId && order.customerId === user.id
    );

    if (order && order.status === "completed") {
      order.status = "picked-up";
      console.log(
        `[어드민 메시지] 고객 ID[${order.customerId}]님이 주문 ID[${order.orderId}]을 수령했습니다.`
      );
    }
  }

  function main() {
    // 어드민 생성
    const admin: User = {
      id: 1,
      name: "바리스타",
      role: "admin",
    };

    // 고객 생성
    const member1: User = {
      id: 2,
      name: "르탄이",
      role: "customer",
    };

    const member2: User = {
      id: 3,
      name: "꿈꾸는개발자",
      role: "customer",
    };

    // 음료 등록
    addBeverage(admin, "아메리카노", 4000);
    addBeverage(admin, "카페라떼", 4500);
    addBeverage(admin, "에스프레소", 3000);

    // 음료 삭제
    removeBeverage(admin, "에스프레소");

    console.log(
      `안녕하세요~ ${
        member1.name
      } 고객님! 별다방에 오신 것을 환영합니다. 저희는 ${JSON.stringify(
        getBeverages(member1)
      )}를 판매하고 있습니다.`
    );

    // 음료 주문
    const orderId1 = placeOrder(member1, "아메리카노");
    if (orderId1 > 0) {
      setTimeout(() => {
        completeOrder(admin, orderId1); // 음료 제작 완료
        pickUpOrder(member1, orderId1); // 음료 수령
      }, 1000);
    }

    console.log(
      `안녕하세요~ ${
        member2.name
      } 고객님! 별다방에 오신 것을 환영합니다. 저희는 ${JSON.stringify(
        getBeverages(member2)
      )}를 판매하고 있습니다.`
    );

    // 음료 주문
    const orderId2 = placeOrder(member2, "카페라떼");
    if (orderId2 > 0) {
      setTimeout(() => {
        completeOrder(admin, orderId2); // 음료 제작 완료
        pickUpOrder(member2, orderId2); // 음료 수령
      }, 3000);
    }
  }

  main();
  ```

  </details>
