## 0507_Day17

<프로그래머스 코딩테스트> 자바스크립트 문법 정리 부분
## 1. [두 개 뽑아서 더하기] `Set`
- 공부 계기
  - 이 문제를 풀 때 겹치는 요소들을 제거하기 위한 방법으로 `Set` 자료구조를 사용한 사람이 있었다.
    ```javascript
    function solution(numbers) {
      const temp = [];

      for (let i = 0; i < numbers.length; i++) {
        for (let j = i + 1; j < numbers.length; j++) {
          temp.push(numbers[i] + numbers[j]);
        }
      }

      const answer = [...new Set(temp)];
      return answer.sort((a, b) => a - b);
    }
    ```
  - `Set`에 대해서 공부한 적은 있지만 내용이 잘 기억이 안 나고, 개념을 제대로 알지 못해서 다시 한 번 공부하기로 했다.

- `Set`의 개념
  - 자바스크립트에서 제공하는 데이터 구조 중 하나로, 중복된 값을 허용하지 않는 컬렉션이다.
  - 원시 값과 객체 참조 모두를 저장할 수 있다.
    - **원시 값**
      - 데이터의 가장 기본적인 형태로, 변경할 수 없는 값
      - 종류: 숫자, 문자열, 불리언, null, undefined 등
    - **객체 참조**
      - 데이터와 메서드를 포함하는 복합적인 자료구조
      - 종류: 배열, 객체 등
      - 객체는 참조 타입이며, 변수에 할당되거나 함수의 매개변수로 전달될 때 해당 객체의 참조(메모리 주소)가 전달된다.
  - 주로 중복된 값을 제거하거나 고유한 값들을 모아놓는 데 사용된다.
  - 예를 들어, 배열에서 중복된 요소를 제거하고 유일한 값들만을 얻고 싶을 때 `Set`을 사용할 수 있다.
  - `Set`은 자주 사용되는 자료구조 중 하나이며, 유용한 기능을 제공한다.
  - `Set` 생성자를 사용하여 초기값으로 배열을 전달하면 해당 배열의 요소들이 `Set`에 추가된다.
    ```javascript
    const mySet = new Set(["apple", "banana", "orange"]);
    ```
    - "apple", "banana", "orange" 세 개의 값을 가지고 있는 배열을 생성하여 이를 `Set` 생성자에 전달하고 있다.
    - 이렇게 하면 `Set`에는 해당 배열의 요소들이 추가되어 생성된다.

- `Set`의 특징
  - **중복된 요소가 없다.**
    - `Set`에는 동일한 요소가 한 번만 존재한다.
    - 즉, 동일한 값을 여러 번 추가해도 한 번만 유지된다.
  - **순서가 없다.**
    - `Set`에 추가된 요소들은 삽입 순서에 따라 저장되지 않는다.
    - `Set`은 내무적으로 요소를 해시 테이블(hash table)에 저장한다.
    - 이러한 해시 테이블은 각 요소에 대해 해시 함수를 사용하여 고유한 해시 값을 생성하고, 이 값을 기반으로 요소를 저장하고 검색한다.
    - 따라서 `Set`에 요소를 추가할 때마다 요소가 저장되는 위치가 결정되는데, 이 위치는 삽입된 순서에 따라 정해지는 것이 아니라 해시 값에 따라 결정된다.
    - 즉, `Set`에 추가된 요소는 삽입된 순서와 상관없이 내부 해시 테이블의 특정 위치에 저장된다.
    - 따라서 `Set`에서는 요소를 순서대로 접근할 수 없다.
    - 만약 순서가 중요한 경우라면 배열을 사용하는 것이 더 적합하다.
    - `Set`은 요소의 유일성을 보장하고 검색 속도를 높이기 위해 사용되는 데이터 구조이며, 순서가 필요하지 않은 경우에 적합하다.
  - **반복 가능한(iterable) 객체**
    - `Set`은 반복 가능한 객체이다.
    - 따라서 반복문을 사용하여 `Set`의 각 요소에 접근할 수 있다.
      ```javascript
      const mySet = new Set(["apple", "banana", "orange"]);
      for (const item of mySet) {
        console.log(item);
      }
      // 출력 결과
      // apple
      // banana
      // orange
      ```
  - **메서드를 통한 요소 추가 및 삭제**
    - `Set`은 `add()`, `delete()`, `clear()` 등의 메서드를 통해 요소를 추가하거나 삭제할 수 있다.
    - `add()` 메서드를 사용한 요소 추가
      ```javascript
      const mySet = new Set();
      mySet.add("apple");
      mySet.add("banana");
      mySet.add("orange");
      console.log(mySet); // Set(3) { 'apple', 'banana', 'orange' }
      ```
    - `delete()` 메서드를 사용한 요소 삭제
      ```javascript
      const mySet = new Set(["apple", "banana", "orange"]);
      mySet.delete("banana");
      console.log(mySet); // Set(2) { 'apple', 'orange' }
      ```
    - `clear()` 메서드를 사용한 모든 요소 삭제
      ```javascript
      const mySet = new Set(["apple", "banana", "orange"]);
      mySet.clear();
      console.log(mySet); // Set(0) {}
      ```
  - **크기 속성**
    - `Set`은 `size` 속성을 통해 저장된 요소의 개수를 반환한다.

- 해석할 코드
  ```javascript
  const answer = [...new Set(temp)];
  ```
  - 중복된 값을 제거하기 위해 `Set` 객체를 활용하였다.
  - `Set` 객체는 중복된 값을 허용하지 않는 자료구조로, 한 번만 등장하는 값들을 모아둔다.
  - `Set` 객체는 배열이 아니므로 배열과 관련된 메서드를 사용할 수 없다.
  - 이를 해결하기 위해 전개 연산자(...)를 사용하여 배열 temp의 요소들을 넣어서 `Set` 객체를 생성함과 동시에 배열로 변환한다.
  - 이 과정에서 `Set`은 중복된 값들을 제거하고 유일한 값들만을 남겨둔다.
  - 이렇게 하면 `Set` 객체의 모든 요소들이 배열 answer에 복사되고, 중복된 값은 제거된 채로 배열에 저장된다.

## 2.  [두 개 뽑아서 더하기] 원본 배열을 변경하지 않고 복사본을 유지하는 방법
- 공부 계기
  - 이 문제를 풀 때 numbers 배열을 num1 배열에 복사하는데 `slice()` 메서드를 사용한 사람이 있었다.
    ```javascript
    const num1 = numbers.slice();
    ```
  - 왜 `slice()` 메서드를 사용해서 배열을 복사했는지 궁금했는데 배열은 객체이기 때문이었다.
  - 이 점을 생각하지 못해서 배열의 특징에 대해서 다시 정리해야겠다는 생각이 들었다.

- 배열의 특징
  - 자바스크립트에서 배열은 객체이다.
  - 따라서 변수에 배열을 할당하면 실제로는 배열의 메모리 위치를 가리키는 참조(reference)가 변수에 저장된다.
  - 이 때문에 배열을 변수에 할당하면 변수는 해당 배열을 참조하게 된다.
  - 따라서 다음과 같이 배열을 복사하는 것은 원본 배열과 동일한 배열을 가리키게 된다.
    ```javascript
    const numbers = [1, 2, 3, 4, 5];
    const newArr = numbers; // 원본 배열을 가리킴
    numbers.push(6);
    console.log(newArr); // [ 1, 2, 3, 4, 5, 6 ]
    ```
    - newArr 배열은 numbers 배열을 가리키고 있다.
    - 따라서 numbers 배열에 변경이 발생하면 newArr에도 반영된다.
  - 원본 배열을 변경하지 않고 복사본을 유지하려면 `slice()` 메서드를 사용해야 한다.
    ```javascript
    const numbers = [1, 2, 3, 4, 5];
    const newArr = numbers.slice(); // 새로운 배열이 생성됨
    numbers.push(6);
    console.log(newArr); // [ 1, 2, 3, 4, 5 ]
    ```
    - `slice()` 메서드를 사용하여 배열을 복사하면 원본 배열과는 별개의 새로운 배열이 생성된다.
    - newArr 배열은 numbers 배열과 다른 곳을 가리키고 있다.
    - 따라서 numbers 배열에 변경이 발생해도 newArr에는 반영되지 않는다.

## 3. [가장 가까운 같은 글자] 전개 연산자 `...`
- 공부 계기
  - 이 문제를 풀 때 문자열 앞에 전개 연산자를 사용하여 각 문자 하나 하나를 손쉽게 배열의 요소로 만든 코드를 봤다.
  - 전개 연산자를 문자열 앞에 쓰는 코드가 생소해서 전개 연산자의 쓰임에 대해서 다시 한 번 정리해보기로 했다.

- 전개 연산자는 배열, 문자열, 맵(Map), 셋(Set) 등과 같은 반복 가능한(iterable) 객체를 각 요소로 분해하여 새로운 배열이나 객체를 생성한다.
  ```javascript
  const s = "hello";
  console.log(...s); // h e l l o
  console.log([...s]); // [ 'h', 'e', 'l', 'l', 'o' ]
  ```
  - `...s`는 문자열 s를 각 문자별로 분해한다.
  - `[...s]`는 문자열 s를 각 문자별로 분해하여 새로운 배열을 생성한다.

## 4. [가장 가까운 같은 글자] 시간복잡도 비교
- 공부 계기
  - [코드 1]: 나는 이 문제의 코드를 다음과 같이 작성했다.
    ```javascript
    function solution(s) {
      let splittedStr = s.split("");
      let answer = splittedStr.map((cur, idx) => {
        let newArr = splittedStr.slice(0, idx).reverse();
        let index = newArr.indexOf(cur);
        return index === -1 ? -1 : index + 1;
      });
      return answer;
    }
    ```
  - [코드 2]: 그리고 다른 사람은 다음과 같이 작성했다.
    ```javascript
    function solution(s) {
      const hash = {};

      return [...s].map((v, i) => {
        let result = hash[v] !== undefined ? i - hash[v] : -1;
        hash[v] = i;
        return result;
      });
    }
    ```
  - [코드 1](내가 작성한 코드)보다 [코드 2](다른 사람이 작성한 코드)를 실행했을 때의 속도가 훨씬 빨라서 두 코드의 시간복잡도를 비교해보기로 했다.
  - 그리고 이 비교를 토대로 코드를 작성할 때 시간복잡도를 고려하는 습관을 들여야겠다는 생각을 했다.

- [코드 1]의 시간복잡도 분석
  - 문자열의 길이를 n이라고 하자.
  - 문자열을 배열로 변환하고, 각 문자에 대해 순차적으로 탐색하면서 이전에 등장한 위치를 탐색한다.
  - 각 문자마다 이전에 등장한 위치를 찾기 위해 `slice()`와 `reverse()` 메서드를 사용하여 새로운 배열을 만들고, 그 배열에서 `indexOf()`를 사용하여 이전 등장 위치를 찾는다.
    - indexOf() 메서드는 배열을 처음부터 끝까지 순회하여 해당 요소를 찾는 과정을 거치기 때문에, 문자열의 길이에 비례하여 시간이 더 걸린다.
    - 첫 번째 문자는 문자열의 길이에 비례하는 1번의 작업이 필요하다.
    - 두 번째 문자는 이전에 등장한 문자가 한 개이므로 최대 문자열의 길이에 비례하는 2번의 작업이 필요하다.
    - 세 번째 문자는 이전에 등장한 문자가 두 개이므로 최대 문자열의 길이에 비례하는 3번의 작업이 필요하다.
    - 이렇게 문자열의 길이가 n일 때, n번째 문자는 최대 문자열의 길이에 비례하는 n번의 작업이 필요하다.
    - 따라서 문자열의 길이의 제곱에 비례하여 성능이 증가한다.
      > 1 + 2 + 3 + ... + n = n(n+1) / 2
  - 이는 각 문자마다 이전에 등장한 위치를 찾기 위해 **O(n^2)의 시간복잡도**를 가진다.

- [코드 2]의 시간복잡도 분석
  - 문자열의 길이를 n이라고 하자.
  - 문자열을 배열로 변환하고, 각 문자와 인덱스에 대해 `map()` 메서드를 사용하여 처리한다.
  - 이전에 등장한 위치를 저장하기 위해 객체 hash를 사용한다. 이 객체를 통해 각 문자의 이전 등장 위치를 상수 시간에 접근할 수 있다.
  - 이 방법은 각 문자에 대해 이전 등장 위치를 상수 시간에 찾기 때문에 **O(n)의 시간복잡도**를 가진다.

- [코드 1]과 [코드 2]의 시간복잡도 비교
  - [코드 1]에서는 각 문자마다 새로운 배열을 생성하고, 이 배열에서 해당 문자의 이전 등장 위치를 찾기 위해 `slice()`와 `reverse()` 메서드를 사용한다.
  - 이 작업은 문자열의 길이에 비례하여 중복되게 이루어진다.
  - 예를 들어, 문자열의 첫 번째 문자를 처리할 때는 한 번의 작업이 필요하지만, 두 번째 문자를 처리할 때는 두 번의 작업이 필요하고, 세 번째 문자를 처리할 때는 세 번의 작업이 필요하다.
  - [코드 1]에서는 각 문자마다 이전에 등장한 위치를 찾기 위해 불필요하게 중복된 작업을 수행하고 있기 때문에, 문자열의 길이의 제곱에 비례하여 성능이 증가한다.
  - 반면, [코드 2]에서는 객체를 사용하여 각 문자의 이전 등장 위치를 저장하고 있다.
  - 이렇게 하면 각 문자마다 한 번의 작업으로 이전 등장 위치를 찾을 수 있기 때문에 불필요한 작업이 반복되지 않는다.
  - [코드 2]는 각 문자마다 상수 시간 내에 이전 등장 위치를 찾을 수 있기 때문에 입력 문자열의 길이에 비례하여 성능이 증가한다.
  - 따라서 [코드 2]가 [코드 1]보다 훨씬 더 효율적으로 동작한다.

## 5. [가장 가까운 같은 글자] 시간복잡도와 실행 속도
- 공부 계기
  - [코드 3]: 이 문제를 다른 사람은 다음과 같이 풀었다.
    ```javascript
    const solution = (s) =>
      [...s].map((char, i) => {
        const count = s.slice(0, i).lastIndexOf(char);
        return count < 0 ? count : i - count;
      });
    ```
  - 위 코드의 실행 속도는 내 코드보다 훨씬 빠르지만, 시간복잡도는 O(n^2)로 같아서 시간복잡도와 실행 속도의 개념과 차이점에 대해 알아보고 싶었다.

- **시간 복잡도**
  - 알고리즘이 **입력 크기에 따라 얼마나 많은 계산을 수행하는지**를 나타낸다.
  - 보통 입력 크기를 n으로 표현하며, 시간 복잡도는 주어진 입력에 대해 알고리즘이 수행하는 연산의 횟수를 나타낸다.
  - 일반적으로 시간 복잡도는 입력 크기 n에 대한 함수로 표현되며, 이를 Big O 표기법으로 표현한다.
  - 표현 방법: O(n), O(n^2), O(log n) 등
  - 알고리즘의 실행 시간이 입력 크기에 대해 어떻게 증가하는지를 보여준다.

- **실행 속도**
  - 알고리즘이 **실제로 실행되는 속도**를 나타낸다.
  - 이는 CPU의 클럭 속도, 메모리 접근 시간, 캐시의 효율 등과 같은 다양한 하드웨어 및 소프트웨어 요소에 의해 영향을 받는다.
  - 실행 속도는 일반적으로 알고리즘의 시간 복잡도에 영향을 받지만, 코드의 구현 방식, 언어의 특성, 최적화 수준 등에 따라 다를 수 있다.

- 시간 복잡도와 실행 속도
  - 시간 복잡도와 실행 속도는 서로 다른 개념이지만, 일반적으로 시간 복잡도가 낮은 알고리즘은 실행 속도가 빠를 가능성이 높다.
  - 그러나 두 가지는 항상 일치하지 않을 수 있다.
  - 실행 속도는 알고리즘의 시간 복잡도뿐만 아니라 다양한 다른 요소에도 영향을 받기 때문이다.
  - 시간 복잡도는 알고리즘이 얼마나 빠르게 실행되는지를 나타내는 것이지만, 코드가 짧다고 무조건 시간 복잡도가 낮아지는 것은 아니다.
  - [코드 1]과 [코드 3] 모두 문자열의 각 문자에 대해 이전에 등장한 위치를 찾고, 해당 위치와 현재 위치 사이의 거리를 계산하여 반환한다.
    - 각 함수에서 문자열의 길이를 n이라고 할 때, 각 문자에 대해 최대 O(n)의 시간이 소요되므로 전체적으로는 **O(n^2)의 시간 복잡도**를 가지게 된다.
    - 시간 복잡도가 같아도 각 함수의 내부 동작이 다르기 때문에 실행 속도는 달라질 수 있다.
    - 특히 자바스크립트의 내장 함수를 사용할 때, 이 함수들이 최적화되어 있어서 더 효율적으로 동작할 수 있다.
    - 또한 코드의 효율성은 컴퓨터의 구조와 어떤 작업을 수행하는지에 따라 달라질 수 있다.
    - 따라서 두 코드가 시간 복잡도 면에서 동일하더라도 실제로 실행 속도가 다를 수 있다.

## 6. 