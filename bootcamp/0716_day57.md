## 0716_Day57

리액트 스탠다드 15일차 강의 내용 정리

## 1. Props Type은 함수 컴포넌트를 호출할 때 어떤 props를 내려줘야 하는지에 대한 지정된 타입이다.

- 함수 컴포넌트에서 필요 없는 props에 대한 타입 지정은 제거해야 한다.

  - `CountryList.tsx` 파일 내용 일부

    ```tsx
    <ul>
      {countries.map((country, index) => (
        <CountryCard
          key={index}
          country={country}
          setSelectedCountries={setSelectedCountries}
        />
      ))}
    </ul>
    ```

  - `CountryCard.tsx` 파일 내용 일부

    ```tsx
    interface CountryCardProps {
      country: Country;
      setSelectedCountries: React.Dispatch<
        React.SetStateAction<CountryWithIsSelected>
      >;
    }

    export default function CountryCard({
      country,
      setSelectedCountries,
    }: CountryCardProps) {
      // ...
    }
    ```

## 2. 배열 메소드 `map()`이나 `filter()` 실행 시 매개변수 타입 지정

- `map()`, `filter()` 메서드의 콜백 함수의 매개변수에는 타입을 지정하지 않는 것이 좋다.

  ```tsx
  const [todos, setTodos] = useState<Todo[]>([]);

  todos.map(todo:Todo => <li>...</li>); // 지양해야 하는 코드
  todos.map(todo => <li>...</li>); // 지향해야 하는 코드
  ```

## 3. 제네릭의 제약 조건

- **타입 매개변수**에 해당하는 **제네릭**에 **제약 조건**을 적용하고 싶다면 **`extends`** 를 사용한다.

  - 제네릭 T에 들어올 수 있는 타입에 대한 **제약 조건이 없는 경우**

    ```tsx
    type UserData<T> = {
      name: string;
      userKey: T;
    };
    ```

    - `userKey` 속성에는 **어떤 타입의 값**이든 들어올 수 있다.

  - 제네릭 T에 들어올 수 있는 타입에 대한 **제약 조건이 있는 경우**

    ```tsx
    type UserData<T extends string | number> = {
      name: string;
      userKey: T;
    };
    ```

    - `userKey` 속성에는 **문자열이나 숫자 타입의 값**만 들어올 수 있다.

  - 제네릭과 타입 제약 조건을 활용하여 특정 속성을 가진 타입을 처리하는 방법

    ```tsx
    type HasLength = {
      length: number;
    };

    function logLength<T extends HasLength>(item: T): void {
      console.log(item.length);
    }

    logLength("Hello, world!"); // 문자열은 length 속성을 가짐
    logLength([1, 2, 3, 4, 5]); // 배열은 length 속성을 가짐
    logLength({ length: 10, name: "Alice" }); // 이 객체는 length 속성을 가지고 있음
    logLength(123); // 오류: 숫자는 length 속성을 가지지 않음 -> 컴파일 타임에 타입 안전성 보장
    ```

    - `HasLength` 타입

      - `length`라는 숫자 속성을 반드시 포함해야 한다.

      - `length` 속성을 가진 모든 값을 대상으로 작업할 수 있는 다양한 구조에서 사용할 수 있다.

    - `logLength()` 함수

      - 함수의 매개변수 `item`은 타입 `T`를 가지며, `T`는 `HasLength` 타입을 확장한 것이다.

      - **`T`는 `length` 속성을 가진 타입**이어야 하므로, 함수 내의 **`item.length` 접근이 안전하게 보장**된다.

## 4. `keyof`

- **객체 타입의 키**들을 **문자열 리터럴 유니언 타입**으로 반환하는 타입 연산자

- 객체의 키를 기반으로 한 타임 안전성을 강화할 수 있다.

- 주로 **제네릭 타입, 매핑된 타입, 유니온 타입** 등을 정의할 때 유용하게 사용된다.

- 예제 1: 기본 사용법

  ```typescript
  type Person = {
    name: string;
    age: number;
    location: string;
  };

  type PersonKeys = keyof Person; // "name" | "age" | "location"
  ```

- 예제 2: 객체의 키를 사용한 제네릭 함수 정의

  ```typescript
  type Person = {
    name: string;
    age: number;
    location: string;
  };

  function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
  }

  const person: Person = {
    name: "John",
    age: 30,
    location: "New York",
  };

  const personName: string = getProperty(person, "name");
  const personAge: number = getProperty(person, "age");

  console.log(personName); // "John"
  console.log(personAge); // 30
  ```

  - `getProperty()` 함수는 객체와 키를 받아서 **해당 키의 값을 반환**한다.

  - 이때 **`K extends keyof T`** 를 통해 **키가 객체의 유효한 키**임을 보장한다.

- 예제 3: 매핑된 타입

  ```typescript
  type Person = {
    name: string;
    age: number;
  };

  type ReadonlyPerson = {
    readonly [K in keyof Person]: Person[K];
  };

  const readonlyPerson: ReadonlyPerson = { name: "Alice", age: 30 };

  readonlyPerson.age = 31; // 오류: 읽기 전용이므로 age에 값을 할당할 수 없음
  ```

  - `ReadonlyPerson` 타입은 `Person` 타입의 모든 키를 순회하며 해당 키들을 읽기 전용으로 설정한다.

    - **`[K in keyof Person]` : `Person` 타입의 키(`name`, `age`)를 순회한다.**

    - `keyof Person` : `"name" | "age"` 유니온 타입을 반환한다.

    - `Person[K]` : `Person` 타입의 각 키에 대응하는 값의 타입을 나타낸다. `Person["name"]`은 `string`, `Person["age"]`는 `number`이다.

    - `readonly` : 각 속성을 읽기 전용으로 만든다.

  - `ReadonlyPerson` 타입은 `Person` 타입과 동일한 구조를 가지지만, 모든 속성이 읽기 전용이다.

- 예제 4: 키와 값의 매핑 타입

  ```typescript
  type Person = {
    name: string;
    age: number;
  };

  type PersonMap = Record<keyof Person, string>;

  const personMap: PersonMap = {
    name: "Alice",
    age: "30",
  };
  ```

  - `PersonMap` 타입은 `Person` 타입의 키를 `string` 타입 값으로 매핑한다.

  - **`Record<keyof Person, string>`** : **`Person` 타입의 모든 키를 `string` 값으로 매핑**한다.

    - `keyof Person` : `Person` 타입의 모든 키를 유니온 타입으로 반환한다. 이 경우에는 `"name" | "age"`가 된다.

  - `personMap` 객체는 `PersonMap` 타입을 따르며, `name`과 `age` 속성을 각각 "Alice"와 "30" 값으로 초기화한다.

    - 여기서 **`age`는 원래 `Person` 타입에서는 `number`였으나, `PersonMap`에서는 `string` 타입으로 매핑**되었다.

## 5. `typeof`

- 자바스크립트에서의 `typeof`는 데이터 타입을 문자열로 리턴한다.

  ```javascript
  let num = 42;
  console.log(typeof num); // "number"

  let str = "Hello";
  console.log(typeof str); // "string"
  ```

- **타입스크립트**에서의 `typeof`는 컴파일 시간에 **변수의 타입(정적 타입)을 추론**한다.

  - 변수의 타입 추론

    ```typescript
    let x = 10;
    let y: typeof x; // number
    ```

  - 객체의 프로퍼티 타입 추론

    ```typescript
    const person = {
      name: "Alice",
      age: 30,
    };

    // 객체의 타입 추론 (typeof)
    type PersonType = typeof person; // { name: string; age: number; }

    // 객체 타입의 키들을 유니언 타입으로 추출 (keyof)
    type PersonKeys = keyof PersonType; // "name" | "age"

    // 제네릭 함수를 사용하여 객체의 특정 속성에 접근
    const getProperty = (
      obj: PersonType, // { name: string; age: number; }
      key: PersonKeys // "name" | "age"
    ): PersonType[PersonKeys] => {
      return obj[key];
    };

    const name = getProperty(person, "name"); // "Alice"
    const age = getProperty(person, "age"); // 30
    ```

  - 클래스의 인스턴스 타입 추론

    ```typescript
    class Car {
      brand = "Toyota";
      year = 2023;
    }

    let myCar: typeof Car;
    myCar = Car;

    const carInstance: MyCar = new myCar();
    ```

    - **`myCar`는 `Car` 클래스 자체를 가리키는 타입**이 되며, **`Car` 클래스의 인스턴스를 생성**할 수 있다.

  - 함수와 함수 시그니처 타입 추론

    ```typescript
    function greet(name: string) {
      console.log(`Hello, ${name}!`);
    }

    type GreetFunc = typeof greet; // (name: string) => void
    ```

## 6. 타입 좁히기(Type Narrowing)와 타입 가드 5가지

- **타입 좁히기 (Type Narrowing)**

  - 여러 가능한 타입 중 하나로 타입을 좁히는 과정

  - **코드 실행 중에 특정 값이 어떤 타입인지 확인**하고, 그 **타입에 맞는 로직을 적용**하는 것

- 타입 좁히기가 필요한 이유

  - **타입스크립트는 정적으로 타입을 검사**하지만, 코드 실행 중에 타입을 확인하고 그에 따라 다르게 동작해야 하는 경우가 많다.

  - 타입 좁히기를 통해 타입 안전성을 유지하면서도 다양한 타입에 대한 처리를 할 수 있다.

- **타입 가드 (Type Guard)**

  - **런타임**에 **조건문을 사용하여 타입을 검사**하고 타입 범위를 좁혀주는 기능

  - 타입 좁히기를 구현하기 위한 수단

1. 단순 조건문을 사용한 타입 가드

   ```typescript
   type User = {
     name: string;
     age?: number;
   };

   function printUserAge(user: User) {
     if (user.age !== undefined) {
       console.log(`User's age is ${user.age}`);
     } else {
       console.log("User's age is not provided.");
     }
   }
   ```

2. `typeof` 타입 가드

   ```typescript
   function printValue(value: string | number) {
     if (typeof value === "string") {
       console.log(`String: ${value.toUpperCase()}`);
     } else {
       console.log(`Number: ${value.toFixed(2)}`);
     }
   }

   printValue("Hello"); // String: HELLO
   printValue(42); // Number: 42.00
   ```

3. `instanceof` 타입 가드

   ```typescript
   import axios, { AxiosError } from "axios";

   async function fetchData(url: string) {
     try {
       const response = await axios.get(url);
       console.log("Data: ", response.data);
     } catch (error) {
       if (error instanceof AxiosError) {
         // AxiosError인 경우
         console.log("Axios error occurred");
       } else {
         // 일반 Error인 경우
         console.log("General error occurred");
       }
     }
   }
   ```

4. `in` 타입 가드

5. 사용자 정의 타입 가드

## 7. 객체 타입을 정의하는 6가지 방법

## 8. Record 타입 보충

## 9. Package Type

## 10. class에서 사용되는 타입

## 11. `useQuery`에 대한 타입 지정

## 12. `useMutation`에 대한 타입 지정

## 13. `useInfiniteQuery`에 대한 타입 지정

```

```
