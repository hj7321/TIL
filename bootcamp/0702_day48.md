## 0702_Day48

<React 심화> 강의 내용 정리 부분

# 1. 인증/인가 1 - 쿠키, 세션, 토큰, JWT

## 1. 인증(authentication)과 인가(authorization)

- **인증(Authentication)** : 서비스를 이용하려는 유저가 **등록된 회원인지 확인**하는 절차 (로그인 과정)

- **인가(Authorization)** : 인증을 받은 유저가 **특정 리소스에 접근할 수 있는 권한이 있는지 확인**하는 절차 (로그인이 일어난 이후의 과정)

- HTTP 프로토콜의 특징

  - **무상태(stateless)**

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F59468a9c-7c8d-4e78-9a25-6c3f45847359%2FUntitled.png?table=block&id=11ae80fb-bfae-4d2e-8bd0-1ecdf3cf2d16&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

    - **각 요청이 독립적**이며, **서버가 이전 요청에 대한 정보를 기억하지 않는다.**

    - 클라이언트가 서버에 요청을 보낼 때마다 서버는 해당 요청을 독립적으로 처리하고, 이전 요청의 상태나 정보를 기억하지 않는다.

    - 따라서 **각 요청마다 서버에서 요구하는 모든 상태 정보를 담아서 요청**해야 한다.

      - 상태값은 매 요청마다 클라이언트가 가지고 오기 때문에, 서버는 클라이언트의 상태를 별도로 기억할 필요없이 주문받은 대로 응답해준다.

      - 무상태라는 특성 덕분에 **동일한 서버를 여러 개로 확장**시킬 수 있다. (Scale-out)

        > **무상태 => scale out의 의미**
        >
        > **동일한 애플리케이션을 여러 대의 서버에 배포**하고, **부하를 관리할 수 있는 로드 밸런서를 이용해 들어오는 요청을 여러 서버로 분산**시킬 수 있다는 의미이다. 각 서버는 상태를 기억할 필요가 없기 때문이다.
        >
        > 이렇게 되면, 각 서버는 독립적으로 요청을 처리할 수 있기 때문에, 하나의 서버에 장애가 발생하더라도 다른 서버가 계속해서 요청을 처리할 수 있어 안전하다.

  - **비연결성(connectionless)**

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fdf1b2407-550c-4b34-8b92-9c2b074f829d%2FUntitled.png?table=block&id=39526ebb-9ee3-484d-b41b-227ffe288b36&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

    - **서버와 클라이언트는 연결되어 있지 않다.** 서버 입장에서는 매번 새로운 요청이다.

    - 비연결성으로 인해 **최소한의 서버 자원**으로 서버를 유지할 수 있게 해준다.

    - 각 사용자별 요청이 잦은 서비스의 경우, 이러한 비연결성은 오히려 비효율적일 수 있다.

## 2. 쿠키, 세션, 토큰

- **쿠키**

  - **브라우저에 저장**되는 작은 데이터 조각이며, **Key-value** 형태로 저장된다.

  - HTTP의 무상태성과 비연결성 특성에도 불구하고, 쿠키를 사용하여 마치 **서버가 클라이언트의 인증 상태를 기억하는 것처럼 구현**할 수 있다.

  - 쿠키는 별도로 삭제 처리하거나 유효기간이 만료되지 않는 한, 서버와 통신할 때 자동으로 주고받게 된다.

  - 서버에 특정 API 요청을 했을 때(예: 로그인 요청), **서버가 응답 시 헤더에 `Set-Cookie` 속성으로 쿠키 정보를 담아주면, 응답을 받은 브라우저는 쿠키를 브라우저에 자동으로 저장**한다.

  - 저장된 쿠키 정보는 개발자 도구 -> 애플리케이션 -> 저장용량 -> 쿠키 항목에서 확인할 수 있다.

    > 쿠키를 브라우저에 저장하는 주체는 주로 서버이다. 서버는 응답 헤더에 `Set-Cookie`를 포함시켜 브라우저에 쿠키를 저장하도록 지시할 수 있다.  
    > 하지만, **클라이언트 측에서도 자바스크립트를 사용하여 직접 쿠키를 설정할 수 있다.** 서버에서 브라우저에게 저장하도록 지시할 수 있다는 점에서는 로컬 스토리지나 세션 스토리지와는 다르다.

  - 서버에 http 요청을 할 때마다 브라우저에 저장되어 있는 쿠키는 자동으로 서버에 보내진다.

    - 단, **동일한 Origin 또는 CORS를 허용하는 Origin에만 쿠키를 보낸다.**

      - **Origin(출처)** : **protocol + host + port**

        ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fccc90ddf-4a82-494f-a153-ad4037dc7925%2FUntitled.png?table=block&id=840e3b86-3c4e-4d62-b652-3cf64f462c35&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1500&userId=&cache=v2)

      - **CORS(Cross Origin Resource Sharing)**

        - 다른 출처에 리소스 요청하는 것을 허용하는 정책

        - 브라우저는 보안상의 이유로 기본적으로 Same Origin Policy(SOP)를 원칙으로 하고 있지만, **서버와 클라이언트 각각 CORS 설정을 통해 상호 합의된 웹사이트는 예외적으로 서로 다른 출처(Cross-Origin)임에도 API 요청이 가능**하다.

    - 예: 유튜브 서버에서 받은 쿠키는 유튜브 이용 시에만 주고받을 수 있다.

  - **쿠키는 클라이언트에서 직접 추가/수정/삭제할 수 있다.**

- **세션을 이용한 인증 방식**

  - **세션**

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F5f5c2817-b5bc-4a5e-a71d-70c2c66ad7b9%2FUntitled.png?table=block&id=ba5629fd-1568-4cd3-9e51-17f01715e9d1&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=300&userId=&cache=v2)

    - **사용자와 서버 간의 연결이 활성화**된 상태 (**인증이 유지**되고 있는 상태)

    - 로그인 성공 -> 서버에서 세션 생성 및 저장(key-value 형식) -> key(sessionId)를 브라우저에 응답(by 쿠키)

  - 쿠키-세션 인증 방식

    - 로그인/회원가입 시 세션 인증 절차

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Ffc876fd8-84a3-469b-9637-86067d28b068%2FUntitled.png?table=block&id=366b78db-a5bb-443b-9c24-f081dd662863&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

    - **로그인/회원가입 성공 시 서버에서 쿠키에 sessionId를 담아서 보내준다.**

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F00512acf-d7f4-47bf-b4d4-fba81505d4f1%2FUntitled.png?table=block&id=85bd5864-9626-4550-8315-a7090dd440af&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

      - 세션 유지 상태 : 서버에서 관리하는 세션 저장소에 회원 데이터가 있다.

      - 세션 만료 상태 : 서버에서 관리하는 세션 저장소에 회원 데이터가 없다.

    - 인가(Authorization)가 필요한 API 요청/응답 절차

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fe970e3ca-7f30-4c53-8227-af10c264915c%2FUntitled.png?table=block&id=a6645786-5dff-4e47-95d2-c1ef69280d01&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

      - 서버는 인가가 필요한 API 요청을 받으면 **클라이언트 쿠키에 들어 있는 sessionId를 세션 저장소에서 조회**하고, 있으면 **DB에 데이터를 조회하여 응답**한다.

  - 세션 인증 방식의 한계

    - **확장성 문제**

      - 세션 정보는 서버의 메모리나 저장소에 저장되기 때문에, 서버가 많아질수록(예: 서버 확장 시) **세션 동기화 문제**가 발생한다.

      - **여러 서버가 동일한 세션 정보를 공유**해야 하므로, 이를 관리하기 위한 추가적인 복잡성이 필요하다.

      - 서버가 많다면 어느 유저가 어느 서버로 로그인했는지 등을 별도로 기억해야 하는 등 매우 복잡한 방식이 수반돼야 한다.

    - **메모리 사용량 증가**

      - 많은 사용자가 접속할 경우, 각 사용자의 세션 정보를 서버 메모리에 저장하는 방식은 메모리 사용량이 급증하게 된다.

      - 이는 **서버 성능 저하**와 **비용 증가**를 초래할 수 있다.

    - **상태 유지의 복잡성**

      - 세션은 서버에 상태를 저장하므로 **서버가 무상태(stateless)로 유지되기 어렵다.**

      - **RESTful 아키텍처의 원칙과 맞지 않는다.**

    - **보안 문제**

      - 세션 ID가 탈취될 경우, 이를 통해 사용자의 세션을 가로채는 **세션 하이재킹(Session Hijacking) 공격**이 발생할 수 있다.

- **토큰을 이용한 인증 방식**

  - **토큰**

    - **클라이언트에서 보관하는 암호화 또는 인코딩된 인증 정보**

      - 암호화와 인코딩의 차이점

        ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F4b8e81d1-f760-426f-a8e1-be09824567c8%2FUntitled.png?table=block&id=444f0e22-1d26-4a5e-9853-0521586a0853&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

        - **암호화**는 데이터를 특정 알고리즘으로 변환하여 **인가된 사용자만이 읽을 수 있도록 하는 과정**이며, **기밀성**을 유지한다.

        - **인코딩**은 데이터를 다른 형식으로 변환하여 **전송 및 저장을 용이하게 하는 과정**으로, **특별한 키 없이도 원래 형태로 복원**할 수 있다.

        - **암호화는 보안 목적, 인코딩은 데이터 처리 목적**이다. 암호화된 데이터는 복호화 키가 필요하지만, 인코딩된 데이터는 키 없이도 복원 가능하다.

    - **서버의 상태를 유지하지 않고도 클라이언트의 인증 상태를 확인**할 수 있게 해준다.

    - 세션처럼 서버에서 사용자의 인증 정보를 보관할 필요가 없기 때문에 서버 부담을 줄여주는 인증 수단이다.

    - **웹에서 인증 수단으로 사용되는 토큰**은 주로 **JWT(JSON Web Token)** 을 이용한다.

  - **JWT**

    - **세션 인증 방식의 한계를 극복**하기 위해 등장한 토큰 인증 방식에서 사용되는 특별한 토큰

    - **로그인한 사용자가 이후에 서버에 요청을 보낼 때 사용**된다.

    - JWT의 세 가지 부분

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F51afddc8-48d6-4dd8-a230-44d02646c86b%2FUntitled.png?table=block&id=abb88686-efa1-4425-8a35-54dda297e299&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1000&userId=&cache=v2)

      1. **헤더(Header)** : **어떤 종류의 토큰인지**와 **어떤 알고리즘으로 서명되었는지**에 대한 정보가 들어있다.

      2. **본문(Payload)** : 실제로 **중요한 데이터**가 들어있는 부분이다. 사용자 ID, 토큰의 만료 시간 등이 여기에 포함된다.

      3. **서명(Signature)** : **토큰이 위조되지 않았는지** 확인하는 역할을 한다. **서버만이 알 수 있는 비밀 키**로 서명되어 있다. 이 서명때문에 토큰의 무결성이 보장된다.

    - JWT의 특징

      - 국제 인터넷 표준 인증 규격 중 하나이다.

      - **인코딩된 토큰을 누구나 복호화하여 payload를 볼 수 있다.**

      - **토큰의 용도**는 인증 정보(payload)에 대한 보호가 아니라 **위조를 방지하기 위함**이다.

      - 정보(payload)를 토큰화할 때 signature에 secret key가 필요하고, secret key는 복호화가 아니라 토큰이 유효한지를 검증하는 데 사용된다.

  - JWT 토큰 인증 방식

    - 로그인/회원가입 시 토큰 인증 절차

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F24ec8fc5-9db0-4f75-af25-54c2b00f3780%2FUntitled.png?table=block&id=5c87ae6b-20cf-4fa8-a3d3-ad32255694a6&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

    - 인가(Authorization)가 필요한 API 요청/응답 절차

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F566c9bc7-fd4d-46e8-92ef-c7ac95b7c2bb%2FUntitled.png?table=block&id=eacf00e8-d04e-4d86-ab5d-8aa4d20486ca&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

    - **Refresh Token**으로 **보안을 강화**하는 것이 중요하다.

      - 다만, 이를 위해서는 각종 토큰을 발급해주는 영역의 백엔드 개발자와의 협업이 필요하다.

      - **리소스 접근 인가를 받기 위해 사용되는 토큰**을 **Access Token**이라고 부른다.

      - Access Token의 만료기간을 길게 잡고 인증 상태를 오래 가져갈 경우 서버 부담은 줄어드나 보안성(탈취 당할 경우)에 허점이 있다.

      - **인증 보안이 중요한 서비스의** 경우, 인증 시 2개의 토큰(Access Token, Refresh Token)을 발급한다. **Access Token**의 기간은 **30분** 정도로 짧게 가져가고, **Refresh Token**은 **1~2주** 정도로 길게 잡는 경우가 많다.

      - 이 경우 서버에서는 **Access Token이 만료**되었을 때, Refresh Token의 상태에 따라 다른 응답을 보낸다.

        - **Refresh Token이 유효한 상태**이면 **새로운 Access Token을 클라이언트에 발급해주고 인증 상태를 유지할 수 있도록 한다.**

        - **Refresh Token이 유효한 상태가 아니면(만료됐으면) 다시 로그인하라는 메시지를 응답한다.**

# 2. 인증/인가 2 - 실습

## 1. JWT 인증서버(API 서버) 소개

- 서버 API_URL : https://moneyfulpublicpolicy.co.kr/

  1. **회원가입** : 아이디, 비밀번호, 닉네임으로 DB에 본인의 회원정보를 저장한다.

     - Request(요청)

       - method: `POST`
       - URL PATH: `/register`
       - body
         ```json
         {
           "id": "유저 아이디",
           "password": "유저 비밀번호",
           "nickname": "유저 닉네임"
         }
         ```

     - Response(응답)

       ```json
       {
         "message": "회원가입 완료",
         "success": true
       }
       ```

  2. **로그인** : 아이디와 비밀번호가 DB에 있는 회원정보와 일치하면 `accessToken`, `userId`, `avatar`, `nickname` 총 4가지 유저 정보를 응답해 준다.

     - Request(요청)

       - method: `POST`
       - URL PATH: `/login`
       - body
         ```json
         {
           "id": "유저 아이디",
           "password": "유저 비밀번호"
         }
         ```
       - query string (선택)
         ```javascript
         /login?expiresIn=10m
         ```
         - `accessToken` 유효시간 조정을 위해 설정한다.
         - query string 없이 path로만 요청 시, 유효시간은 기본 1시간이다.
         - query string(expiresIn)으로 시간 기입 시, 해당 시간대로 토큰 유효시간을 조정할 수 있다.
         - expiresIn: 시간 단위를 붙인 문자열  
           예: 10s, 10m, 10h
         - **토큰 만료 시 로그아웃 처리되는 로직**을 테스트할 때 사용해보자.

     - Response(응답)

       ```json
       {
         "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImFiY2FiYyIsImlhdCI6MTcwMDgxNDQyMCwiZXhwIjoxNzAwODE4MDIwfQ.8hWOHHEzDPzumnqCU7jyoi3zFhr-HNZvC7_pzBfOeuU",
         "userId": "유저 아이디",
         "success": true,
         "avatar": "프로필 이미지",
         "nickname": "유저 닉네임"
       }
       ```

  3. **회원정보 확인** : `accessToken`이 유효한 경우, 비밀번호를 제외한 본인의 회원정보를 응답해 준다.

     ```javascript
     // authorization 속성 정의
     const response = await axios.get(`${BASE_URL}/user`, {
       headers: {
         "Content-Type": "application/json",
         Authorization: `Bearer ${accessToken}`,
       },
     });
     ```

     - Request(요청)

       - method: `GET`
       - URL PATH: `/user`
       - header
         ```json
         {
           "Authorization": "Bearer AccessToken"
         }
         ```

     - Response(응답)

       ```json
       {
         "id": "사용자 아이디",
         "nickname": "사용자 닉네임",
         "avatar": null,
         "success": true
       }
       ```

  4. **프로필 변경** : `accessToken`이 유효한 경우, 프로필 이미지 또는 닉네임을 FormData를 통해 요청하면 변경 완료된 이미지 URL과 닉네임을 응답해준다.

     ```javascript
     // 이미지 파일을 FormData에 담는 방법
     const formData = new FormData();
     // avatar와 nickname 중 하나 또는 모두 변경 가능
     formData.append("avatar", imgFile);
     formData.append("nickname", nickname);

     // 요청 시 Content-Type에 유의
     const response = await axios.patch(`${BASE_URL}/profile`, formData, {
       headers: {
         "Content-Type": "multipart/form-data",
         Authorization: `Bearer ${accessToken}`,
       },
     });
     ```

     - Request(요청)

       - method: `PATCH`
       - URL PATH: `/profile`
       - header
         ```json
         {
           "Authorization": "Bearer AccessToken"
         }
         ```
       - body
         ```json
         {
           "avatar": "이미지 파일",
           "nickname": "변경할 닉네임"
         }
         ```

     - Response(응답)

       ```json
       {
         "avatar": "변경된 이미지 URL",
         "nickname": "변경된 닉네임",
         "message": "프로필이 업데이트되었습니다.",
         "success": true
       }
       ```

- Thunder Client

  - HTTP 요청을 보내고 응답을 받는 데 필요한 모든 기능을 가지고 있는 도구

  - 이를 이용하면 손쉽게 API를 테스트하고 디버깅할 수 있다.

  - 설치 방법

    - VSCode Extension(확장) 탭에서 "thunder client" 검색 후 설치한다.

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F4614834d-2eb2-4ae0-8a38-2827eb45d2cc%2FUntitled.png?table=block&id=e9f843d5-426e-4c5e-ac5f-72a329ca2c6f&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1000&userId=&cache=v2)

    - VSCode 왼쪽 사이드바에서 Thunder Client 아이콘을 선택한다.

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F31f8b644-3b11-45f6-b920-271ea5f0a67b%2FUntitled.png?table=block&id=70cf83c3-4059-4a1f-8220-155ca3e4eeaf&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=100&userId=&cache=v2)

  - 기본 사용 방법

    1. "New Request"를 클릭한다.

       ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F99ce0d27-53ad-46e1-8875-92c27d28de5d%2FUntitled.png?table=block&id=e86b7629-b734-4f03-a091-f614f21ef422&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=800&userId=&cache=v2)

    2. 원하는 HTTP method를 선택하고, URL를 입력한다.

       - payload가 필요할 경우 Body에 추가한다.

         ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Ff222e02c-a743-4c53-aa6f-26f384ad4fbd%2FUntitled.png?table=block&id=cd641263-94b1-4e82-a07c-15314aa3d836&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

    3. "Send" 버튼을 눌러서 응답을 확인한다.

       ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F4c829eb7-c78e-424b-b191-7f7c7b531b9c%2FUntitled.png?table=block&id=06eadf94-e2c6-429f-a71b-b600a3ff074c&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

## 2. 코드 작성

- 요구사항

  - 주요 기능은 로그인, 회원가입, 회원정보 확인이며, 인증 상태는 Context로 관리한다.

  - `Access Token`은 localStorage에 저장하여 사용한다.

  - 주의: 실제 운영 환경에서는 localStorage에 토큰을 저장하는 것은 보안상 위험할 수 있다. 테스트 목적에 맞게 지금은 이렇게 구현한다.

- 주요 파일 및 폴더 구조

  1. `src/context/AuthContext.jsx`

     - 설명: **인증 및 인가 상태를 관리**하는 컨텍스트 파일

     - 기능

       - 로그인 상태 관리
       - 로그인/로그아웃 함수 제공
       - Access Token 관리

  2. `src/shared/Router.jsx`

     - 설명: 메인 라우터 파일로, **주요 페이지들로의 라우팅을 관리**한다. 인증 및 인가 기능을 포함하여 **각 페이지로의 접근을 제어**한다.

     - 포함 페이지: `Main.jsx`, `Login.jsx`, `Signup.jsx`, `MyPage.jsx`(로그인된 사용자만 접근 가능)

  3. `src/App.jsx`

     - 설명: 라우터를 자식(children)으로 포함하는 메인 컴포넌트이다. **인증 상태를 관리하는 컨텍스트를 제공**한다.

  4. `src/components/Header.jsx`

     - 설명: 공통 헤더 컴포넌트로, **로그인 여부에 따라 다른 버튼을 표시**한다.

     - 기능

       - 로그인 시: 로그아웃 버튼
       - 비로그인 시: 로그인, 회원가입 버튼
       - 로고(간단한 텍스트)를 누르면 `Main.jsx`로 이동

  5. `src/pages/Main.jsx`

     - 설명: **로그인 여부에 상관없이 접근 가능**한 페이지이다.

     - 기능: "Go to MyPage" 버튼을 누르면 마이페이지로 이동한다.

  6. `src/pages/Login.jsx`

     - 설명: **로그인 처리**를 위한 페이지이다.

  7. `src/pages/Signup.jsx`

     - 설명: **회원가입**을 위한 페이지이다.

  8. `src/pages/MyPage.jsx`

     - 설명: **로그인된 유저만 접근 가능**한 페이지이다. **인가를 테스트**할 수 있는 중요한 페이지이다. 허락이 된 유저만 유저 정보를 읽어올 수 있고, 닉네임 정보를 수정할 수 있다. 이 과정에서 **요청 헤더에 인증 정보(access token)를 담게 된다.**

     - 기능

       - 로그인 상태: 유저 정보 표시
       - 비로그인 상태: 로그인이 필요하다는 alert 메시지를 띄운 후 로그인 페이지로 리디렉션
       - 닉네임 수정 기능 포함

- 라우터 구성

  - 로그인이 필요한 화면: `MyPage.jsx`

  - 로그인이 없어도 되는 화면: `Main.jsx`

  - 로그인이 없어야만 접근할 수 있는 화면: `Login.jsx`, `Signup.jsx`

- 코드 구현

  1. `src/context/AuthContext.jsx`

     - 구현 내용

       - 인증 상태를 관리하는 컨텍스트 파일로, 로그인 및 로그아웃 기능을 제공한다.
       - **Access Token을 로컬 스토리지에 저장**하고, **인증 상태를 전역적으로 관리**한다.

     - 코드

       ```jsx
       import { createContext, useState } from "react";

       // (1) AuthContext 생성
       export const AuthContext = createContext();
       // `AuthContext`는 인증 상태를 관리하기 위한 Context 객체이다.
       // 이 Context는 애플리케이션의 컴포넌트 트리에서 인증 정보를 필요로 하는 컴포넌트들이 접근할 수 있도록 한다.

       // (2) 초기 토큰 가져오기
       const token = localStorage.getItem("accessToken");
       // 로컬 스토리지에 저장된 access token을 가져온다.
       // 만약 토큰이 존재하지 않으면 null을 반환한다.
       // 이 토큰은 사용자가 로그인된 상태인지 아닌지를 확인하는 데 사용된다.

       // (3) AuthProvider 컴포넌트
       export const AuthProvider = ({ children }) => {
         // (3-1) 상태 관리
         const [isAuthenticated, setIsAuthenticated] = useState(!!token);
         // `isAuthenticated`는 사용자가 현재 인증되어 있는지를 나타내는 상태 변수이다.
         // `!!token`을 통해 로컬 스토리지에 토큰이 존재하면 true, 그렇지 않으면 false로 초기화된다.
         // `setIsAuthenticated`는 `isAuthenticated` 상태를 변경하기 위한 함수이다.

         // (3-2) 로그인 함수
         const login = (token) => {
           localStorage.setItem("accessToken", token);
           setIsAuthenticated(true);
         };
         // `login()` 함수는 로그인을 처리한다.
         // 인자로 받은 `token`을 로컬 스토리지에 저장하고, `isAuthenticated` 상태를 true로 변경한다.

         // (3-3) 로그아웃 함수
         const logout = () => {
           localStorage.removeItem("accessToken");
           setIsAuthenticated(false);
         };
         // `logout()` 함수는 로그아웃을 처리한다.
         // 로컬 스토리지에서 access token을 제거하고, `isAuthenticated` 상태를 false로 변경한다.

         // (3-4) AuthContext.Provider
         return (
           <AuthContext.Provider value={{ isAuthenticated, login, logout }}>
             {children}
           </AuthContext.Provider>
         );
         // `AuthContext.Provider`는 Context를 제공하는 컴포넌트이다.
         // value 속성에 `isAuthenticated`, `login`, `logout`을 포함한 객체를 전달하여, 하위 컴포넌트들이 이 값들에 접근할 수 있도록 한다.
         // `{children}`은 `AuthProvider` 컴포넌트의 자식 컴포넌트들이다.
         // 리액트에서는 Context.Provider를 사용할 때, 자식 컴포넌트들이 Provider의 값을 사용할 수 있다.
       };
       // `AuthProvider`는 인증 상태와 관련된 로직을 제공하는 컴포넌트이다.
       // 이 컴포넌트는 하위 컴포넌트들에게 인증 상태와 관련된 데이터를 공급한다.
       ```

  2. `src/shared/Router.jsx`

     - 구현 내용

       - 애플리케이션의 라우팅을 관리하여 페이지 간의 이동을 제어한다.

       - **로그인 여부에 따라 접근 가능한 페이지를 구분**하고, **적절한 페이지로 리다이렉션**한다.

     - 코드

       ```jsx
       import { useContext } from "react";
       import {
         BrowserRouter as Router,
         Route,
         Routes,
         Navigate,
       } from "react-router-dom";
       import Main from "../pages/Main";
       import Login from "../pages/Login";
       import Signup from "../pages/Signup";
       import MyPage from "../pages/MyPage";
       import { AuthContext } from "../context/AuthContext";
       import Header from "../components/Header";

       // (1) PrivateRoute 컴포넌트
       // PrivateRoute: 로그인이 필요한 페이지에 접근할 수 있도록 하는 컴포넌트
       // 로그인이 되어있지 않은 사용자는 Login 페이지로 리다이렉트
       const PrivateRoute = ({ element: Element, ...rest }) => {
         const { isAuthenticated } = useContext(AuthContext);
         return isAuthenticated ? (
           <Element {...rest} />
         ) : (
           <Navigate to="login" />
         );
       };
       // 로그인된 사용자만 접근할 수 있는 페이지를 위한 컴포넌트이다.
       // `isAuthenticated`는 `AuthContext`에서 가져온 인증 상태이다.
       // 로그인된 경우(`isAuthenticated`가 true인 경우), 전달된 컴포넌트(`Element`)를 렌더링한다.
       // 로그인되지 않은 경우(`isAuthenticated`가 false인 경우), 로그인 페이지로 리다이렉션한다.

       // (2) PublicRoute 컴포넌트
       // PublicRoute: 로그인이 필요없는 페이지에 접근할 수 있도록 하는 컴포넌트
       // 로그인이 되어있는 사용자는 MyPage 페이지로 리다이렉트
       const PublicRoute = ({ element: Element, ...rest }) => {
         const { isAuthenticated } = useContext(AuthContext);
         return !isAuthenticated ? (
           <Element {...rest} />
         ) : (
           <Navigate to="/mypage" />
         );
       };
       // 로그인되지 않은 사용자만 접근할 수 있는 페이지를 위한 컴포넌트이다.
       // `isAuthenticated`는 `AuthContext`에서 가져온 인증 상태이다.
       // 로그인되지 않은 경우(`isAuthenticated`가 false인 경우), 전달된 컴포넌트(`Element`)를 렌더링한다.
       // 로그인된 경우(`isAuthenticated`가 true인 경우), 마이페이지로 리다이렉션한다.

       // (3) SharedRouter 컴포넌트
       const SharedRouter = () => {
         <Router>
           <Header />
           <Routes>
             <Route path="/" element={<Main />} />
             <Route path="/login" element={<PublicRoute element={Login} />} />
             <Route path="/signup" element={<PublicRoute element={Signup} />} />
             <Route
               path="/mypage"
               element={<PrivateRoute element={MyPage} />}
             />
           </Routes>
         </Router>;
       };
       // 애플리케이션의 주요 라우팅을 관리하는 컴포넌트이다.
       // `Router`는 브라우저의 URL을 관리하며, URL 변경에 따라 다른 컾모넌트를 렌더링한다.
       // `Header` 컴포넌트는 모든 페이지에서 공통으로 표시된다.
       // `Routes`는 여러 `Route` 컴포넌트를 포함하여 URL 경로와 컴포넌트를 매핑한다.
       // - `/`는 `Main` 페이지를 렌더링한다.
       // - `/login`은 `PublicRoute`를 사용하여 로그인 페이지를 렌더링한다. 로그인된 경우 마이페이지로 리다이렉션한다.
       // - `/signup`은 `PublicRoute`를 사용하여 회원가입 페이지를 렌더링한다. 로그인된 경우 마이페이지로 리다이렉션한다.
       // - `/mypage`는 `PrivateRoute`를 사용하여 마이페이지를 렌더링한다. 로그인되지 않은 경우 로그인 페이지로 리다이렉션한다.

       export default SharedRouter;
       ```

  3. `src/App.jsx`

     - 구현 내용

       - 애플리케이션의 메인 컴포넌트로, 인증 컨텍스트와 라우터를 포함한다.

       - **전체 애플리케이션의 구조를 정의**하고, **Context Provider를 통해 상태를 전달**한다.

     - 코드

       ```jsx
       import SharedRouter from "./shared/Router";
       import { AuthProvider } from "./context/AuthContext";

       const App = () => {
         return (
           <AuthProvider>
             <SharedRouter />
           </AuthProvider>
         );
         // `AuthProvider` 컴포넌트는 애플리케이션의 전역적인 인증 상태를 관리하는 컨텍스트를 제공한다.
         // `SharedRouter` 컴포넌트는 주요 페이지들의 라우팅을 관리하며, 인증 및 인가 기능을 포함하여 각 페이지로의 접근을 제어한다.
       };

       export default App;
       ```

  4. `src/components/Header.jsx`

     - 구현 내용

       - 공통 헤더 컴포넌트로, **로그인 상태에 따라 다른 네비게이션 옵션을 표시**한다.

       - 로고 클릭 시 메인 페이지로 이동하며, 로그인 및 로그아웃 버튼을 포함한다.

     - 코드

       ```jsx
       import { useContext } from "react";
       import { Link, useNavigate } from "react-router-dom";
       import { AuthContext } from "../context/AuthContext";

       const Header = () => {
         const { isAuthenticated, logout } = useContext(AuthContext);
         const navigate = useNavigate();
         // `navigate`는 프로그래밍 방식으로 페이지를 이동하기 위한 함수이다.

         // (1) 로그아웃 함수
         const handleLogout = () => {
           const confirmLogout = confirm("정말로 로그아웃 하시겠습니까?");
           if (confirmLogout) {
             logout();
             navigate("/");
           }
         };
         // "Logout" 버튼을 눌렀을 때 실행되는 함수이다.
         // `logout()` 함수는 인증 컨텍스트에서 제공하는 로그아웃 함수이다. 이를 호출하면 로그아웃 상태로 변경된다.
         // `navigate("/")`로 인해 메인 페이지로 이동한다.

         // (2) 컴포넌트 렌더링: 로고 및 네비게이션 옵션
         return (
           <header
             style={{
               textDecoration: "none",
               color: "black",
               fontSize: "30px",
               fontWeight: "bold",
               cursor: "pointer",
             }}
           >
             <h1>
               <Link
                 style={{
                   textDecoration: "none",
                   color: "black",
                   fontSize: "30px",
                   fontWeight: "bold",
                   cursor: "pointer",
                 }}
                 to="/"
               >
                 Sparta
               </Link>
             </h1>
             <nav
               style={{
                 display: "flex",
                 gap: "20px",
               }}
             >
               {isAuthenticated ? (
                 <>
                   <button onClick={handleLogout}>Logout</button>
                 </>
               ) : (
                 <>
                   <Link
                     style={{
                       textDecoration: "none",
                       color: "black",
                       fontSize: "20px",
                       fontWeight: "bold",
                       cursor: "pointer",
                     }}
                     to="/login"
                   >
                     Login
                   </Link>
                   <Link
                     style={{
                       textDecoration: "none",
                       color: "black",
                       fontSize: "20px",
                       fontWeight: "bold",
                       cursor: "pointer",
                     }}
                     to="/signup"
                   >
                     Signup
                   </Link>
                 </>
               )}
             </nav>
           </header>
         );
       };

       export default Header;
       ```

  5. `src/pages/Main.jsx`

     - 구현 내용

       - 애플리케이션의 메인 페이지로, 로그인 여부에 상관없이 접근 가능하다.

       - "Go to MyPage" 버튼을 제공하여 **마이페이지로 이동 가능**하게 한다.

     - 코드

       ```jsx
       import { useNavigate } from "react-router-dom";

       const Main = () => {
         const navigate = useNavigate();
         // `navigate`는 프로그래밍 방식으로 페이지를 이동하기 위한 함수이다.

         // (1) 페이지 이동 처리
         // "Go to MyPage" 버튼 클릭 시 실행되는 함수이다.
         const handleClick = () => {
           const token = localStorage.getItem("accessToken");
           // 로컬 스토리지에서 access token을 가져온다.
           if (!token) {
             alert("로그인이 필요합니다.");
             navigate("/login");
             // access token이 존재하지 않으면, 로그인이 필요하다는 알람을 띄우고 로그인 페이지로 이동한다.
           } else {
             navigate("/mypage");
             // access token이 존재하면, 마이페이지로 이동한다.
           }
         };

         // (2) 컴포넌트 렌더링
         return (
           <div>
             <h2>Main Page</h2>
             <button onClick={handleClick}>Go to MyPage</button>
           </div>
         );
       };
       // 메인 페이지를 렌더링한다.
       // "Go to MyPage" 버튼이 있으며, 클릭 시 `handleClick()` 함수가 실행된다.

       export default Main;
       ```

  6. `src/pages/Login.jsx`

     - 구현 내용

       - 사용자 로그인을 처리하는 페이지로, 로그인 폼을 제공한다.

       - **로그인 성공 시, 토큰을 저장하고 마이페이지로 리다이렉션**한다.

     - 코드

       ```jsx
       import { useState, useContext } from "react";
       import { useNavigate } from "react-router-dom";
       import axios from "axios";
       import { AuthContext } from "../context/AuthContext";

       const Login = () => {
         const [id, setId] = useState("");
         const [password, setPassword] = useState("");
         const { login } = useContext(AuthContext);
         const navigate = useNavigate();
         // `navigate`는 프로그래밍 방식으로 페이지를 이동하기 위한 함수이다.

         // (1) 폼 제출 처리
         // 로그인 폼 제출 시 실행되는 함수이다.
         const handleSubmit = async (e) => {
           e.preventDefault(); // 기본 제출 동작을 중지시킨다.
           try {
             const response = await axios.post(
               "https://moneyfulpublicpolicy.co.kr/login",
               {
                 id,
                 password,
               }
             ); // 서버에 로그인 요청을 보낸다.
             const data = response.data;
             if (data.success) {
               login(data.accessToken);
               navigate("/mypage");
               // 성공적인 응답을 받으면, 인증 토큰을 저장하고 마이페이지로 이동한다.
             } else {
               alert("Login failed");
               // 응답이 실패하면, 로그인 실패 메시지를 표시한다.
             }
           } catch (error) {
             console.error("Login error: ", error);
             alert("Login failed");
             // `catch` 블록에서 HTTP 요청 자체가 실패한 경우를 처리한다.
           }
         };

         // (2) 컴포넌트 렌더링
         return (
           <div>
             <h2>Login Page</h2>
             <form onSubmit={handleSubmit}>
               <input
                 type="text"
                 value={id}
                 onChange={(e) => setId(e.target.value)}
                 placeholder="ID"
               />
               <input
                 type="password"
                 value={password}
                 onChange={(e) => setPassword(e.target.value)}
                 placeholder="Password"
               />
               <button type="submit">Login</button>
             </form>
           </div>
         );
         // 로그인 페이지를 렌더링한다.
         // 아이디와 비밀번호를 입력할 수 있는 입력 필드와 로그인 버튼을 제공한다.
       };

       export default Login;
       ```

  7. `src/pages/Signup.jsx`

     - 구현 내용

       - 사용자 회원가입을 처리하는 페이지로, 회원가입 폼을 제공한다.

       - **회원가입 성공 시, 로그인 페이지로 리다이렉션**한다.

     - 코드

       ```jsx
       import { useState } from "react";
       import { useNavigate } from "react-router-dom";
       import axios from "axios";

       const Signup = () => {
         const [id, setId] = useState("");
         const [password, setPassword] = useState("");
         const [nickname, setNickname] = useState("");
         const navigate = useNavigate();
         // `navigate`는 프로그래밍 방식으로 페이지를 이동하기 위한 함수이다.

         // (1) 폼 제출 처리
         // 회원가입 폼 제출 시 실행되는 함수이다.
         const handleSubmit = async (e) => {
           e.preventDefault(); // 기본 제출 동작을 중지시킨다.
           try {
             const response = await axios.post(
               "https://moneyfulpublicpolicy.co.kr/register",
               {
                 id,
                 password,
                 nickname,
               }
             ); // 서버에 회원가입 요청을 보낸다.
             const data = response.data;
             if (data.success) navigate("/login");
             // 성공적인 응답을 받으면, 로그인 페이지로 리다이렉션한다.
             else alert("Signup failed");
             // 응답이 실패하면, 회원가입 실패 메시지를 표시한다.
           } catch (error) {
             console.error("Signup error: ", error);
             alert("Signup failed");
             // `catch` 블록에서 HTTP 요청 자체가 실패한 경우를 처리한다.
           }
         };

         // (2) 컴포넌트 렌더링
         return (
           <div>
             <h2>Signup Page</h2>
             <form onSubmit={handleSubmit}>
               <input
                 type="text"
                 value={id}
                 onChange={(e) => setId(e.target.value)}
                 placeholder="ID"
               />
               <input
                 type="password"
                 value={password}
                 onChange={(e) => setPassword(e.target.value)}
                 placeholder="Password"
               />
               <input
                 type="text"
                 value={nickname}
                 onChange={(e) => setNickname(e.target.value)}
                 placeholder="Nickname"
               />
               <button type="submit">Signup</button>
             </form>
           </div>
         );
         // 회원가입 페이지를 렌더링한다.
         // 아이디, 비밀번호, 닉네임을 입력할 수 있는 입력 필드와 회원가입 버튼을 제공한다.
       };

       export default Signup;
       ```

  8. `src/pages/MyPage.jsx`

     - 구현 내용

       - 로그인된 사용자만 접근 가능한 페이지로, 사용자 정보를 표시한다.

       - **사용자 닉네임을 수정할 수 있는 기능**을 제공한다.

     - 코드

       ```jsx
       import { useEffect, useState, useContext } from "react";
       import axios from "axios";
       import { AuthContext } from "../context/AuthContext";
       import { useNavigate } from "react-router-dom";

       const MyPage = () => {
         const [userInfo, setUserInfo] = useState(null);
         const [newNickname, setNewNickname] = useState("");
         const { isAuthenticated } = useContext(AuthContext);
         const navigate = useNavigate();
         // `navigate`는 프로그래밍 방식으로 페이지를 이동하기 위한 함수이다.

         // (1) `useEffect` 훅
         useEffect(() => {
           if (!isAuthenticated) {
             alert("로그인이 필요합니다.");
             navigate("/login");
             // 사용자가 인증되어 있지 않으면 로그인 페이지로 리다이렉트한다.
           } else {
             // 비동기 함수를 정의한다.
             const fetchUserInfo = async () => {
               try {
                 const token = localStorage.getItem("accessToken");
                 // 로컬 스토리지에 저장되어 있는 access token을 가져온다.
                 const response = await axios.get(
                   "https://moneyfulpublicpolicy.co.kr/user",
                   {
                     headers: {
                       Authorization: `Bearer ${token}`,
                     },
                   }
                 );
                 // 사용자 정보를 가져오는 GET 요청을 보낸다.
                 // 이때, Authorization 헤더에 `Bearer ${token}`을 포함하여 서버에 인증 정보를 전달한다.
                 setUserInfo(response.data);
                 // 서버로부터 받은 응답 데이터를 `setUserInfo`를 사용하여 `userInfo` 상태에 저장한다.
               } catch (error) {
                 console.error("Failed to fetch user info: ", error);
                 // 요청이 실패하면 에러 메시지를 콘솔에 출력한다.
               }
             };

             fetchUserInfo(); // 비동기 함수를 호출한다.
             // 사용자가 인증되어 있으면 사용자 정보를 가져온다.
           }
         }, [isAuthenticated, navigate]);
         // `isAuthenticated`와 `navigate`가 변경될 때마다 `useEffect` 내부의 코드가 다시 실행된다.
         // 이 의존성 배열을 통해 `inAuthenticated` 상태가 변경되면 항상 올바른 인증 상태에 따라 동작하도록 한다.

         // (2) 닉네임 변경 핸들러
         // 닉네임 변경을 처리하는 함수이다.
         const handleNicknameChange = async (e) => {
           e.preventDefault(); // 기본 폼 제출 동작을 중지한다.
           try {
             const token = localStorage.getItem("accessToken");
             // 로컬 스토리지에 저장되어 있는 access token을 가져온다. 이 토큰은 인증된 사용자임을 증명하는 데 사용된다.

             const formData = new FormData();
             // FormData 객체를 생성한다. FormData 객체는 키-값 쌍으로 데이터를 저장하는 방법을 제공한다.
             formData.append("nickname", newNickname);
             // `newNickname`을 FormData 객체에 추가한다.

             const response = await axios.patch(
               "https://moneyfulpublicpolicy.co.kr/profile",
               formData,
               {
                 headers: {
                   Authorization: `Bearer ${token}`,
                   "Content-Type": "multipart/form-data",
                 },
               }
             );
             // 서버에 PATCH 요청을 보낸다. 이 요청은 FormData 객체를 서버로 전송한다.
             // headers 객체를 통해 `Authorization` 헤더에 `Bearer ${token}`을 추가하여 인증 정보를 함께 보낸다.
             // `Content-Type` 헤더를 "multipart/form-data"로 설정하여 파일 및 데이터를 폼 형식으로 전송한다.

             if (response.data.success) {
               setUserInfo((prevState) => ({
                 ...prevState,
                 nickname: response.data.nickname,
               }));
               alert("닉네임이 변경되었습니다");
               setNewNickname("");
               // 성공적인 응답을 받으면, `setUserInfo`를 사용하여 사용자 정보를 업데이트한다.
               // `prevState`를 통해 이전 상태를 유지하면서 nickname만 업데이트한다.
               // 성공 메시지를 알리고, `newNickname` 상태를 초기화한다.
             } else alert("닉네임 변경에 실패했습니다.");
             // 응답이 실패하면, 실패 메시지를 표시하낟.
           } catch (error) {
             console.error("Failed to update nickname: ", error);
             alert("닉네임 변경에 실패했습니다.");
             // 서버 요청 중 오류가 발생하면 `catch` 블록이 실행된다.
             // 오류 메시지를 콘솔에 출력하고, 사용자에게 실패 메시지를 표시한다.
           }
         };

         // (3) 컴포넌트 렌더링
         if (!userInfo) return <div>Loading...</div>;
         // `userInfo`가 없으면 "Loading..."을 표시한다.

         return (
           <div>
             <h2>My Page</h2>
             <p>ID: {userInfo.id}</p>
             <p>Nickname: {userInfo.nickname}</p>

             <form onSubmit={handleNicknameChange}>
               <input
                 type="text"
                 value={newNickname}
                 onChange={(e) => setNewNickname(e.target.value)}
                 placeholder="새 닉네임"
               />
               <button type="submit">닉네임 변경</button>
             </form>
           </div>
         );
       };
       // 사용자 정보를 표시한다.
       // 닉네임 변경 폼을 렌더링한다.

       export default MyPage;
       ```

# 3. tailwind.css

## 1. Tailwind CSS의 등장배경

- CSS 프레임워크의 중요성

  - CSS 프레임워크는 웹 애플리케이션 개발에서 매우 중요하다.

  - 작은 규모의 애플리케이션에서는 CSS 관리가 간단하지만, 애플리케이션이 커질수록 CSS 관리가 점점 더 복잡해진다.

  - **CSS 프레임워크**는 **애플리케이션의 스타일링을 쉽게 관리**하고, **일관된 디자인 시스템을 구축**하는 데 도움을 준다.

- Tailwind CSS의 필요성

  - **TailWind CSS**는 유틸리티 퍼스트(Utility-First) CSS 프레임워크로, **빠르고 쉽게 스타일링을 적용할 수 있는 클래스**를 제공한다.

  - 기존의 CSS-in-JS 라이브러리인 styled-component는 편리하지만 성능 이슈와 클래스 네임 충돌 문제가 발생할 수 있다.

  - **Tailwind CSS**는 이러한 **복잡성을 줄이고**, 보다 **유연하고 직관적인 스타일링을 제공**한다.

  - Tailwind는 디자인 시스템을 직접 만들 수 있도록 도와주는 프레임워크이다. 매우 가볍고, 사용하기 쉬운 CSS 프레임워크이다.

## 2. Tailwind CSS의 주요 개념

- Tailwind CSS의 주요 특징

  - **유틸리티 퍼스트**

    - 다양한 유틸리티 클래스를 제공하여, **HTML 요소에 직접 클래스를 추가**하는 방식으로 스타일링을 할 수 있다.

      > **유틸리티 클래스**
      >
      > - 특정 스타일 속성을 나타내는 짧고 간단한 CSS 클래스
      > - HTML 요소에 직접 적용하여 빠르고 쉽게 스타일링을 할 수 있다.
      > - Tailwind CSS는 이러한 유틸리티 클래스를 대량으로 제공하여, 별도의 CSS 작성 없이도 다양한 스타일을 구현할 수 있게 한다.

    - 별도의 **CSS 파일을 작성할 필요 없이**, HTML 파일만으로도 충분히 스타일링이 가능하다.

  - **성능 최적화**

    - Tailwind CSS는 **불필요한 스타일을 제거**하고, **필요한 부분만 스타일을 적용**하는 방식으로 성능 최적화가 잘 되어 있다.

    - **사용하지 않는 CSS를 제거**하여, **최종 빌드 파일 크기를 최소화**할 수 있다.

      > **Purging CSS**
      >
      > 사용하지 않는 CSS를 제거하여 최종 빌드 파일 크기를 줄이는 과정을 의미한다. Tailwind CSS는 이를 자동으로 처리해준다.

    - CSS 파일의 크기를 줄이고, 애플리케이션 로딩 속도를 개선할 수 있다.

  - **React와의 통합**

    - React와 완벽하게 통합되어, Tailwind CSS의 유틸리티 클래스를 쉽게 사용할 수 있다.

    - Tailwind CSS는 React의 JSX 문법과 함께 사용할 수 있어, 스타일링이 매우 간편하다.

      ```jsx
      <div className="bg-blue-500 text-white p-4">Hello, Tailwind CSS!</div>
      ```

    - 클래스 네임 충돌 없이 독립적인 컴포넌트 스타일링이 가능하다.

  - **커스터마이징**

    - Tailwind CSS는 **기본 설정을 쉽게 커스터마이징** 할 수 있어, 프로젝트에 맞는 디자인 시스템을 구축할 수 있다.

    - Tailwind 설정 파일(`tailwind.config.js`)을 통해 **색상, 폰트, 스페이싱 등 다양한 설정을 커스터마이징**할 수 있다.

      ```javascript
      module.exports = {
        theme: {
          extend: {
            colors: {
              primary: "#1DA1F2",
            },
          },
        },
      };
      ```

    - **다양한 설정 옵션**을 제공하여 프로젝트의 요구사항에 맞는 스타일링을 손쉽게 적용할 수 있다.

  - 전통적인 CSS 프레임워크와 비교할 때, Tailwind CSS는 **유연성**과 **커스터마이징의 용이성**에서 큰 강점을 가지고 있다.

- 설치 및 기본 사용법

  - Tailwind CSS를 설치한다.

    ```
    yarn add tailwindcss postcss autoprefixer
    npx tailwindcss init -p
    ```

  - `tailwind.config.js` 파일 내용을 변경한다.

    ```javascript
    export default {
      content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
      theme: {
        extend: {},
      },
      plugins: [],
    };
    ```

  - 기본 사용법

    - Tailwind CSS를 사용하기 위한 초기 설정이 매우 간단하다.

      ```javascript
      // src/index.css

      @tailwind base;
      @tailwind components;
      @tailwind utilities;
      ```

    - 인증 예제 header를 inline으로 스타일링한 코드 (Tailwind CSS 사용하기 전)

      ```jsx
      <header
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          padding: "0 20px",
          backgroundColor: "lightgray",
        }}
      >
      ```

    - 인증 예제 header를 Tailwind CSS로 스타일링한 코드

      ```jsx
      <header className="flex justify-between items-center px-5 bg-gray-200">
      ```

## 3. Tailwind CSS와 Styled-Components 비교

- 설정 및 사용법 비교

  - **Tailwind CSS** : **유틸리티 클래스**를 사용하여 간편하게 스타일링을 적용한다.

    ```jsx
    <div className="bg-blue-500 text-white p-4">Hello, Tailwind CSS!</div>
    ```

  - **Styled-Components** : **자바스크립트 파일 내에서 스타일을 정의**하고, **컴포넌트에 직접 스타일을 적용**한다.

    ```jsx
    import styled from "styled-components";

    const Button = styled.button`
      background-color: blue;
      color: white;
      padding: 1rem;
    `;

    function App() {
      return <Button>Hello, Styled-Components!</Button>;
    }
    ```

- 장단점 비교

  | 사용 도구             | 장점                                                                           | 단점                                                    |
  | --------------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------- |
  | **Tailwind CSS**      | 유틸리티 클래스 기반으로 간편한 사용, 성능 최적화, 커스터마이징 용이           | 클래스 네임이 길어질 수 있고, 프로젝트 초기 설정 필요   |
  | **Styled-Components** | 자바스크립트 파일 내에서 스타일링 가능, 동적 스타일링 지원, 컴포넌트 기반 설계 | 초기 설정 및 학습 곡선, 스타일링 시 성능 이슈 발생 가능 |

# 4. 반응형 웹

## 1. 반응형 웹이란?

- 우리가 인터넷을 사용할 때 여러 가지 기기를 사용하는데, 그 기기마다 화면 크기가 조금씩 다르다.

- **반응형 디자인**은 이러한 **다양한 기기에 맞게 화면이 자동으로 변하는 디자인**이다.

- 반응형 디자인의 필요성

  - 유저들은 항상 편안한 환경에서 서비스를 이용하기를 원한다.

  - 휴대폰으로 서비스를 사용할 때, 글씨가 너무 작으면 읽기가 어렵고 레이아웃이 한눈에 들어오지 않으면 사용하기 불편해한다.

  - 반응형 디자인은 모든 기기에서 화면이 잘 보이고 좋은 유저 경험이 되도록 만들어 준다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fe9f5b489-1638-4ada-8393-6f601e30af05%2FUntitled.png?table=block&id=c16db721-2a2f-4c8a-937e-accde1be221f&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=280&userId=&cache=v2)

    > 웹 전용 화면을 모바일로 보았을 때, 내용과 버튼들이 매우 작아서 사용하기 불편해 보인다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F9be6d8ac-a8de-438b-85d9-745c8223ec80%2FUntitled.png?table=block&id=4eb46551-3eb3-491a-99a2-40bb0b42ee0f&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=280&userId=&cache=v2)

    > 모바일 전용 페이지로 보면 UI가 모바일 환경에 최적화되어 있어 편안하다.

- 반응형 디자인의 장점

  - 반응형 디자인을 사용하면 유저 편의성 향상 외에 또 다른 이점도 있다.

  - 사이트를 만들 때 모든 디바이스에 대응하는 사이트를 따로따로 만들지 않아도 된다.

  - **반응형으로 사이트를 한 번 구현하면 모든 기기에서 편하게 볼 수 있어서** 많은 시간과 노력을 아낄 수 있다.

## 2. 다양한 디바이스를 고려한 웹사이트 구현 기법

- **반응형 웹**

  - **다양한 기기에서 인터넷을 할 때 화면이 자동으로 바뀌는 웹사이트**

  - 어떤 기기를 사용해도 화면이 편하게 보일 수 있도록 웹사이트를 만들 때 다양한 크기의 화면에 맞게 디자인을 해야 한다.

  - 예시: 애플, 에어비앤비, H&M, Next UI, Tailwind CSS

  - 지정해둔 넓이(디바이스 넓이)에 따라 디자인이 변경되는 반응형 웹의 와이어 프레임

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fa1a6ca5a-9937-4aef-9447-6d912d38b91f%2FUntitled.png?table=block&id=5c082939-9766-4d50-a8ca-f8f9c36a437d&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

    - 컨텐츠는 거의 동일하게 제공하나, 디바이스마다 폰트의 크기, 레이아웃, 구성을 다르게 주어 **사용자에게 효과적으로 내용을 전달할 수 있는 디자인을 각 디바이스 별로 제공**하는 것을 확인할 수 있다.

- **적응형 웹**

  - **각 기기마다 미리 정해진 화면 크기에 맞게 디자인을 하는 웹사이트**

  - 특정 기기의 화면 크기에 따라 디자인을 미리 정해놓고 그에 맞게 보여준다.

  - 이렇게 하면 각 기기마다 디자인을 다르게 만들 수 있지만, 정해놓은 기기 이외의 다른 환경에서는 화면이 잘 맞지 않을 수도 있다.

  - 예시: 네이버, 무신사

## 3. 반응형 웹 개발

- **CSS 파일**을 사용하는 방법

  - CSS 파일에 미디어 쿼리를 작성하여 리액트 컴포넌트에 적용할 수 있다.

    ```css
    /* styles.css */

    .container {
      padding: 20px;
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
    }
    ```

  - 리액트 컴포넌트에서 CSS 파일을 임포트하여 사용한다.

    ```jsx
    import "./styles.css";

    const SampleComponent = () => {
      return <div className="container">반응형 웹</div>;
    };

    export default SampleComponent;
    ```

- **Styled-Components 라이브러리**를 사용하는 방법

  - 자바스크립트 파일 내에서 스타일을 정의할 수 있다.

    ```jsx
    // SampleComponent.jsx

    import styled from "styled-components";

    const Container = styled.div`
      padding: 20px;
      @media (max-width: 768px) {
        padding: 10px;
      }
    `;

    const SampleComponent = () => {
      return <Container>반응형 웹</Container>;
    };

    export default SampleComponent;
    ```

- **react-responsive 라이브러리**를 사용하는 방법

  - 미디어 쿼리를 리액트 컴포넌트에서 쉽게 사용할 수 있다.

    ```jsx
    // SampleComponent.jsx

    import { useMediaQuery } from "react-responsive";

    const SampleComponent = () => {
      const isMobile = useMediaQuery({ query: "(max-width: 768px)" });

      return (
        <div style={{ padding: isMobile ? "10px" : "20px" }}>반응형 웹</div>
      );
    };

    export default SampleComponent;
    ```

- **Tailwind CSS**를 사용하는 방법

  - Tailwind의 모든 유틸리티 클래스는 다양한 중단점에서 조건부로 적용할 수 있으므로 HTML을 벗어나지 않고도 복잡한 반응형 인터페이스를 쉽게 구축할 수 있다.

  - 먼저 문서의 `<head>`에 뷰포트(viewport) `<meta>` 태그를 추가했는지 확인한다.

    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    ```

  - 그런 다음, 유틸리티를 추가하되 **특정 중단점에서만 적용하려면 유틸리티 앞에 중단점 이름과 `:` 문자**를 붙이기만 하면 된다.

    ```html
    <img class="w-16 md:w-32 lg:w-48" src="..." />
    ```

    - 기본적으로 5개의 중단점이 있으며, 일반적인 디바이스 해상도에서 영감을 얻었다.

      | 중단점 접두사 | 최소 너비 | CSS                                |
      | :-----------: | :-------: | ---------------------------------- |
      |    **sm**     |   640px   | @media (min-width: 640px) { ... }  |
      |    **md**     |   768px   | @media (min-width: 768px) { ... }  |
      |    **lg**     |  1024px   | @media (min-width: 1024px) { ... } |
      |    **xl**     |  1280px   | @media (min-width: 1280px) { ... } |
      |    **2xl**    |  1536px   | @media (min-width: 1536px) { ... } |

      - 이는 **프레임워크의 모든 유틸리티 클래스에서 작동**하므로 문자 간격이나 커서 스타일 등 주어진 중단점에서 말 그대로 무엇이든 변경할 수 있다.

  - Theme 활용하기

    - `tailwind.config.js` 파일의 `theme` 섹션에서는 프로젝트의 색상 팔레트, 글자 크기, 글꼴, 중단점, 테두리 반경(border radius) 값 등을 정의할 수 있다.

      ```javascript
      // tailwind.config.js

      /** @type {import("tailwindcss").Config} */
      module.exports = {
        theme: {
          screens: {
            sm: "468px",
            md: "768px",
            lg: "976px",
            xl: "1440px",
          },
          colors: {
            blue: "#1fb6ff",
            purple: "#7e5bef",
            pink: "#ff49db",
            orange: "#ff7849",
            green: "#13ce66",
            yellow: "#ffc82c",
            "gray-dark": "#273444",
            gray: "#8492a6",
            "gray-light": "#d3dce6",
          },
          fontFamily: {
            sans: ["Graphik", "sans-serif"],
            serif: ["Merriweather", "serif"],
          },
          extend: {
            spacing: {
              128: "32rem",
              144: "36rem",
            },
            borderRadius: {
              "4xl": "2rem",
            },
          },
        },
      };
      ```

      - `screens`

        - `screens` 키를 사용하면 프로젝트에서 반응형 중단점을 사용자 지정할 수 있다.

      - `colors`

        - `colors` 키를 사용하면 프로젝트의 글로벌 색상 팔레트를 사용자 지정할 수 있다.

        - 기본적으로 이러한 색상은 배경색(`backgroundColor`), 테두리 색(`borderColor`), 텍스트 색(`textColor`) 등과 같은 모든 색상 관련 핵심 플러그인에서 상속된다.

      - `spacing`

        - `spacing` 키를 사용하면 프로젝트의 글로벌 간격 및 크기 조정 배율을 사용자 지정할 수 있다.

        - 기본적으로 이러한 값은 패딩(`padding`), 여백(`margin`), 폭(`width`), 높이(`height`), 최대 높이(`maxHeight`), 플렉스 기준(`flex-basis`), 간격(`gap`), 삽입(`inset`), 공간(`space`), 변형(`translate`), 스크롤 마진(`scrollMargin`), 스크롤 패딩(`scrollPadding`), 텍스트 들여쓰기(`textIndent`) 핵심 플러그인에서 상속된다.

  - 스크린 사이즈 지정하기

    - `tailwind.config.js` 파일의 `theme.screens` 섹션에서 프로젝트의 중단점을 정의한다.

    - **키는 반응형 수정자**(예: `md:text-center`)가 되고, **값은 중단점이 시작되는 최소 너비**이다.

    - 기본 중단점은 일반적인 기기 해상도를 기준으로 한다.

      ```javascript
      // tailwind.config.js

      /** @type {import("tailwindcss").Config} */
      module.exports = {
        theme: {
          screens: {
            sm: "640px",
            // => @media (min-width: 640px) { ... }
            md: "768px",
            // => @media (min-width: 768px) { ... }
            lg: "1024px",
            // => @media (min-width: 1024px) { ... }
            xl: "1280px",
            // => @media (min-width: 1280px) { ... }
            "2xl": "1536px",
            // => @media (min-width: 1546px) { ... }
          },
        },
      };
      ```

      - 프로젝트에 원하는 방식으로 이름을 지정하여 원하는 만큼의 화면을 자유롭게 만들 수 있다.

      - default로 `min-width`를 따라가는 것을 확인할 수 있는데, 단계별로 조건에 맞는 CSS를 덮어 씌우게 되기 때문에 CSS 최적화를 위해서는 **모바일 퍼스트(모바일에서 더 많이 쓰이는) 서비스라면 `min-width`, 데스크탑 퍼스트 서비스라면 `max-width`를 기준으로 구현**하는 게 좋다.

      - 클래스에 `screen`에 대한 클래스명을 주지 않는다면 가장 기본값은 맨 위에 선언된 값이 된다.

        ```javascript
        // tailwind.config.js

        /** @type {import('tailwindcss').Config} */
        module.exports = {
          theme: {
            screens: {
              "2xl": { max: "1535px" },
              // => @media (max-width: 1535px) { ... }

              xl: { max: "1279px" },
              // => @media (max-width: 1279px) { ... }

              lg: { max: "1023px" },
              // => @media (max-width: 1023px) { ... }

              md: { max: "767px" },
              // => @media (max-width: 767px) { ... }

              sm: { max: "639px" },
              // => @media (max-width: 639px) { ... }
            },
          },
        };
        ```

  - 컬러 지정하기

    - 프로젝트에서 자주 쓰이는 색상을 미리 지정하여 사용할 수 있다.

    - 서비스 전체의 컬러의 통일성과 코드 가독성에 좋다.

      ```javascript
      // tailwind.config.js

      /** @type {import('tailwindcss').Config} */
      module.exports = {
        theme: {
          screens: {
            sm: "480px",
            md: "768px",
            lg: "976px",
            xl: "1440px",
          },
          colors: {
            blue: "#1fb6ff",
            purple: "#7e5bef",
            pink: "#ff49db",
            orange: "#ff7849",
            green: "#13ce66",
            yellow: "#ffc82c",
            "gray-dark": "#273444",
            gray: "#8492a6",
            "gray-light": "#d3dce6",
          },
        },
      };
      ```

  - 프리셋 사용하기

    - 모바일 퍼스트로 디바이스 크기를 다음과 같이 설정한다.

      ```javascript
      // tailwind.config.js

      /** @type {import('tailwindcss').Config} */
      module.exports = {
        theme: {
          screens: {
            sm: "640px",
            // => @media (min-width: 640px) { ... }

            md: "768px",
            // => @media (min-width: 768px) { ... }

            lg: "1024px",
            // => @media (min-width: 1024px) { ... }

            xl: "1280px",
            // => @media (min-width: 1280px) { ... }

            "2xl": "1536px",
            // => @media (min-width: 1536px) { ... }
          },
        },
      };
      ```

    - 실제 태그에 프리셋을 적용한다.

      ```html
      <img class="w-16 md:w-32 lg:w-48" src="..." />
      ```

      - 위와 같이 적용을 할 경우에 default인 sm 사이즈에서는 이미지의 width가 4rem, md 사이즈에서는 8rem, lg 사이즈에서는 12rem이 적용된다.
