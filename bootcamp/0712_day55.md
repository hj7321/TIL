## 0712_Day55

<Next.js> 4주차(Rendering) 강의 내용 정리 부분

## 1. v12와 v13의 주요 차이점

- Next.js를 사용한다고 할 떄, 가장 중요하게 보는 개념이 바로 **렌더링 방식**이다.

- Next.js v12

  - 렌더링 기준: **페이지 단위**

  - 예시

    - `about` 페이지는 SSG로 동작한다.

    - `todoList` 페이지는 SSR로 동작한다.

    - `sample` 페이지는 CSR로 만든다.

- Next.js v13

  - 렌더링 기준: **컴포넌트 단위**

  - React 18 버전에서 제시한 서버 컴포넌트(서버 상에서만 동작), 클라이언트 컴포넌트(브라우저에서만 동작)에 힘입어 렌더링 방식이 컴포넌트 단위로 변경되었다.

  - 한 페이지 안에도 여러 렌더링 방식이 공존할 수 있게 되었다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fd65917a1-a523-4891-b85b-903a7280deec%2FUntitled.png?table=block&id=7593495b-971f-40ab-81bd-075f8ca1cede&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fccae38a4-7810-4890-b323-c73302e28fd0%2FUntitled.png?table=block&id=1472c9a9-b17d-4ba9-b32a-03478eefcbe6&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1200&userId=&cache=v2)

## 2. 서버 컴포넌트와 클라이언트 컴포넌트

- Next.js에서 **기본적으로 `app` 폴더 하위의 모든 컴포넌트는 서버 컴포넌트**이다.

- **서버 컴포넌트**

  - 서버상에서 실행되는 컴포넌트

  - 테스트 해보기

    ```tsx
    // src/app/page.tsx

    export default function Home() {
      console.log("여기는 어디일까요?");

      return <div>안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!</div>;
    }
    ```

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F54506b6d-3f35-4a60-ae14-cc44e6a7388f%2FUntitled.png?table=block&id=94a6b355-0449-41d9-819a-fe1e3e70c5d4&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

    - 크롬 브라우저가 아니라 **터미널에 콘솔이 출력**되었다.

    - 우리가 **서버를 돌리고 있는 localhost, 즉 내 컴퓨터의 Node.js 환경에서 콘솔이 출력**되고 있다.

    - 만일 우리의 프로젝트가 AWS 같은 클라우드 컴퓨팅에서 돌아가고 있다면, 해당 서버의 로그에 콘솔이 출력되었을 것이다.

    - 이처럼 **컴포넌트의 실행 환경**이 브라우저인지, 서버인지에 따라 서버 컴포넌트인지, 클라이언트 컴포넌트인지가 결정된다.

  - 메서드 테스트를 통해 런타임 환경 이해하기

    - `alert()` 메서드

      ```tsx
      // src/app/page.tsx

      export default function Home() {
        console.log("여기는 어디일까요?");

        alert("hello");

        return <div>안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!</div>;
      }
      ```

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F9a19ea1b-bbed-4781-a505-19ffd332bcce%2FUntitled.png?table=block&id=38dee588-5a2d-483d-9405-648ed68428a2&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

      - 위 결과를 통해, `alert()` 메서드는 서버 컴포넌트(Node.js 런타임 환경)에서는 사용할 수 없다는 것을 알 수 있다.

    - `os.hostname()` 메서드

      ```tsx
      // src/app/page.tsx

      export default function Home() {
        // console.log("여기는 어디일까요?");

        const os = require("os");
        console.log("Hostname:", os.hostname());

        return <div>안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!</div>;
      }
      ```

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F3fc95f2b-486b-4466-b91f-3739c255329c%2FUntitled.png?table=block&id=88761ca3-4571-4caf-8468-d502af57f38d&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

      - 위 결과를 통해, `os.hostname()` 메서드는 서버 컴포넌트(Node.js 런타임 환경)에서 사용할 수 있다는 것을 알 수 있다.

- **클라이언트 컴포넌트**

  - 브라우저 상에서 실행되는 컴포넌트

    - 서버 컴포넌트에서는 `alert()`, `confirm()`처럼 유저와의 상호작용이 필요한 메서드, 기능은 사용할 수 없다.

    - 또한 `useState`, `useEffect`처럼 CSR을 위해 사용된 기술들도 사용할 수 없다.

    - 하지만 개발을 하다 보면 당연하게도 이러한 기능이 필요할 때가 있는데, 이런 경우 **`"use client"`를 컴포넌트 최상단에 삽입**하면 된다.

  - 테스트 해보기

    ```tsx
    // src/app/page.tsx

    "use client";

    export default function Home() {
      console.log("여기는 어디일까요?");

      return <div>안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!</div>;
    }
    ```

    - 컴포넌트 최상단에 `"use client"`를 삽입하면, 터미널이 아닌 브라우저에 콘솔이 찍힌다.

  - 메서드 테스트를 통해 런타임 환경 이해하기

    - `alert()` 메서드

      ```tsx
      // src/app/page.tsx

      "use client";

      export default function Home() {
        console.log("여기는 어디일까요?");

        alert("hello");

        return <div>안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!</div>;
      }
      ```

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fc5c9ecf8-6b9e-48a0-8fa0-76b93e0a92e3%2FUntitled.png?table=block&id=b4907234-fc06-43ae-b53e-293e7cb5ee70&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

    - `useEffect`, `useState`

      ```tsx
      // src/app/page.tsx

      "use client";

      import { useEffect, useState } from "react";

      export default function Home() {
        const [count, setCount] = useState(0);

        useEffect(() => {
          console.log("렌더링이 완료되었습니다.");
        }, []);

        const handleClick = () => {
          setCount(count + 1);
        };

        return (
          <div>
            안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!
            <div>{count}</div>
            <button onClick={handleClick}>클릭</button>
          </div>
        );
      }
      ```

      - 만약 `"use client"` 코드가 없다면, 아래와 같은 오류가 발생한다.

        ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F6070aa8e-c2ea-4ecc-89c6-1ebaa34aa424%2FUntitled.png?table=block&id=5c013d11-7014-41f2-ab82-bfa883f1f53d&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

- 사용자와의 상호작용이 있는 경우 클라이언트 컴포넌트를, 그 외의 경우는 서버 컴포넌트를 사용한다.

  ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F3845e139-a6da-4dfc-8f0d-40375fd9cddb%2FUntitled.png?table=block&id=90b2c15a-1d97-4b8e-9752-c7b9d2223946&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1400&userId=&cache=v2)

- 컴포넌트 분리하기

  - 코드 1

    ```tsx
    // src/app/page.tsx

    export default function Home() {
      return (
        <div>
          안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!
          <section>
            <h1>제목</h1>
            <p>내용</p>
            <ul>
              <li>항목1</li>
              <li>항목2</li>
              <li>항목3</li>
            </ul>
          </section>
          <button onClick={() => alert("안녕하세요!")}>클릭</button>
        </div>
      );
    }
    ```

    - 이 코드는 `"use client"`가 없으므로 서버 컴포넌트이다.

    - `onClick`은 클라이언트 컴포넌트에서만 사용 가능한 기술이기 때문에 오류가 날 것이다.

    - 오류가 나는 원인인 `<button>` 태그를 `Button` 컴포넌트로 분리한다.

    - 컴포넌트 분리

      - `Button.tsx`

        ```tsx
        // src/components/Button.tsx

        "use client";

        const Button = () => {
          return <button onClick={() => alert("안녕하세요!")}>클릭</button>;
        };

        export default Button;
        ```

      - `page.tsx`

        ```tsx
        // src/app/page.tsx

        import Button from "@/components/Button";

        export default function Home() {
          return (
            <div>
              안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!
              <section>
                <h1>제목</h1>
                <p>내용</p>
                <ul>
                  <li>항목1</li>
                  <li>항목2</li>
                  <li>항목3</li>
                </ul>
              </section>
              <Button />
            </div>
          );
        }
        ```

  - 코드 2

    ```tsx
    // src/app/page.tsx

    "use client";

    import { useEffect, useState } from "react";

    export default function Home() {
      const [count, setCount] = useState(0);

      useEffect(() => {
        console.log("렌더링이 완료되었습니다.");
      }, []);

      const handleClick = () => {
        setCount(count + 1);
      };

      return (
        <div>
          안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!
          <div>{count}</div>
          <button onClick={handleClick}>클릭</button>
        </div>
      );
    }
    ```

    - 컴포넌트 분리

      - `Counter.tsx`

        ```tsx
        // src/components/Counter.tsx

        "use client";

        import { useEffect, useState } from "react";

        const Counter = () => {
          const [count, setCount] = useState(0);

          useEffect(() => {
            console.log("렌더링이 완료되었습니다.");
          }, []);

          const handleClick = () => {
            setCount(count + 1);
          };

          return (
            <div>
              <div>{count}</div>
              <button onClick={handleClick}>클릭</button>
            </div>
          );
        };

        export default Counter;
        ```

      - `page.tsx`

        ```tsx
        // src/app/page.tsx

        import Counter from "@/components/Counter";

        export default function Home() {
          return (
            <div>
              안녕하세요! 내배캠 리액트.. 아니아니 넥스트입니다!
              <Counter />
            </div>
          );
        }
        ```

## 3. 렌더링 이해를 위한 핵심 개념

- **SSG (Static Site Generation)**

  - **fetch한 데이터는 영원히 변하지 않는다.**

  - 컴포넌트를 갱신할 필요가 없다.

  - SSG는 빌드 타임 때만 컴포넌트를 생성하고, 이후에는 변하지 않는 페이지로 가정하여 static 컴포넌트를 제공하는 것을 말한다.

  - Next.js는 아무것도 하지 않으면 기본적으로 SSG로 동작한다.

- **ISR (Incremental Site Regeneration)**

  - **fetch한 데이터는 가끔씩 변한다.**

  - 일정 주기마다 가끔씩만 컴포넌트를 갱신해준다.

  - ISR은 빌드 타임 때 컴포넌트를 초기 생성하고, 이후에는 일정 주기마다 변화를 적용하여 컴포넌트를 제공하는 것을 말한다.

- **SSR (Server Side Rendering)**

  - **fetch한 데이터는 실시간으로 계속 바뀐다.**

  - 컴포넌트 요청이 있을 때마다 데이터를 갱신해서 최신 데이터만 제공해야 한다.

  - SSR은 빌드 타임 때 컴포넌트를 초기 생성하고, 이후 컴포넌트 요청이 있을 때마다 변화를 적용하여 가장 최신의 데이터를 사용자에게 제공한다.

- **CSR (Client Side Rendering)**

  - **fetch한 데이터는 실시간으로 계속 바뀐다.**

  - 컴포넌트 요청이 있을 때마다 데이터를 갱신해서 최신 데이터만 제공해야 한다.

  - CSR은 **빌드 타임 때 컴포넌트를 초기 생성하지는 않는다.** 자바스크립트로 이루어진 리액트 파일을 다운로드 받고 그제서야 화면이 그려지게 된다.

## 4. 주요 렌더링 패턴 4가지 직접 구현해보기(with fetch)

- 선행되어야 할 것

  - 원활한 테스트를 위해서는 dev 모드가 아닌 production 모드로 진행해야 한다.

  - 테스트 할 내용

    - 새로고침 시, 데이터를 로딩하는 절차 없이 바로 가지고 오는가?

    - 새로고침 시, 데이터를 갱신하는 주기가 어떻게 되는가?

  - ㅇㅇ

- fetch 시, **아무 옵션도 주지 않으면 SSG**이다.

- fetch 시, **일정 주기로 갱신하는 옵션을 주면 ISR**이다.

- fetch 시, **매번 갱신하는 옵션을 주면 SSR**이다.

- fetch 시, **`"use client"`가 들어가면 CSR**이다.

<br>
<hr>
<br>

<Next.js> 5주차(Route Handlers) 강의 내용 정리 부분

## 5. Full Stack이란?

## 6. Route Handlers

## 7. 실습
