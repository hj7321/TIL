## 0610_Day37

리액트 스탠다드 4일차 강의 내용 정리

## 1. 이벤트 핸들러 함수 할당 시 주의사항

- **이벤트 핸들러 함수**

  - 사용자가 웹 페이지와 상호작용할 때 발생하는 이벤트를 처리하기 위한 함수
  - 특정 이벤트가 발생했을 때 실행되며, 이벤트 객체(event object)를 통해 이벤트에 대한 다양한 정보를 얻을 수 있다.

- **이벤트(Event)**

  - 사용자가 웹 페이지와 상호작용할 때 발생하는 사건
  - 예: 클릭(click), 키보드 입력(keydown, keyup), 마우스 이동(mousemove), 폼 제출(submit) 등

- **이벤트 핸들러(Event Handler)**

  - 이벤트가 발생했을 때 실행되는 함수
  - 특정 요소에 이벤트 핸들러를 등록하여 이벤트 발생 시 해당 함수를 호출한다.

- **이벤트 핸들러 함수는 매개변수로 이벤트 객체를 받는 특징을 가지고 있다.**

  ```
  onClick={handleCountDown} === onClick={event => handleCountDown(event)}
  ```

  - 잘못된 이벤트 핸들러 방식 코드

    ```jsx
    function App() {
      const [initialNum, setInitialNum] = useState(0);

      const addNumber = (number) => {
        const addedNumber = initialNum + number * 1;
        setInitialNum(addedNumber);
      };

      return (
        <div>
          <h1>덧셈과 뺄셈이 가능한 앱 만들기</h1>
          <div>
            <input
              type="text"
              value={initialNum}
              onChange={(event) => event.target.value}
            />{" "}
            만큼을{" "}
            <button onClick={(number) => addNumber(number)}>더할게요</button>
          </div>
          ...
        </div>
      );
    }
    ```

    - 입력 필드의 `onChange` 핸들러
      - `onChange` 핸들러가 현재 `event.target.value`를 반환만 하고 있다.
      - 상태를 업데이트해야 한다.
      - 수정된 상태를 `setInitialNum`을 사용하여 반영해야 한다.
    - 버튼의 `onClick` 핸들러
      - **`onClick` 핸들러는 number를 인자로 받으려고 하지만, 실제로는 이벤트 객체를 받는다.**
      - 버튼 클릭 시 입력 필드의 값을 읽어서 addNumber() 함수에 전달해야 한다.

  - 수정된 코드

    ```jsx
    import React, { useState } from "react";

    function App() {
      const [initialNum, setInitialNum] = useState(0);
      const [inputValue, setInputValue] = useState("");

      const addNumber = () => {
        const number = Number(inputValue); // 입력 값을 숫자로 변환
        const addedNumber = initialNum + number;
        setInitialNum(addedNumber);
        setInputValue(""); // 입력 필드를 비움
      };

      return (
        <div>
          <h1>덧셈과 뺄셈이 가능한 앱 만들기</h1>
          <div>
            <input
              type="text"
              value={inputValue}
              onChange={(event) => setInputValue(event.target.value)}
            />{" "}
            만큼을 <button onClick={addNumber}>더할게요</button>
          </div>
        </div>
      );
    }

    export default App;
    ```

    - 추가 상태 변수 `inputValue`
      - 입력 필드의 값을 관리하기 위해 `inputValue` 상태 변수를 추가했다.
    - 입력 필드의 `onChange` 핸들러
      - 입력 필드의 값을 `inputValue` 상태로 업데이트한다.
    - addNumber() 함수
      - 입력 필드의 값을 읽어 숫자로 변환하고, `initialNum`에 더한 뒤 상태를 업데이트한다.
      - 입력 필드의 값을 초기화한다.
    - 버튼의 `onClick` 핸들러
      - addNumber() 함수를 호출하여 상태를 업데이트한다.

## 2. `useState`

- 상태 변경 함수인 `setState`의 실행은 비동기적으로 동작한다.

  ```jsx
  import React, { useState } from "react";

  function App() {
    const [count, setCount] = useState(0);

    const handleClick = () => {
      setCount(count + 1);
      console.log("1st count:", count); // 0

      setCount(count + 1);
      console.log("2nd count:", count); // 0
    };

    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={handleClick}>증가</button>
      </div>
    );
  }

  export default App;
  ```

  - 콘솔 창에서 count가 0이 찍히는 이유는 **리액트의 상태 업데이트가 비동기적으로 일어나기 때문**이다.
  - 리액트의 상태 업데이트는 즉시 이루어지지 않으며, **상태가 업데이트된 후에 컴포넌트가 다시 렌더링되기 전까지 상태 값은 변경되지 않는다.**
  - 따라서, 동일한 이벤트 핸들러 내에서 여러 번 상태를 업데이트하려고 하면, **해당 이벤트 핸들러가 끝날 때까지 이전 상태 값이 유지**된다.
  - 첫 번째 `setCount(count + 1)`
    - `setCount` 함수를 호출하면 리액트는 상태 업데이트를 예약한다. 이 시점에서 count는 여전히 0이다.
    - 하지만, 상태가 즉시 업데이트되는 것이 아니라 나중에 비동기적으로 처리된다. 따라서 count 값은 여전히 0으로 유지된다.
  - `console.log("1st count:", count)`
    - 이 로그는 **`setCount` 함수 호출 이후에 실행되지만, 상태는 아직 업데이트되지 않았다.**
    - 따라서 이 로그는 count의 현재 값인 0을 출력한다.
  - 두 번째 `setCount(count + 1)`
    - 두 번째 `setCount` 함수 호출도 상태 업데이트를 예약한다.
    - 이 호출도 마찬가지로 **count 값이 업데이트되기 전에 호출되므로 여전히 0을 사용**한다.
  - `console.log("2nd count:", count)`
    - 두 번째 로그도 `setCount` 함수 호출 이후에 실행되지만, 상태는 여전히 업데이트되지 않았다.
    - 따라서 이 로그도 0을 출력한다.
  - 상태 업데이트 후
    - 이벤트 핸들러가 종료된 후, 리액트는 예약된 상태 업데이트를 처리하고, 컴포넌트를 다시 렌더링한다.
    - 이때,
