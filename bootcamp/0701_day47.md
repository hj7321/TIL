## 0701_Day47

<React 심화> 강의 내용 정리 부분

# 1. TanStack Query 3 - 심화

## 1. Query Cancellation

- 사용 용도

  - 다운로드 UI가 있을 때, 또는 UX를 저해시키는 **불필요한 네트워크 요청을 제거**하기 위해 사용된다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fd6e995d7-bb6d-4c52-a7e3-0bab4b74d8e8%2FUntitled.png?table=block&id=2a390355-7ac8-4006-8761-a7193db3291a&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=500&userId=&cache=v2)

  - **대용량 fetching을 중간에 취소**하거나 **사용하지 않는 컴포넌트에서 fetching이 진행 중**이면 **자동으로 취소**시켜 불필요한 네트워크 비용을 줄일 수 있다.

  - `queryFn`의 매개변수로 **Abort Signal**을 받을 수 있고, 이를 이용해서 **쿼리 취소**를 가능하게 한다.

- 사용 방법

  - `queryFn`은 매개변수로 `QueryFunctionContext`라는 객체를 받는다.

    ```jsx
    export const getTodos = async (queryFnContext) => {
      const { queryKey, pageParam, signal, meta } = queryFnContext;

      const response = await axios.get("http://localhost:5000/todos", {
        signal,
      });
      // 요청에 signal을 포함시켜 쿼리를 취소할 수 있도록 한다.
      return response.data;
    };

    useQuery({
      queryKey: ["todos"],
      queryFn: getTodos,
    });
    ```

    - `queryFnContext`

      - **`useQuery` 훅이 `queryFn` 함수에 전달하는 컨텍스트(`QueryFunctionContext` 객체)**

      - 이 컨텍스트 객체는 **React Query 내부에서 생성**되며, **`useQuery` 훅이 `queryFn`을 호출할 때 자동으로 전달**된다.

      - 이 객체는 쿼리 키, 페이지 매개변수, 요청 취소 신호 등 쿼리를 수행하는 데 필요한 다양한 정보를 포함한다.

    - `queryFnContext`의 속성 설명

      1. `queryKey`

         - 설명: **쿼리를 식별**하기 위해 사용되는 키이다. **쿼리 함수가 실행될 때 이 키를 사용하여 쿼리 결과를 캐싱하고 관리**한다.

         - 예시: `["todos"]`와 같은 배열 형태로 사용된다.

         - 용도: API 요청 URL을 동적으로 구성하거나, 캐싱된 데이터를 식별하는 데 사용된다.

      2. `pageParam`

         - 설명: 주로 **무한 스크롤**이나 **페이지네이션** 기능에서 사용되는 매개변수이다. **다음 페이지를 요청할 때 필요한 매개변수를 제공**한다.

         - 예시: 페이지 번호 또는 다음 페이지를 가져오기 위한 커서 값 등이 될 수 있다.

         - 용도: 페이지네이션이 구현된 API에서 다음 페이지를 가져오는 데 사용된다.

      3. `signal`

         - 설명: **`AbortSignal` 객체**로, **쿼리를 중단**할 때 사용된다. React Query가 쿼리를 취소할 때 이 신호를 활용한다.

         - 예시: `axios` 요청을 중단하는 데 사용된다.

         - 용도: 쿼리를 중단하고 자원 낭비를 방지하거나, 사용자가 네트워크 요청을 취소할 수 있도록 한다.

      4. `meta`

         - 설명: 쿼리와 관련된 **추가 메타데이터**를 포함할 수 있는 객체이다.

         - 예시: 사용자 정의 데이터나 플래그 등을 포함할 수 있다.

         - 용도: 쿼리 함수 내부에서 추가적인 데이터를 필요로 할 때 사용된다.

  - 페이지 컴포넌트 unmount 시 Query 취소

    - API 요청 시 기본 설정은 컴포넌트가 unmount 되어도 네트워크 요청은 중단되지 않는다.

    - **GET 요청 시 abort signal**이 옵션으로 들어간 경우에만 **unmount 시 자동으로 네트워크가 취소**된다.

      ```jsx
      import axios from "axios";

      const query = useQuery({
        queryKey: ["todos"],
        queryFn: ({ signal }) =>
          axios.get("/todos", {
            signal,
          }),
      });
      ```

  - 수동으로 Query 취소

    ```jsx
    const query = useQuery({
      queryKey: ["todos"],
      queryFn: async ({ signal }) => {
        const resp = await fetch("/todos", { signal });
        return resp.json();
      },
    });

    const queryClient = useQueryClient();

    return (
      <button
        onClick={(e) => {
          e.preventDefault();
          queryClient.cancelQueries({ queryKey: ["todos"] });
          // "todos" 키와 관련된 쿼리를 수동으로 취소한다.
          // 이 함수는 fetch 요청에 전달된 signal을 통해 요청을 취소한다.
        }}
      >
        Cancel
      </button>
    );
    ```

- 사용 시 주의사항

  - 불필요한 네트워크 요청을 최소화한다는 명분으로 단순하게 **모든 GET 요청마다 Abort Signal을 심는 것은 작업부하를 올리고 바람직하지 않다.**

  - 동영상 다운로드 같은 대용량 fetching이 아닌 이상 대부분의 GET 요청은 빠르게 완료 및 캐싱 처리되어 성능에 유의미한 영향을 끼치지 않는다.

  - **대용량 fetching이 있는 경우** 또는 **Optimistic UI를 구현**할 때처럼 **필요한 경우에만 적용**해야 한다.

## 2. Optimistic Updates

![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F8199403a-d0e7-44da-97c7-89f800e45557%2FUntitled.png?table=block&id=9da3a9fd-e62d-4584-aac7-77f587bc2ee8&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1600&userId=&cache=v2)

- 서버 요청이 정상적으로 잘 될거라는 가정 하에 **UI 변경을 먼저 하고 서버 요청**을 하는 방식

- 만약 서버 요청이 실패하는 경우, UI를 원상복구(revert/roll back)한다.

- React Query는 변형이 완료되기 전에 UI를 낙관적으로 업데이트하는(Optimistic Updates) 두 가지 방법을 제공한다.

  1. **UI를 통한 방법**: 반환된 변수를 활용하여 `useMutation` 결과에서 UI를 업데이트한다.

     - 캐시와 직접 상호 작용하지 않으므로 더 간단한 방법이다.

       ```jsx
       const addTodoMutation = useMutation({
        mutationFn: (newTodo) => axios.post("/api/data", {text: newTodo})
        onSettled: async () => {
          return await queryClient.invalidateQueries({queryKey: ["todos"]})
        },
       });

       const {isPending, submittedAt, variables, mutate, isError} = addTodoMutation;
       ```

       - `mutationFn`

         - 변이를 수행하는 함수
         - 이 예제에서는 `newTodo` 문자열을 받아서, `axios.post`를 사용하여 "/api/data" 엔드포인트에 POST 요청을 보낸다. 이 요청의 본문에는 `newTodo`가 포함된다.

       - `onSettled`

         - **변이 작업이 성공하거나 실패한 후에 호출되는 콜백 함수**
         - 이 예제에서는 `todos` 쿼리를 무효화하여, 다음 번에 해당 쿼리를 사용할 때 최신 데이터를 가져오도록 한다.
         - 이로써 새로운 `todo`가 추가된 후 `todos` 목록이 갱신되도록 한다.
         - **`invalidateQueries` 메서드가 반환하는 `Promise`가 해결될 때까지 기다린다.**
         - `async`, `await` 키워드를 사용한 방식은 **해당 작업이 완료될 때까지 다른 작업을 기다려야 하는 경우** 유용하다.

       - `addTodoMutation`에서 제공하는 값들

         - `isPending` : 변이가 진행 중인지 여부를 나타내는 불리언 값
         - `submittedAt` : 변이가 제출된 시간
         - `variables` : 변이를 수행할 때 사용된 변수들. 이 예제에서는 `newTodo`가 된다.
         - `mutate` : 변이를 트리거하는 함수. 이 함수를 호출하여 변이를 실행할 수 있다.
         - `isError` : 변이 실행 중 오류가 발생했는지 여부를 나타내는 불리언 값

       - 설명

         - 이렇게 하면 추가된 할 일이 포함된 `addTodoMutation.variables`에 접근할 수 있다.
         - **쿼리가 렌더링되는 UI 목록에서 변이가 `isPending`인 동안 목록에 다른 항목을 추가할 수 있다.**
           ```tsx
           <ul>
             {todoQuery.items.map((todo) => {
               <li key={todo.id}>{todo.text}</li>;
             })}
             {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
           </ul>
           ```
           - 변이가 `isPending`인 동안에는 다른 불투명도(opacity)로 임시 아이템을 렌더링한다.
           - 변이가 완료되면 해당 항목은 자동으로 더 이상 렌더링되지 않는다.
           - 리페치(다시 가져오기)가 성공했으므로 목록에서 해당 아이템이 일반 아이템으로 표시된다.
         - 변이 오류가 발생하면 항목도 사라진다. 그러나 원하는 경우 변이의 `isError` 상태를 확인하여 계속 표시할 수 있다.
         - **변이는 변이 오류가 발생해도 지워지지 않으므로 계속 접근**할 수 있으며, 재시도 버튼을 표시할 수도 있다.
           ```tsx
           {
             isError && (
               <li style={{ color: "red" }}>
                 {variables}
                 <button onClick={() => mutate(variables)}>Retry</button>
               </li>
             );
           }
           ```

     - 돌연변이와 쿼리가 동일한 컴포넌트에 있지 않은 경우

       - 이 방법은 변이와 쿼리가 동일한 컴포넌트에 있는 경우 매우 잘 작동하지만, 전용 **`useMutationState` 훅을 통해 다른 컴포넌트의 모든 변이에도 접근**할 수 있다.

       - 이 방법은 **`mutationKey`와 함께 사용**하는 것이 좋다.

         ```jsx
         const { mutate } = useMutation({
           mutationFn: (newTodo) => axios.post("/api/data", { text: newTodo },
           onSettled: () => queryClient.invalidateQueries({ queryKey: ["todos"] }),
           mutationKey: ["addTodo"],
           )
         });

         const variables = useMutationState({
           filters: { mutationKey: ["addTodo"], status: "pending" },
           select: (mutation) => mutation.state.variables,
         });
         ```

         - `useMutation` 훅

           - `mutationFn`

             - 변이를 수행하는 함수
             - 이 예제에서는 `newTodo` 문자열을 받아서, `axios.post`를 사용하여 "/api/data" 엔드포인트에 POST 요청을 보낸다. 이 요청의 본문에는 `newTodo`가 포함된다.

           - `onSettled`

             - **변이 작업이 성공하거나 실패한 후에 호출되는 콜백 함수**
             - 이 예제에서는 `todos` 쿼리를 무효화하여, 다음 번에 해당 쿼리를 사용할 때 최신 데이터를 가져오도록 한다.
             - 이로써 새로운 `todo`가 추가된 후 `todos` 목록이 갱신되도록 한다.
             - **`invalidateQueries` 메서드는 `Promise`를 반환하지만, 이 `Promise`가 해결될 때까지 기다리지 않고 즉시 반환한다.**
             - `async`, `await` 키워드를 사용하지 않는 방식은 **`onSettled` 콜백이 비동기 작업의 완료를 기다릴 필요가 없는 경우** 사용한다.

           - `mutationKey`

             - **변이의 고유 키**
             - 이 예제에서는 `addTodo`라는 키를 사용하고 있다.

         - `useMutationState` 훅

           - **변이의 상태를 추적**하는 데 사용된다.
           - 이 훅은 아직 공식적인 React Query API에 포함되지 않은 것으로 보이며, 실제로는 `useMutation` 훅의 반환값으로 추적해야 한다.

           - `filters`

             - 특정 조건에 맞는 변이 상태를 필터링한다.
             - 여기서는 `addTodo` 변이 키와 "pending" 상태를 가진 변이를 필터링한다.

           - `select`

             - 필터링된 변이 상태에서 선택한 데이터를 정의한다.
             - 여기서는 변이 상태의 `variables`를 선택한다.

         - 설명

           - **변수는 동시에 여러 개의 변이가 실행될 수 있으므로 배열이 된다.**
           - **항목에 대한 고유 키**가 필요한 경우, **`mutation.state.submittedAt`** 를 선택할 수도 있다.
           - 이렇게 하면 낙관적인 업데이트를 동시에 표시하는 것도 쉬워진다.

  2. **캐시를 통한 방법**: `onMutate` 옵션을 사용하여 캐시를 직접 업데이트한다.

     - 변이를 수행하기 전에 상태를 낙관적으로 업데이트하면 변이가 실패할 가능성이 있다.

     - 이러한 실패 사례의 대부분은 낙관적인 쿼리에 대한 리페치를 트리거하여 실제 서버 상태로 되돌릴 수 있다.

     - 하지만 일부 상황에서는 리페칭이 제대로 작동하지 않을 수 있으며, 변이 오류는 리페칭을 할 수 없는 서버 문제를 나타낼 수 있다.

     - 이 경우 대신 **업데이트를 롤백**하도록 선택할 수 있다.

     - 이렇게 하려면 **`useMutation`의 `onMutate` 핸들러 옵션**을 사용하면 나중에 **`onError` 및 `onSettled` 핸들러에 마지막 인수로 전달될 값을 반환**할 수 있다.

     - 대부분의 경우 **롤백 함수를 전달**하는 것이 가장 유용하다.

     - 새 할 일을 추가할 때 할 일 목록 업데이트

       ```jsx
       const queryClient = useQueryClient();

       useMutation({
         mutationFn: updateTodo,
         onMutate: async (newTodo) => {
           await queryClient.cancelQueries({ queryKey: ["todos"] });
           const previousTodos = queryClient.getQueryData(["todos"]);
           queryClient.setQueryData(["todos"], (old) => [...old, newTodo]);
           return { previousTodos };
         },
         onError: (err, newTodo, context) => {
           queryClient.setQueryData(["todos"], context.previousTodos);
         },
         onSettled: () => {
           queryClient.invalidateQueries({ queryKey: ["todos"] });
         },
       });
       ```

       - `mutationFn`

         - 변이를 수행하는 함수
         - 이 예제에서는 `updateTodo` 함수가 사용된다. 이 함수는 새로운 할 일 항목을 서버에 업데이트한다.

       - `onMutate`

         - `onMutate` 콜백은 **변이가 시작되기 전에 호출**된다.
         - 여기서 **낙관적 업데이트**를 수행할 수 있다.
         - 코드 설명
           - 현재 진행 중인 `todos` 쿼리를 취소한다. 이렇게 하면 변이 중에 발생하는 잠재적 충돌을 방지할 수 있다.
           - 현재 `todos` 데이터를 가져와서 `previousTodos`에 저장한다.
           - 새로운 할 일(`newTodo`) 항목을 추가하여 낙관적 업데이트를 수행한다. 여기서 `old`는 이전의 `todos` 데이터이다.
           - `onMutate` 콜백은 **`context` 객체를 반환**한다. 이 객체는 **`onError` 콜백에서 사용**할 수 있다.

       - `onError`

         - **변이 중 오류가 발생했을 때 호출**된다.
         - 이 예제에서는 **오류가 발생하면, `context.previousTodos`를 사용하여 `todos` 데이터를 이전 상태로 복원**한다.
         - 이렇게 하면 오류가 발생했을 때 UI가 일관된 상태를 유지할 수 있다.

       - `onSettled`

         - **변이가 성공하거나 실패한 후에 호출**된다.
         - 이 예제에서는 `todos` 쿼리를 무효화하여 최신 데이터를 다시 가져오도록 한다.

     - 단일 할 일 업데이트

       ```jsx
       const queryClient = useQueryClient();

       useMutation({
         mutationFn: updateTodo,
         onMutate: async (newTodo) => {
           await queryClient.cancelQueries({ queryKey: ["todos", newTodo.id] });
           const previousTodo = queryClient.getQueryData(["todos", newTodo.id]);
           queryClient.setQueryData(["todos", newTodo.id], newTodo);
           return { previousTodo, newTodo };
         },
         onError: (err, newTodo, context) => {
           queryClient.setQueryData(
             ["todos", context.newTodo.id],
             context.previousTodo
           );
         },
         onSettled: (newTodo) => {
           queryClient.invalidateQueries({ queryKey: ["todos", newTodo.id] });
         },
       });
       ```

       - `mutationFn`

         - 변이를 수행하는 함수
         - 이 예제에서는 `updateTodo` 함수가 사용된다. 이 함수는 새로운 할 일 항목을 서버에 업데이트한다.

       - `onMutate`

         - `onMutate` 콜백은 **변이가 시작되기 전에 호출**된다.
         - 여기서 **낙관적 업데이트**를 수행할 수 있다.
         - 코드 설명
           - 현재 진행 중인 특정 할 일(`newTodo.id`) 항목에 대한 쿼리를 취소한다. 이렇게 하면 변이 중에 발생하는 잠재적 충돌을 방지할 수 있다.
           - 현재 특정 할 일(`newTodo.id`) 항목의 데이터를 가져와서 `previousTodo`에 저장한다.
           - 특정 할 일(`newTodo.id`) 항목의 데이터를 `newTodo`로 업데이트하여 낙관적 업데이트를 수행한다. 여기서 `newTodo`는 업데이트된 데이터이다.
           - `onMutate` 콜백은 **`context` 객체를 반환**한다. 이 객체는 **`onError` 콜백에서 사용**할 수 있다.

       - `onError`

         - **변이 중 오류가 발생했을 때 호출**된다.
         - 이 예제에서는 **오류가 발생하면, `context.previousTodo`를 사용하여 특정 할 일 항목의 데이터를 이전 상태로 복원**한다.
         - 이렇게 하면 오류가 발생했을 때 UI가 일관된 상태를 유지할 수 있다.

       - `onSettled`

         - **변이가 성공하거나 실패한 후에 호출**된다.
         - 이 예제에서는 특정 할 일 항목에 대한 쿼리를 무효화하여 최신 데이터를 다시 가져오도록 한다.

## 3. Prefetching

- **페이지 이동 전에 이동할 페이지의 쿼리를 백그라운드에서 미리 호출**한다.

- 캐시 데이터가 있는 상태로 해당 페이지로 이동 시, 로딩 없이 바로 UI를 볼 수 있다.

  ```jsx
  const prefetchTodos = async () => {
    await queryClient.prefetchQuery({
      queryKey: ["todos"],
      queryFn: fetchTodos,
    });
  };
  ```

  - **미리 호출(prefetch)할 `queryKey`와 `queryFn`은 이동할 페이지의 쿼리와 동일**해야 한다.

  - `prefetchQuery`의 기능

    - **데이터 페칭을 미리 수행**하여, 사용자가 해당 데이터가 필요할 때 더 빠르게 응답할 수 있도록 도와준다.

    - 이는 사용자 경험을 향상시키는 데 유용하다.

  - `prefetchQuery`의 특징

    - **비동기 데이터 미리 가져오기** : 데이터를 미리 가져와서 캐시에 저장한다. 이렇게 하면 사용자가 해당 데이터를 요청할 때 빠르게 응답할 수 있다.

    - **자동 캐시 관리** : 데이터를 캐시에 저장하고, 나중에 동일한 `queryKey`로 쿼리를 수행할 때 캐시된 데이터를 반환한다.

    - **유효성 검사** : 자동으로 데이터를 가져와 캐시에 저장하므로, 데이터가 최신 상태인지 확인하는 데 유용하다.

  - `prefetchQuery` 예제

    - 페이지 전환 전 데이터 미리 가져오기

      ```jsx
      const prefetchNextPage = async () => {
        await queryClient.prefetchQuery({
          queryKey: ["page", nextPage],
          queryFn: () => fetchPageData(nextPage),
        });
      };
      ```

      - 사용자가 다음 페이지로 이동하기 전에 데이터를 미리 가져와서 페이지 전환 시 로딩 시간을 줄일 수 있다.

    - 호버 시 데이터 미리 가져오기

      ```jsx
      const prefetchOnHover = async (todoId) => {
        await queryClient.prefetchQuery({
          queryKey: ["todo", todoId],
          queryFn: () => fetchTodoById(todoId),
        });
      };
      ```

      - 사용자가 특정 `todo` 항목 위로 마우스를 올릴 때 데이터를 미리 가져와서 클릭 시 로딩 시간을 줄일 수 있다.

## 4. Paginated / Lagged Queries

![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fdd2ac306-d2d2-4fee-b8dd-4801458c0293%2FUntitled.png?table=block&id=4e948bbe-e531-48f6-aa9c-a744feab3bfc&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

- 다른 페이지 클릭 시 매번 Loading UI를 보여주기보다는 **기존 UI를 유지하다가 서버로부터 새로운 데이터를 받아왔을 때 바꾸는 방식**을 적용할 수 있다.

- `useQuery`의 옵션 중 **`keepPreviousData`를 `true`로 바꾸면 이전 캐시 데이터를 기반으로 `isLoading` 여부를 판단**하게 한다.

- 페이지가 매겨진 데이터를 렌더링하는 것은 매우 일반적인 UI 패턴이며, TanStack Query에서는 쿼리 키에 페이지 정보를 포함하면 그냥 작동한다.

  ```jsx
  const result = useQuery({
    queryKey: ["projects", page],
    queryFn: fetchProjects,
  });
  ```

  - 하지만 이 간단한 예제를 실행해 보면 이상한 점을 발견할 수 있다.

  - **각각의 새 페이지가 완전히 새로운 쿼리처럼 취급**되기 때문에 **UI가 성공 및 보류 중 상태를 오가는 것**을 볼 수 있다.

  - 이러한 환경은 최적이 아니지만, 안타깝게도 오늘날 많은 도구가 이 방식을 고집하고 있다.

  - 하지만 TanStack Query에는 이 문제를 해결할 수 있는 **`placeholderData` 기능**이 포함되어 있다.

- `placeholderData`로 쿼리 페이지네이션 개선하기

  - 쿼리에 대한 페이지 인덱스(또는 커서)를 증가시키고자 하는 예제를 생각해 보자.

  - `useQuery`를 사용하면 기술적으로는 여전히 정상적으로 작동하지만, 각 페이지 또는 커서마다 다른 쿼리가 생성 및 소멸됨에 따라 UI가 성공 및 보류 중 상태를 오가게 된다.

  - TanStack Query의 **`placeholderData`를 `(previousData) => previousData` 또는 `keepPreviousData` 함수로 설정**하면 몇 가지 새로운 기능을 얻을 수 있다.

    - **쿼리 키가 변경되었더라도** 새 데이터를 요청하는 동안 **마지막으로 성공적으로 가져온 데이터를 사용**할 수 있다.

    - **새 데이터가 도착하면 이전 데이터가 원활하게 교체**되어 새 데이터가 표시된다.

    - **쿼리가 현재 어떤 데이터를 제공**하는지 알 수 있도록 **`isPlaceholderData`를 사용**할 수 있다.

  - 예제

    ```jsx
    import { keepPreviousData, useQuery } from "@tanstack/react-query";
    import { useState } from "react";

    function Todos() {
      const [page, setPage] = useState(0); // 페이지 번호를 상태로 관리한다.

      const fetchProjects = (page = 0) =>
        fetch("/api/projects?page=" + page).then((res) => res.json());
      // 페이지 번호를 인자로 받아 서버에서 프로젝트 목록을 가져오는 비동기 함수이다.

      const { isPending, isError, error, data, isFetching, isPlaceholderData } =
        useQuery({
          queryKey: ["projects", page],
          queryFn: () => fetchProjects(page),
          placeholderData: keepPreviousData,
        });

      return (
        <div>
          {isPending ? (
            <div>Loading...</div>
          ) : isError ? (
            <div>Error: {error.message}</div>
          ) : (
            <div>
              {data.projects.map((project) => (
                <p key={project.id}>{project.name}</p>
              ))}
            </div>
          )}
          <span>Current Page: {page + 1}</span>
          <button
            onClick={() => setPage((old) => Math.max(old - 1, 0))}
            disabled={page === 0}
          >
            Previous Page
          </button>{" "}
          <button
            onClick={() => {
              if (!isPlaceholderData && data.hasMore) setPage((old) => old + 1);
            }}
            disabled={isPlaceholderData || !data?.hasMore}
          >
            Next Page
          </button>
          {isFetching ? <span>Loading...</span> : null}
        </div>
      );
    }
    ```

    - `useQuery` 훅 사용 부분

      - `queryKey`

        - 쿼리를 식별하는 고유한 키

        - `page` 상태 값에 따라 페이지별로 다른 데이터를 가져오게 된다.

      - `queryFn`

        - 실제 데이터를 가져오는 비동기 함수

        - `page`를 인자로 넘겨서 해당 페이지의 프로젝트 목록을 가져온다.

      - `placeholderData`

        - **이전 데이터를 유지**하는 옵션이다.

        - 새로운 데이터가 로딩되기 전에 이전 데이터를 보여주어 사용자 경험을 향상시킨다.

      - `useQuery` 훅에서 반환된 여러 상태값

        - `isPending` : **데이터가 로딩 중인지의 여부**를 나타낸다.

        - `isError` : **데이터를 가져오는 중 오류가 발생했는지의 여부**를 나타낸다.

        - `error` : **오류 객체**이다.

        - `data` : **실제로 가져온 데이터 객체**이다. 여기서는 `projects` 배열을 포함하고 있다.

        - `isFetching` : **데이터를 다시 가져오는 중인지의 여부를** 나타낸다.

        - `isPlaceholderData` : **이전 데이터를 표시하는 중인지의 여부**를 나타낸다.

    - 페이지 네비게이션 버튼

      - "Previous Page" 버튼

        - `onClick` 핸들러

          - 현재 페이지를 나타내는 `page` 상태를 업데이트한다.
          - `setPage()` 함수는 이전 상태값 `old`를 받아서 새로운 페이지를 설정한다. **`Math.max(old - 1, 0)`을 사용하여 페이지가 음수가 되지 않도로록 보장**한다.

        - `disabled` 속성

          - 버튼을 비활성화할지 여부를 결정한다.
          - `page === 0`일 때 버튼이 비활성화된다.
          - 즉, 첫 번째 페이지일 때 이전 페이지로 이동할 수 없다.

      - "Next Page" 버튼

        - `onClick` 핸들러

          - 조건을 만족할 때만 페이지를 증가시킨다.
          - `isPlaceholderData`는 이전 데이터를 표시 중인지 여부를 나타내는 상태값이다.
          - `data.hasMore`은 현재 데이터에 더 많은 페이지가 있는지 여부를 나타내는 상태값이다.
          - **이전 데이터를 표시하는 중이 아니고, 현재 데이터에 더 많은 페이지가 있다면 페이지를 업데이트**한다.

        - `disabled` 속성

          - 버튼을 비활성화할지 여부를 결정한다.
          - 이전 데이터를 표시하는 중이거나, 현재 데이터가 없거나, 현재 데이터에 더 많은 페이지가 없다면 버튼이 비활성화된다.

- `placeholderData`로 무한 쿼리 결과 지연시키기

  - 일반적이지는 않지만, `placeholderData` 옵션도 `useInfiniteQuery` 훅과 완벽하게 작동한다.

  - 따라서 **무한 쿼리 키가 시간에 따라 변경되는 동안 사용자가 캐시된 데이터를 계속 볼 수 있도록 원활하게 허용**할 수 있다.

## 5. Infinite Queries

![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F357a16c4-bb56-407f-a9b0-84a61a25f9e3%2FUntitled.png?table=block&id=4153db5f-ec60-4c02-bf0b-5643e77a2c4d&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1300&userId=&cache=v2)

- 데이터 페칭이 일어날 때마다 기존 리스트 데이터에 페치된 데이터를 추가하고자 할 때 유용하게 사용할 수 있는 훅이다.

- 더보기 UI 또는 무한 스크롤 UI에 사용하기 적합하다.

- 예제

  ```jsx
  const fetchProjects = async ({ pageParam = 0 }) => {
    const res = await fetch("/api/projects?cursor=" + pageParam);
    return res.json();
  };

  const {
    data,
    error,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
    status,
  } = useInfiniteQuery({
    queryKey: ["projects"],
    queryFn: fetchProjects,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  });
  ```

  - `fetchProjects()` 함수

    - 페이지마다 프로젝트 데이터를 비동기적으로 가져오는 함수이다.

    - `{ pageParam = 0 }`은 함수에 전달되는 매개변수이다. `pageParam`은 기본적으로 0으로 설정되어 있으며, 페이지를 나타내는 커서(cursor) 값을 받는다.

    - "/api/projects?cursor="를 통해 서버로부터 데이터를 가져온다.

    - `fetch()` 함수를 사용하여 데이터를 가져온 후, `res.json()`을 통해 JSON 형식으로 변환하여 반환한다.

  - `useInfiniteQuery` 훅 사용

    - `queryKey`

      - 쿼리를 식별하는 고유한 키

      - 여기서는 `projects` 데이터를 가져오는 쿼리를 실행한다.

    - `queryFn`

      - 실제 데이터를 가져오는 비동기 함수

      - 앞서 정의한 `fetchProjects()` 함수를 사용하여 페이지별 데이터를 가져온다.

    - `getNextPageParam`

      - **다음 페이지의 매개변수를 지정하는 함수**

      - **`lastPage`** 는 **마지막으로 받은 페이지의 데이터**를 나타낸다.

      - **`pages`** 는 **지금까지 가져온 모든 페이지의 배**열이다.

      - 이 함수는 **다음 페이지를 가져오기 위해 필요한 커서 값을 반환**한다.

    - `useInfiniteQuery`의 반환값

      - `data` : 현재 로드된 데이터를 나타낸다. `useInfiniteQuery`는 페이지별로 데이터를 배열 형태로 반환한다.
      - `error` : 데이터 가져오기 과정에서 발생한 오류를 나타낸다.
      - `fetchNextPage` : **다음 페이지의 데이터를 가져오는 함수**이다. **사용자가 스크롤을 내릴 때 호출**되어 다음 페이지의 데이터를 가져온다.
      - `hasNextPage` : **다음 페이지가 있는지 여부를 나타내는 불리언 값**이다.
      - `isFetching` : **데이터를 가져오는 중인지 여부**를 나타낸다.
      - `isFetchingNextPage` : **다음 페이지를 가져오는 중인지 여부**를 나타낸다.
      - `status` : **현재 쿼리의 상태**를 나타낸다. (`idle`, `loading`, `success`, `error` 등)

  - 실행 순서 정리

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fd4b9f666-f646-4221-8b72-ab747f95bf4b%2FUntitled.png?table=block&id=0a4a5b29-6302-4076-9a8a-2ebed7593287&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1400&userId=&cache=v2)

    1. `queryFn`이 실행된다.

    2. **`{ pages, pageParams }`가 캐시 데이터로 등록**된다.

    3. `getNextPageParam`이 실행된다. **리턴된 `nextPageParam`은 캐시가 아닌 훅 내부 메모리에 저장**된다.

    4. `nextPageParam`이 `undefined`가 아닌 경우, `hasNextPage`는 `true`로 상태가 변경된다.

    5. `fetchNextPage`가 실행된다.

    6. 다시 `queryFn`이 실행된다. 이때 **내부적으로 저장되어 있던 `nextPageParam`을 `queryFn`의 매개변수로 넘겨준다.**

  - `pages`와 `pageParams`를 갖는 캐시 데이터

    - `useQuery`에서는 `queryFn`의 반환값이 캐시 데이터로 등록된다.

    - `useInfiniteQuery`에서는 **`queryFn`의 반환값은 `pages` 배열의 요소**로 추가되고, **매개변수로 받았던 `pageParam`은 `pageParams` 배열의 요소**로 추가된다.

  - `useInfiniteQuery` 사용 시 주의사항

    - 훅 내부적인 동작 원리로 인해 **예상보다 잦은 리렌더링**이 발생할 수 있다.

    - 연산량이 많은 코드가 있는 경우, `useMemo`와 같은 **메모이제이션 적용**을 고려해야 한다.

    - **리렌더링이 발생한다고 해서 실제 브라우저 렌더링이 발생하는 것은 아니다.**

- Infinite Query 더 알아보기

  - 기존 데이터 집합에 추가로 **더 많은 데이터를 로드**하거나 **무한 스크롤** 할 수 있는 목록을 렌더링하는 것은 매우 일반적인 UI 패턴이다.

  - TanStack Query는 이러한 유형의 목록을 쿼리하기 위해 `useInfiniteQuery`라는 유용한 버전의 `useQuery`를 지원한다.

  - `useInfiniteQuery`를 사용하면 몇 가지 다른 점을 발견할 수 있다.

    - `data`는 이제 무한 쿼리 데이터를 포함하는 객체이다.

    - **가져온 페이지를 포함하는 `data.pages` 배열**이 있다.

    - **페이지를 불러오는 데 사용된 페이지 매개변수가 포함된 `data.pageParams` 배열**이 있다.

    - 이제 `fetchNextPage` 및 `fetchPreviousPage` 함수를 사용할 수 있다. 이때, **`fetchNextPage`는 필수**이다.

    - 이제 **초기 페이지 매개변수를 지정**하기 위해 **`initialPageParam`** 옵션을 사용할 수 있다. (필수)

    - **로드할 데이터가 더 있는지 여부**와 **가져올 정보를 결정**하는 데 **`getNextPageParam` 및 `getPreviousPageParam`** 옵션을 사용할 수 있다. 이 정보는 **`queryFn`에서 추가 매개변수로 제공**된다.

    - 이제 `hasNextPage` 값을 사용할 수 있으며, `getNextPageParam`이 `null` 또는 `undefined`가 아닌 값을 반환하는 경우 `true`로 설정된다.

    - 이제 `hasPreviousPage` 값을 사용할 수 있으며, `getPreviousPageParam`이 `null` 또는 `undefined`가 아닌 값을 반환하는 경우 `true`로 설정된다.

    - **백그라운드 새로고침 상태**와 **추가 로드 상태**를 구분하기 위해 **`isFetchingNextPage` 및 `isFetchingPreviousPage`** 값을 사용할 수 있다.

# 2. Zustand

## 1. Zustand의 등장 배경

- 상태 관리의 중요성

  - 상태(state)는 리액트 애플리케이션에서 데이터와 UI의 현재 상태를 나타낸다.

  - 상태가 변경되면 UI도 업데이트된다.

  - 상태 관리는 모든 리액트 애플리케이션에서 매우 중요하다. 작은 규모의 애플리케이션에서는 상태 관리가 간단하지만, **애플리케이션이 커질수록 상태 관리는 점점 더 복잡해진다.**

- Zustand의 필요성

  - 기존의 상태 관리 라이브러리인 Redux는 제공하는 기능과 연계된 미들웨어 등 매우 강력한 퍼포먼스를 자랑하지만, 설정과 사용법이 복잡했다.

  - **Zustand**는 상태 관리 본연의 기능에 집중하여 **복잡성을 줄이고, 보다 간단하고 직관적인 상태 관리 기능을 제공**한다.

  - 공식 문서에서는 Zustand를 다음과 같이 소개한다.

    > **단순화된 Flux 패턴**을 사용하는 **작고(small) 빠르고(fast) 확장 가능한(scalable)** 상태 관리 솔루션이며, **훅을 기반으로 하는 간편한 API**가 존재한다.

  - Zustand는 독일어로 "상태"를 의미한다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F0452cd01-16f6-497f-9033-fb7f8ba24298%2FUntitled.png?table=block&id=e4883fa8-73f2-40c4-8138-011d8b0421c1&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=500&userId=&cache=v2)

## 2. Zustand의 주요 개념

- 특징

  - **간결함**

    - 매우 간단한 API를 제공하기 때문에 학습 곡선이 완만하다.

    - 매우 적은 설정 코드 및 적용 코드를 이용하여 상태 관리 기능을 구현할 수 있다.

  - **성능 최적화**

    - 불필요한 리렌더링을 방지하는 등 성능 최적화가 잘 되어 있다.

    - 상태가 변경될 때, **해당 상태를 구독하고(subscribe) 있는 컴포넌트만 리렌더링**한다.

      > "구독"은 **상태의 변경을 감지**하고, **해당 변경에 반응하는 컴포넌트만 업데이트**하는 메커니즘을 의미한다.

    - 상태의 일부가 변경되었을 때 그 상태를 사용하는 컴포넌트만 업데이트되므로, **애플리케이션 전체가 리렌더링되지 않는다.**

    - 이를 통해 **성능을 최적화**하고, **리렌더링으로 인한 성능 저하를 방지**할 수 있다.

  - **React와의 통합**

    - React의 훅과 완벽하게 통합된다.

    - Zustand는 React의 `useState`, `useEffect`와 같은 기본 훅을 사용하는 것처럼 간편하게 사용할 수 있다.

      ```jsx
      const bears = useBearsStore((state) => state.bears);
      ```

    - 상태를 정의하고 이를 React 컴포넌트에서 쉽게 사용할 수 있어, 기존 React 개발 경험을 그대로 활용할 수 있다.

  - **높은 점유율**

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F75a86a11-3e72-46a9-b854-64f6b94a265a%2FUntitled.png?table=block&id=cdd349b9-ec27-448c-b88b-6d67990ab494&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1500&userId=&cache=v2)

- Zustand 설치

  ```
  yarn add zustand
  ```

- 기본 사용법

  - `bearsStore.js` 파일

    ```javascript
    // src/zustand/bearsStore.js

    import { create } from "zustand";

    const useBearsStore = create((set) => ({
      bears: 0,
      increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
      removeAllBears: () => set({ bears: 0 }),
    }));

    export default useBearsStore;
    ```

    - zustand 패키지에서 `create()` 함수를 가져온다. `create()` 함수는 **Zustand 스토어를 생성**하는 함수이다.

    - `create()` 함수를 호출하여 `useBearsStore`라는 상태 관리 스토어를 생성한다.

    - `create()` 함수의 인자로는 **상태를 변경하는 `set()` 함수**를 받는다. 이 함수를 이용하여 상태를 업데이트한다.

    - `useBearsStore` 스토어의 초기 상태는 `{ bears: 0 }`이다. `bears`라는 상태값은 현재 곰의 수를 나타낸다.

    - 스토어의 메서드

      - `increasePopulation`

        - **곰의 수를 증가시키는 메서드**

        - 이 메서드는 **현재 상태를 가져와서 `bears` 값을 1 증가시킨 후, 새로운 상태를 설정**한다.

        - `set()` 함수를 사용하여 상태를 업데이트한다. 이전 상태를 받아와서 `bears` 값을 1 증가시킨 객체를 반환한다.

      - `removeAllBears`

        - **모든 곰을 제거하는 메서드**

        - 이 메서드는 **`bears` 값을 0으로 설정**하여 모든 곰을 제거한다.

        - `set()` 함수를 사용하여 `{ bears: 0 }` 객체를 반환하여 상태를 초기화한다.

  - `App.jsx` 파일

    ```jsx
    // src/App.jsx

    import useBearsStore from "./zustand/bearsStore";

    function App() {
      const bears = useBearsStore((state) => state.bears);
      const increasePopulation = useBearsStore(
        (state) => state.increasePopulation
      );
      return (
        <div>
          <h1>{bears} around here...</h1>
          <button onClick={increasePopulation}>one up</button>
        </div>
      );
    }

    export default App;
    ```

    - `useBearsStore` 훅을 사용하여 상태 및 상태 업데이트 함수를 가져온다.

    - **`bears`는 현재 곰의 수를 나타내는 상태**이다. `useBearsStore`의 콜백 함수 `(state) => state.bears`를 통해 상태값을 읽어온다.

    - **`increasePopulation`은 곰의 수를 증가시키는 함수**이다. `useBearsStore`의 콜백 함수 `(state) => state.increasePopulation`을 통해 이 함수를 가져온다.

    - h1 태그 안의 `{bears}`를 통해 화면에 현재 곰의 수를 표시한다.

    - 버튼을 클릭하면 `increasePopulation` 함수가 호출되어 곰의 수를 1 증가시킨다.

## 3. Zustand와 Redux Toolkit 비교

- 설정 및 사용법 비교

  - **Zustand** : **매우 간단한 설정과 사용법**을 제공한다. **상태를 정의하고 사용하는 과정이 직관적**이다.

    ```jsx
    import { create } from "zustand";

    const useStore = create((set) => ({
      bears: 0,
      increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
    }));
    ```

  - **Redux Toolkit** : **보다 구조화된 방법**을 제공하지만, **설정이 다소 복잡**할 수 있다. **보일러 플레이트**가 너무 많다 보니 상태 하나하나를 관리하고자 해도 추가/설정해야 하는 것이 상당하다.

    ```jsx
    import { configureStore, createSlice } from "@reduxjs/toolkit";

    const slice = createSlice({
      name: "counter",
      initialState: { value: 0 },
      reducers: {
        increment: (state) => {
          state.value += 1;
        },
      },
    });

    const store = configureStore({ reducer: slice.reducer });
    ```

- 장단점 비교

  | 사용 도구         | 장점                                                            | 단점                                   |
  | ----------------- | --------------------------------------------------------------- | -------------------------------------- |
  | **Zustand**       | 간단하고 빠르며, 설정이 매우 쉽다.                              | 상태가 커지면 관리가 어려울 수 있다.   |
  | **Redux Toolkit** | 구조화된 방법을 통해 대규모 애플리케이션에서도 관리가 용이하다. | 설정이 복잡하고, 학습 곡선이 가파르다. |

## 4. 예시 코드

- 기본 예제

  - 상태 정의

    ```javascript
    // src/zustand/todosStore.js

    import { create } from "zustand";

    const useTodosStore = create((set) => ({
      todos: [],
      addTodo: (todo) => set((state) => ({ todos: [...state.todos, todo] })),
      removeTodo: (index) =>
        set((state) => ({
          todos: state.todos.filter((_, idx) => idx != index),
        })),
    }));

    export default useTodosStore;
    ```

  - 상태 사용

    ```jsx
    // src/App.jsx

    import React, { useState } from "react";
    import useTodosStore from "./zustand/todosStore";

    function App() {
      const todos = useTodosStore((state) => state.todos);
      const addTodo = useTodosStore((state) => state.addTodo);
      const removeTodo = useTodosStore((state) => state.removeTodo);
      const [input, setInput] = useState("");

      return (
        <div>
          <h1>Todo List</h1>
          <input value={input} onChange={(e) => setInput(e.target.value)} />
          <button
            onClick={() => {
              addTodo(input);
              setInput("");
            }}
          >
            Add Todo
          </button>
          <ul>
            {todos.map((todo, index) => (
              <li key={index}>
                {todo}{" "}
                <button onClick={() => removeTodo(index)}>Remove Todo</button>
              </li>
            ))}
          </ul>
        </div>
      );
    }

    export default App;
    ```

- Zustand와 Immer의 결합

  - 직접 중첩된 상태를 업데이트했을 때의 문제점

    - Zustand의 간편한 상태 업데이트 방식은 **깊은 중첩 구조를 가지는 상태**를 업데이트할 때 문제가 발생할 수 있다.

    - 배열이나 객체의 중첩된 상태를 업데이트할 때 **불변성을 유지하지 않으면 상태 반영이 제대로 이루어지지 않아 예상치 못한 오류가 발생**할 수 있다.

      - mutable vs. immutable

        - mutable 방법: 원본 데이터를 직접 수정하여 변경된 데이터를 반환한다. 이 방법은 간단하지만, 상태 변화 추적이 어려워져 버그 발생 가능성이 높다.

        - immutable 방법: 원본 데이터를 변경하지 않고, 수정된 새로운 데이터를 반환한다. 이를 통해 불변성을 유지하며, 상태 관리가 쉬워지고 예측 가능한 코드 작성을 돕는다.

        | 특징                     | mutable 방법 | immutable 방법             |
        | ------------------------ | ------------ | -------------------------- |
        | 배열 맨 뒤에 요소 추가   | `push()`     | `concat()`                 |
        | 배열 맨 뒤에서 요소 제거 | `pop()`      | `slice()`                  |
        | 배열 맨 앞에 요소 추가   | `unshift()`  | `[newItem, ...arr]`        |
        | 배열 맨 앞에서 요소 제거 | `shift()`    | `slice(1)`                 |
        | 배열의 요소 변경         | `splice()`   | `slice() + concat()`       |
        | 배열 정렬                | `sort()`     | `Array.from() + sort()`    |
        | 배열 반전                | `reverse()`  | `slice().reverse()`        |
        | 배열 요소 1개 이상 제거  | `splice()`   | `filter()`                 |
        | 객체 속성 추가           | 직접 할당    | `Object.assign()`          |
        | 객체 속성 제거           | `delete()`   | `Object.keys() + reduce()` |
        | 객체 속성 변경           | 직접 할당    | `Object.assign()`          |
        | 문자열 병합              | 직접 할당    | `concat()`                 |

        ```javascript
        // src/zustand/todosStore.js

        import { create } from "zustand";

        const useTodosStore = create((set) => ({
          todos: [],
          addTodo: (text) =>
            set((state) => {
              // 불변성을 어기는 예시: 직접 배열을 수정
              state.todos.push({ id: Date.now(), text, completed: false });
              return state;
            }),
          toggleTodo: (id) =>
            set((state) => {
              // 불변성을 어기는 예시: 직접 객체를 수정
              const todo = state.todos.find((todo) => todo.id === id);
              if (todo) todo.completed = !todo.completed;
              return state;
            }),
        }));

        export default useTodosStore;
        ```

        ```jsx
        // src/App.jsx

        import useTodosStore from "./zustand/todosStore";

        function App() {
          const { todos, addTodo, toggleTodo } = useTodosStore();

          return (
            <div>
              <ul>
                {todos.map((todo) => (
                  <li key={todo.id}>
                    <span
                      style={{
                        textDecoration: todo.completed
                          ? "line-through"
                          : "none",
                      }}
                      onClick={() => toggleTodo(todo.id)}
                    >
                      {todo.text}
                    </span>
                  </li>
                ))}
              </ul>
              <button
                onClick={() =>
                  addTodo(prompt("새로운 todolist를 입력해주세요."))
                }
              >
                Add Todo
              </button>
            </div>
          );
        }

        export default App;
        ```

        - 리스트가 추가되거나 수정되더라도 다른 요소에 의해 리렌더링이 일어나지 않는 한, UI에 반영이 되지 않는다.

  - immer를 이용해 해결하는 경우

    - immer란?

      - Immer는 자바스크립트에서 **상태를 쉽게 변경할 수 있게 해주는 라이브러리**이다.

      - **원본 데이터를 변경하지 않고도 마치 직접 수정하는 것처럼 코드를 작성**할 수 있으며, Immer가 **자동으로 불변성을 유지한 새 상태를 만들어준다.**

      - 우리가 위에서 겪은 문제를 해결해 줄 키를 가지고 있는 라이브러리이다.

    - immer 사용 방법

      - 먼저, immer 라이브러리를 설치해 준다.

        ```
        yarn add immer
        ```

      - `todosStore.js` 파일을 다음과 같이 수정한다.

        ```javascript
        // src/zustand/todosStore.js

        import { create } from "zustand";
        import { immer } from "zustand/middleware/immer";

        const useTodosStore = create(
          immer((set) => ({
            todos: [
              {
                id: 1,
                title: "Learn Zustand",
                tasks: [{ id: 1, task: "Read documentation", done: false }],
              },
            ],
            addTask: (todoId, newTask) =>
              set((state) => {
                const todo = state.todos.find((todo) => todo.id === todoId);
                if (todo) todo.tasks.push(newTask); // 불변성 유지: immer가 자동으로 처리
              }),
            toggleTask: (todoId, taskId) =>
              set((state) => {
                const todo = state.todos.find((todo) => todo.id === todoId);
                if (todo) {
                  const task = todo.tasks.find((task) => task.id === taskId);
                  if (task) task.done = !task.done; // 불변성 유지: immer가 자동으로 처리
                }
              }),
          }))
        );

        export default useTodosStore;
        ```

- 기타 유용한 패턴

  - **선택적 상태 구독**

    - 상태의 특정 부분만 구독하여 성능을 최적화할 수 있다.

      ```jsx
      // src/App.jsx

      const todos = useTodosStore((state) => state.todos);
      const addTask = useTodosStore((state) => state.addTask);
      const toggleTask = useTodosStore((state) => state.toggleTask);
      ```

  - **미들웨어 사용**

    - 로깅, 퍼시스턴스 등을 사용하면 다양한 기능을 추가할 수 있다.

    - `persist`를 이용하면 새로고침을 하더라도 데이터가 남아있게 된다.

      ```javascript
      import { create } from "zustand";
      import { persist } from "zustand/middleware";
      import { immer } from "zustand/middleware/immer";

      const useTodosStore = create(
        persist(
          immer((set) => ({
            todos: [
              {
                id: 1,
                title: "Learn Zustand",
                tasks: [{ id: 1, task: "Read documentation", done: false }],
              },
            ],
            addTask: (todoId, newTask) =>
              set((state) => {
                const todo = state.todos.find((todo) => todo.id === todoId);
                if (todo) todo.tasks.push(newTask);
              }),
            toggleTask: (todoId, taskId) =>
              set((state) => {
                const todo = state.todos.find((todo) => todo.id === todoId);
                if (todo) {
                  const task = todo.tasks.find((task) => task.id === taskId);
                  if (task) task.done = !task.done;
                }
              }),
          })),
          {
            name: "todos-storage", // 저장소 이름 설정
            // getStorage: () => sessionStorage, // localStorage가 아닌 곳에 저장함
          }
        )
      );

      export default useTodosStore;
      ```

      - `persist` 미들웨어

        - **상태를 브라우저의 localStorage에 저장**(기본값)하여 페이지 새로고침 후에도 상태를 유지한다.

        - `name: "todos-storage"`는 저장소의 키 이름을 정의한다.

        - 주석 처리된 `getStorage: () => sessionStorage`는 상태를 sessionStorage에 저장하도록 설정한다.

      - 이렇게 하면, 새로고침을 하더라도 localStorage에서 데이터를 관리하기 때문에 지속성을 유지할 수 있다.

        ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F90a4bb68-b5f4-4ac9-b324-716589377afe%2FUntitled.png?table=block&id=56bb27e1-ca3f-43ea-b5c9-f414d0d5496a&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=900&userId=&cache=v2)

## 5. Zustand의 장점과 단점

- 장점

  - **간편한 사용** : 간단한 API와 직관적인 사용법을 제공한다.

  - **성능 최적화** : 불필요한 리렌더링을 방지한다.

  - **React와의 완벽한 통합** : React의 훅과 잘 통합되어 있다.

  - **미들웨어 지원** : 로깅, 퍼시스턴스 등 다양한 미들웨어를 사용할 수 있다.

  - **유연성** : 필요한 부분만 선택적으로 사용할 수 있다.

  - **커뮤니티와 자료** : 예전에는 다른 대형 라이브러리에 비해 상대적으로 커뮤니티와 자료가 부족했지만, 꾸준한 인기 급상승으로 많은 자료가 확보되고 있다.

- 단점

  - **상태가 커지면 관리 어려움** : 상태가 많아지면 관리가 복잡해질 수 있다.

- Redux Toolkit과의 비교

  - 설정과 사용법 : **Zustand**는 **설정과 사용이 간단**하며, **Redux Toolkit**은 **더 구조화된 방법**을 제공한다.

  - 성능 : 두 라이브러리 모두 **성능 최적화**가 잘 되어 있지만, **Zustand**는 **불필요한 리렌더링을 방지**하는 데 더 초점을 맞춘다.

  - 유연성 : **Zustand**는 **필요한 부분만 선택적으로 사용**할 수 있지만, **Redux Toolkit**은 보다 **강력한 구조화된 방법**을 제공한다.

  - 커뮤니티와 자료 : Redux Toolkit은 대형 커뮤니티와 풍부한 자료를 가지고 있으며, Zustand는 상대적으로 부족할 수 있지만 현재는 많은 인기에 힘입어 늘어나고 있다.

# 3. UX 향상 - throttling & debouncing

## 1. Throttling & Debouncing 소개

- **Throttling 기법**

  - **짧은 시간 간격으로 연속해서** 발생한 이벤트들을 일정시간 단위(delay)로 그룹화하여 **처음 또는 마지막 이벤트 핸들러만 호출**되도록 하는 기법

  - 주로 무한 스크롤에서 사용한다.

  - 이벤트의 반복 발생 시 처리 방법

    - **Leading Edge**

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F5ea444f4-3ab7-4436-ad68-c6baca9f49e0%2FUntitled.png?table=block&id=7c4370da-2311-42d9-9b1f-d7cd67bded5e&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=300&userId=&cache=v2)

      - 설명: **이벤트가 처음 발생할 때 핸들러가 실행**된다. 이후 주어진 시간 동안은 이벤트가 무시된다.

      - 예시: 사용자가 스크롤을 시작할 때 처음에만 API 호출이 이루어지고, 일정 시간 동안 추가 호출이 무시된다.

    - **Trailing Edge**

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F13e41fbd-cf07-4b19-ae9e-28fd9d5d8012%2FUntitled.png?table=block&id=f78543a9-9577-438a-b3c1-62771ed71d2b&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=300&userId=&cache=v2)

      - 설명: 이벤트가 반복적으로 실행될 때, **주어진 시간(delay)이 지나면 마지막 이벤트를 처리**한다.

      - 예시: Leading Edge와 비슷하지만 주어진 시간의 마지막 이벤트에 API 호출이 이루어진다.

    - **Leading & Trailing Edge**

      ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fae75e8ed-b0df-47a6-921d-c46354dcd0c5%2FUntitled.png?table=block&id=66210336-4e2a-478f-9e5a-2aa1e9b2d4da&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=300&userId=&cache=v2)

      - 설명: 주어진 시간에 대해 **이벤트가 처음 발생할 때 핸들러가 실행**되고, **주어진 시간이 지나면 마지막 이벤트도 처리**한다.

      - 예시: 사용자가 버튼을 여러 번 클릭할 때 처음 클릭 시 바로 API 호출이 이루어지고, 주어진 시간의 마지막 이벤트에도 API 호출이 이루어진다.

- **Debouncing 기법**

  ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fb37f6e7a-7440-4648-b8b1-a113477556f4%2FUntitled.png?table=block&id=1be3c37e-f517-46b6-a5ee-77ba4304c85d&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=10000&userId=&cache=v2)

  - 짧은 시간 간격으로 연속해서 이벤트가 발생하면 이벤트 핸들러를 호출하지 않다가 **마지막 이벤트로부터 일정 시간(delay)이 경과한 후에 한 번만 호출**하도록 하는 기법

  - 서버에 대한 불필요한 API 호출을 줄이고, UI가 급격한 수의 이벤트를 처리하는 것을 방지하기 위해 사용한다.

  - 주로 입력값 실시간 검색, 화면 resize 이벤트 등에서 사용된다.

- **메모리 누수(Memory Leak)**

  - 개념: 필요하지 않은 메모리를 계속 점유하고 있는 현상

  - Throttling과 Debouncing에서 `setTimeout`을 자주 사용하기 때문에, 이 함수의 사용으로 인한 메모리 누수 가능성을 이해하는 것이 중요하다.

  - `setTimeout`이 메모리 누수를 유발할까?

    - 상황에 따라 메모리 누수를 일으킬 수도 있고 아닐 수도 있다.

    - **하나의 페이지에서 페이지 이동 없이 `setTimeout`을 동작시키고 타이머 함수가 종료될 때까지 기다린다면, 메모리 누수는 없다.**

    - 리액트로 만든 SPA 웹사이트는 페이지 이동 시 컴포넌트가 언마운트된다.

    - **페이지 이동 전에 `setTimeout`으로 인해 타이머가 동작 중인 상태에서 `clearTimeout`을 해주지 않고 페이지를 이동한다면, 컴포넌트는 언마운트 되었음에도 불구하고 타이머는 여전히 메모리를 차지하고 동작하고 있다.** 이 경우, **메모리 누수**가 발생한다.

## 2. 실습

- 직접 만들어보는 Throttling & Debouncing

  - `App` 컴포넌트 작성

    ```jsx
    // src/App.jsx

    import { BrowserRouter, Routes, Route } from "react-router-dom";
    import Home from "pages/Home";
    import Company from "pages/Company";

    function App() {
      return (
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<Home />} />
            <Route path="/company" element={<Company />} />
          </Routes>
        </BrowserRouter>
      );
    }

    export default App;
    ```

  - `Home` 컴포넌트(테스트를 위한 메인 컴포넌트) 작성

    ```jsx
    // src/pages/Home.jsx

    import { useEffect, useState } from "react";
    import { useNavigate } from "react-router-dom";

    export default function Home() {
      const navigate = useNavigate();
      let timerId = null;

      // Leading Edge Throttling
      const throttle = (delay) => {
        if (timerId) return; // timerId가 있으면 바로 함수 종료
        console.log(`API 요청 실행! ${delay}ms 동안 추가요청 안받음`);
        timerId = setTimeout(() => {
          console.log(`${delay}ms 지남! 추가요청 받음`);
          timerId = null;
        }, delay);
      };

      // Trailing Edge Debouncing
      const debounce = (delay) => {
        if (timerId) clearTimeout(timerId); // 할당되어 있는 timerId에 해당하는 타이머 제거
        timerId = setTimeout(() => {
          // timerId에 새로운 타이머 할당
          console.log(
            `마지막 요청으로부터 ${delay}ms 지났으므로 API 요청 실행!`
          );
          timerId = null;
        }, delay);
      };

      useEffect(() => {
        return () => {
          // 페이지 이동 시 실행
          if (timerId) clearTimeout(timerId); // 메모리 누수 방지
        };
      }, [timerId]);

      return (
        <div style={{ paddingLeft: 20, paddingRight: 20 }}>
          <h1>Button 이벤트 예제</h1>
          <button onClick={() => throttle(2000)}>쓰로틀링 버튼</button>
          <button onClick={() => debounce(2000)}>디바운싱 버튼</button>
          <div>
            <button onClick={() => navigate("/company")}>페이지 이동</button>
          </div>
        </div>
      );
    }
    ```

    - **Throttling 함수 (Leading Edge Throttling)**

      - Throttling은 특정 함수가 주기적으로 실행되는 것을 방지하는 기법으로, 이 함수는 주어진 시간 동안 함수가 여러 번 호출되는 것을 제한한다.

      - 이 함수의 목적은 **일정 시간 간격으로만 API 요청을 실행**하도록 하는 것이다.

      - `throttle()` 함수는 **호출 시점에서 일정 시간동안 추가 호출을 막는 기능**을 한다.

      - `timerId`가 이미 설정되어 있으면, **이전 요청이 아직 유효하다**는 의미이므로 함수는 즉시 종료된다.

      - `setTimeout`을 사용하여 일정 시간(`delay`)동안 추가 요청을 막고, 시간이 지나면 **`timerId`를 `null`로 설정하여 다음 요청을 받을 수 있게 한다.**

    - **Debouncing 함수 (Trailing Edge Debouncing)**

      - Debouncing은 특정 함수가 연속적으로 호출될 때 마지막 호출 이후 일정 시간동안 추가 호출을 막고, 일정 시간이 지나면 한 번만 실행되도록 하는 기법이다.

      - 이 함수는 **마지막 호출 이후 일정 시간이 지나야만 API 요청을 실행**하도록 한다.

      - `debounce()` 함수는 **연속적인 호출이 발생할 때 마지막 호출 이후 일정 시간동안 추가 호출을 막는 기능**을 한다.

      - `timerId`가 설정되어 있으면 기존 타이머를 제거하고 새로운 타이머를 설정하여 이전 요청을 취소하고 새로운 요청을 기다리게 한다.

        - 디바운싱 함수에서 기존 타이머를 제거하는 이유는, **연속된 호출이 발생했을 때 마지막 호출 이후 일정 시간(`delay`)이 지나기 전에 다시 호출될 경우, 이전 호출을 취소하고 새로운 타이머를 설정**하기 위해서이다.

        - 이렇게 함으로써 **연속된 호출이 발생해도 마지막 호출 이후 일정 시간 동안 대기한 후에 한 번만 실행**되도록 한다.

      - `setTimeout`을 사용하여 마지막 호출 이후 지정된 지연 시간(`delay`)이 지나면 **`timerId`를 `null`로 설정하여 다음 요청을 받을 수 있게 한다.**

    - **`useEffect` 훅**

      - 컴포넌트가 언마운트될 때(다른 페이지로 이동할 때) 실행된다.

      - 페이지 이동 시 `timerId`에 설정된 타이머가 있으면 이를 제거하여 메모리 누수를 방지한다.

      - `timerId`가 변경될 때마다 이 효과가 재실행된다.

  - `Company` 컴포넌트(`Home` 페이지 컴포넌트에서 다른 페이지로 갔을 때 어떤 동작을 하는지 보기 위한 다른 페이지 컴포넌트) 작성

    ```jsx
    // src/pages/Company.jsx

    import React from "react";

    export default function Company() {
      return <div>Test Page</div>;
    }
    ```

    - `Home.jsx` 파일에서 클린업 함수가 없었다면, `Company` 페이지 컴포넌트로 이동할 때 다음과 같은 문제들이 발생할 수 있다.

      - **메모리 누수: 타이머가 계속 동작**

        - `Home` 컴포넌트가 언마운트되더라도, 설정된 타이머(`setTImeout`)가 계속 동작하게 된다.

        - 이는 불필요한 메모리를 점유하게 되어 메모리 누수가 발생할 수 있다.

      - **불필요한 코드 실행: 타이머가 완료되면 코드 실행**

        - `Home` 컴포넌트가 언마운트된 이후에도 타이머가 만료되면 콜백 함수가 실행된다.

        - 이 경우, 이미 언마운트된 컴포넌트와 관련된 코드가 실행될 수 있으며, 이는 예상치 못한 동작을 초래할 수 있다.

      - **에러 발생 가능성: 상태 업데이트 시도**

        - 콜백 함수 내에서 상태를 업데이트하려고 시도할 경우, 컴포넌트가 이미 언마운트되었기 때문에 에러가 발생할 수 있다.

        - 예를 들어, `setState`를 호출하면 "Can't perform a React state update on an unmounted component"와 같은 경고 또는 에러가 발생할 수 있다.

- lodash 활용하기

  - lodash란?

    - **자바스크립트 유틸리티 라이브러리**로, 배열, 객체, 문자열 등의 데이터 조작을 쉽게 할 수 있는 다양한 함수들을 제공한다.

    - **성능 최적화**와 **코드 가독성**을 높이는 데 유용하다.

    - 특히, `throttle()`과 `debounce()`같은 함수도 포함되어 있어 편리하다.

  - lodash를 활용하여 Debouncing 기능 테스트 해보기

    - `Home.jsx` 파일을 다음과 같이 바꾼다.

      ```jsx
      import { useState, useCallback } from "react";
      import _ from "lodash";

      function Home() {
        const [searchText, setSearchText] = useState(""); // 디바운싱된 입력값을 저장하는 상태 변수
        const [inputText, setInputText] = useState(""); // 즉시 업데이트되는 입력값을 저장하는 상태 변수

        // 디바운싱 적용 함수
        const handleSearchText = _.debounce(
          (text) => setSearchText(text),
          2000
        );

        const handleChange = (e) => {
          setInputText(e.target.value); // 즉시 업데이트
          handleSearchText(e.target.value); // 디바운싱된 업데이트
        };

        return (
          <div style={{ paddingLeft: 20, paddingRight: 20 }}>
            <h1>디바운싱 예제</h1>
            <br />
            <input
              placeholder="입력값을 넣고 디바운싱 테스트를 해보세요."
              style={{ width: "300px" }}
              onChange={handleChange}
              type="text"
            />
            <p>Search Text: {searchText}</p>
            <p>Input Text: {inputText}</p>
          </div>
        );
      }

      export default Home;
      ```

      - 디바운싱 함수

        - lodash의 `debounce()` 함수를 사용하여 `handleSearchText()` 함수를 선언한다.

        - 이 함수는 **입력이 멈춘 후 2000ms(2초)가 지나면 `setSearchText`를 호출하여 `searchText`의 상태를 업데이트**한다.

        - 2000ms 내에 입력이 계속되면 기존의 타이머는 취소되고, 새로운 타이머가 설정된다.

      - 위 코드를 실행하면 다음과 같이 동작한다.

        ![alt text](https://file.notion.so/f/f/83c75a39-3aba-4ba4-a792-7aefe4b07895/005fd5ba-7e3d-4d1e-b3b5-1972c7c30d68/deboucing.gif?id=5911362e-8d4b-4ad8-966c-dc37b135e082&table=block&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&expirationTimestamp=1719806400000&signature=9dHAhSeYWtLtudoRRUwgoJ0jk_IcLwz3HJvTF3ntpAo)

        - input 필드에 입력한 값이 계속 일정 delay를 두고 한 글자씩 차례로 반영된다. -> 원하는 결과가 아님

        - 컴포넌트에서 리렌더링이 일어나면서 **`debounce()` 함수를 계속해서 생성**하기 때문이다.

        - **입력할 때마다 `debounce()` 함수가 새로 생성**되고, **새로 생성된 `debounce()` 함수는 새로운 타이머를 설정**하여, 결과적으로 **입력 필드에 값을 입력할 때마다 일정한 지연(delay)이 발생하면서 한 글자씩 순차적으로 반영**된다.

          - **컴포넌트가 처음 마운트되었을 때 `debounce()` 함수가 설정한 타이머는 리렌더링이 일어나도 여전히 유효하다.**

          - `debounce()` 타이머는 타이머가 설정된 시점에서 시작되어, 타이머가 만료되면 설정된 콜백 함수가 실행된다.

          - **컴포넌트가 리렌더링되면 새로운 `debounce()` 함수가 생성되더라도 기존 타이머는 영향을 받지 않는다.**

          - 새로운 타이머가 설정될 때마다 기존 타이머가 취소되지 않으면, 동일한 타이머 콜백 함수가 여러 번 실행될 수 있다.

          - 리액트 컴포넌트가 리렌더링되면, 컴포넌트 함수 내의 코드가 다시 실행되지만, 이때 생성된 **클로저나 타이머 등은 이전 렌더링과 독립적으로 작동**한다.

            > - 자바스크립트에서 타이머 함수(`setTimeout`, `setInterval`)는 **비동기적으로 동작**한다.
            > - 이 타이머 함수는 실행되는 시점에 설정된 콜백 함수와 그 함수가 접근할 수 있는 변수(클로저)를 함께 기억한다.
            > - 따라서, **타이머가 설정되면 해당 타이머는 설정 시점의 환경을 기억**하고, **리액트 컴포넌트의 리렌더링과 상관없이 독립적으로 동작**한다.
            > - 리액트 컴포넌트가 리렌더링되면 컴포넌트 함수가 다시 호출되어 새로운 렌더링 결과를 생성한다.
            > - 그러나, 리렌더링이 일어난다고 해서 이전에 설정된 타이머가 자동으로 취소되거나 무효화되지는 않는다.
            > - **설정된 타이머는 설정된 시점의 클로저와 함께 동작**하며, **리렌더링이 일어나더라도 타이머의 동작은 계속 유지**된다.

        - 이를 방지하기 위해서, **`useCallback`으로 함수를 메모이제이션**하면 문제가 해결된다.

          ```jsx
          const handleSearchText = useCallback(
            _.debounce((text) => setSearchText(text), 2000),
            []
          );
          ```

          - `useCallback` 훅을 사용하여 `handleSearchText()` 함수가 컴포넌트 리렌더링 시에도 재생성되지 않도록 한다.

          - 빈 의존성 배열을 사용하여, 컴포넌트가 마운트될 때 한 번만 함수가 생성된다.

          - 이제 `handleSearchText()` 함수는 컴포넌트가 리렌더링되더라도 새롭게 생성되지 않는다.

          - **디바운스 타이머가 일관되게 유지**되어 입력값이 연속적으로 업데이트되지 않고, **사용자가 입력을 멈춘 후 2000ms가 지나야 상태가 업데이트**된다.

            ![alt text](https://file.notion.so/f/f/83c75a39-3aba-4ba4-a792-7aefe4b07895/a9b156d7-35e3-42b9-a641-af1c714d7916/debo.gif?id=339cba33-0ec5-462b-be72-d8d632aef577&table=block&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&expirationTimestamp=1719806400000&signature=B4bFr8X_p5MhMu9S8ws6fIkQWbC9bmUEfkFuP4jdeWo)

<br>
<hr>
<br>
개인 프로젝트 관련 타입스크립트 문법 정리 부분
<br>
<br>

# 4. 인덱스 시그니처 (Index Signature)

- 타입스크립트에서 인덱스 시그니처는 **객체의 속성들을 동적으로 정의**할 수 있게 해주는 기능이다.

- 객체가 일반적으로는 정적으로 정의된 속성들만 가지지만, 경우에 따라 동적으로 속성을 추가하고 접근할 필요가 있다.

- 이때 인덱스 시그니처를 사용하여 객체의 속성에 접근하는 방법을 확장할 수 있다.

- 인덱스 시그니처는 다음과 같은 문법으로 정의된다.

  ```typescript
  type TypeName = {
    [index: typeOfIndex]: typeOfValue;
  };
  ```

  - `index` : **키(key)의 타입을 나타내는 이름**이다. 일반적으로 문자열 또는 숫자 타입을 사용한다.

  - `typeOfIndex` : **키(key)의 타입**을 나타내는 TypeScript 타입이다. 예를 들어, `string`, `number`, `symbol` 등이 가능하다.

  - `typeOfValue` : 인덱스로 접근할 때 반환되는 **값(value)의 타입**을 나타낸다.

- 예제

  ```typescript
  // 문자열을 키로 갖고, 숫자를 값으로 갖는 객체 타입 정의
  type StringToNumberMap = {
    [key: string]: number;
  };

  const ageMap: StringToNumberMap = {
    Alice: 30,
    Bob: 25,
    Charlie: 35,
  };

  console.log(ageMap["Alice"]); // 30
  console.log(ageMap["Bob"]); // 25
  ```

  - `StringToNumberMap` 타입은 문자열을 키로 하고 숫자를 값으로 갖는 객체를 정의한다.

  - `ageMap` 객체는 이 타입을 따르며, 각 이름에 해당하는 나이를 저장하고 있다.

- 인덱스 시그니처를 사용하면 객체에 정적으로 정의된 속성 외에도 동적으로 속성을 추가하고 접근할 수 있어 매우 **유연한 객체 모델링**을 가능하게 한다.

- 인덱스 시그니처를 사용할 때 주의할 점

  - **한 객체에는 하나의 인덱스 시그니처**만 있을 수 있다.

  - 인덱스 시그니처의 **키(key)는 `string`, `number`, `symbol` 타입 중 하나**여야 한다.

  - 인덱스 시그니처를 사용하면 **타입 시스템에서 해당 인덱스의 값의 타입을 보장하지 않으므로**, 사용 시 주의가 필요하다.
