## 0704_Day50

리액트 스탠다드 11일차 강의 내용 정리

## 1. `useQuery`와 `useMutation` 기본 로직 다시 보기

- TanStack Query 적용 전/후 비교

  - 적용 전: `useState`, `useEffect` 사용 (1_beforeTanstack 브랜치)

    <details>
    <summary>Home.jsx</summary>

    ```jsx
    // src/pages/Home.jsx

    import { useState, useEffect } from "react";
    import { todoApi } from "../api/todos";
    import TodoForm from "../components/TodoForm";
    import TodoList from "../components/TodoList";

    export default function Home() {
      const [isLoading, setIsLoading] = useState(true);
      // 데이터를 로딩 중인지 여부를 나타내는 상태로, 초기값은 true이다.
      const [error, setError] = useState(null);
      // API 호출 중 발생한 오류를 저장하는 상태로, 초기값은 null이다.
      const [data, setData] = useState([]);
      // 서버에서 가져온 투두 항목들을 저장하는 상태로, 초기값은 빈 배열이다.

      // fetchData() 함수는 서버로부터 데이터를 비동기적으로 가져오는 기능을 한다.
      const fetchData = async () => {
        try {
          const response = await todoApi.get("/todos?_sort=-createdAt");
          // todoApi.get()을 통해 생성일자 기준 내림차순으로 정렬하는 쿼리와 함께 GET 요청을 보낸다.
          setData(response.data);
          // 데이터를 성공적으로 가져오면 setData()를 통해 data 상태를 업데이트한다.
        } catch (err) {
          setError(err);
          // 오류가 발생하면 setError()를 통해 error 상태를 업데이트한다.
        } finally {
          setIsLoading(false);
          // setIsLoading()을 통해 isLoading을 false로 설정하여 로딩이 완료되었음을 알린다.
        }
      };

      useEffect(() => {
        fetchData();
      }, []);
      // 컴포넌트가 마운트될 때 한 번만 fetchData() 함수를 호출한다.

      if (isLoading) {
        return <div style={{ fontSize: 36 }}>로딩중...</div>;
      }

      if (error) {
        console.error(error);
        return (
          <div style={{ fontSize: 24 }}>
            에러가 발생했습니다: {error.message}
          </div>
        );
      }

      return (
        <>
          <h2>서버통신 투두리스트 by useState</h2>
          <TodoForm fetchData={fetchData} />
          <TodoList todos={data} />
        </>
      );
      // 데이터를 정상적으로 가져온 경우, TodoForm과 TodoList 컴포넌트를 렌더링한다.
      // TodoForm은 fetchData() 함수를 prop으로 받아 새로운 투두 항목이 추가되었을 때 데이터를 다시 가져오도록 한다.
      // TodoList는 data를 prop으로 받아 투두 항목들을 표시한다.
    }
    ```

    </details>

    <details>
    <summary>TodoForm.jsx</summary>

    ```jsx
    // src/components/TodoForm.jsx

    import { useState } from "react";
    import { todoApi } from "../api/todos";

    export default function TodoForm({ fetchData }) {
      // 투두 항목을 새로고침하는 함수인 fetchData() 함수를 prop으로 받는다.
      const [title, setTitle] = useState("");
      // 제목 입력 필드의 값을 관리하는 상태로, 초기값은 빈 문자열이다.
      const [contents, setContents] = useState("");
      // 내용 입력 필드의 값을 관리하는 상태로, 초기값은 빈 문자열이다.

      // handleAddTodo() 함수는 폼 제출 이벤트를 처리한다.
      const handleAddTodo = async (e) => {
        e.preventDefault(); // 폼 제출 시 리로드를 방지한다.
        setTitle(""); // 폼 제출 후 제목 입력 필드를 초기화한다.
        setContents(""); // 폼 제출 후 내용 입력 필드를 초기화한다.
        await todoApi.post("/todos", {
          id: Date.now().toString(),
          title,
          contents,
          isCompleted: false,
          createdAt: Date.now(),
        });
        // 서버에 새로운 투두 항목을 POST 요청으로 전송한다.

        await fetchData();
        // 서버에서 투두 항목을 다시 가져와 리스트를 업데이트한다.
      };

      return (
        <form onSubmit={handleAddTodo}>
          <label htmlFor="title">제목:</label>
          <input
            type="text"
            id="title"
            name="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
          />
          <label htmlFor="contents">내용:</label>
          <input
            id="contents"
            name="contents"
            value={contents}
            onChange={(e) => setContents(e.target.value)}
            required
          />
          {/* required 속성은 사용자가 해당 필드를 반드시 채워야 한다는 것을 나타낸다. */}
          {/* 이 속성을 사용하면 폼이 제출될 때 해당 필드가 비어 있으면 브라우저가 자동으로 사용자에게 경고 메시지를 표시하고, 폼 제출을 막는다. */}
          <button type="submit">추가하기</button>
        </form>
      );
    }
    ```

    </details>

    <details>
    <summary>TodoList.jsx</summary>

    ```jsx
    // src/components/TodoList.jsx

    import { useNavigate } from "react-router-dom";

    export default function TodoList({ todos }) {
      // 투두 항목들의 배열인 todos를 prop으로 받는다.
      const navigate = useNavigate();

      return (
        <ul style={{ listStyle: "none", width: 250 }}>
          {todos.map((todo) => (
            <li
              key={todo.id}
              style={{
                border: "1px solid black",
                padding: "10px",
                marginBottom: "10px",
              }}
            >
              <h3>{todo.title}</h3>
              <button onClick={() => navigate(`/detail/${todo.id}`)}>
                내용보기
              </button>
            </li>
          ))}
        </ul>
      );
    }
    ```

    </details>

    <details>
    <summary>Detail.jsx</summary>

    ```jsx
    // src/pages/Detail.jsx

    import { useEffect } from "react";
    import { useState } from "react";
    import { useNavigate, useParams } from "react-router-dom";
    import { todoApi } from "../api/todos";

    export default function Detail() {
      const { id } = useParams(); // URL 파라미터에서 id를 가져온다.
      const navigate = useNavigate(); // 페이지 이동을 위한 함수를 가져온다.

      const [isLoading, setIsLoading] = useState(true);
      // 데이터를 로딩 중인지 여부를 나타내는 상태로, 초기값은 true이다.
      const [error, setError] = useState(null);
      // API 호출 중 발생한 오류를 저장하는 상태로, 초기값은 null이다.
      const [data, setData] = useState([]);
      // 서버에서 가져온 투두 항목들을 저장하는 상태로, 초기값은 빈 배열이다.

      // 컴포넌트가 마운트될 때 데이터를 가져오는 비동기 함수를 실행한다.
      useEffect(() => {
        // 특정 투두 항목을 가져오는 fetchDetail() 함수를 정의한다.
        const fetchDetail = async () => {
          try {
            const response = await todoApi(`/todos/${id}`);
            // 서버에서 해당 id에 해당하는 투두 항목 데이터를 가져온다.
            setData(response.data);
            // 데이터를 성공적으로 가져오면 setData()를 통해 data 상태를 업데이트한다.
          } catch (err) {
            setError(err);
            // 오류가 발생하면 setError()를 통해 error 상태를 업데이트한다.
          } finally {
            setIsLoading(false);
            // setIsLoading()을 통해 isLoading을 false로 설정하여 로딩이 완료되었음을 알린다.
          }
        };

        fetchDetail(); // fetchDetail() 함수를 호출하여 데이터를 가져온다.
      }, [id]); // id가 변경될 때마다 useEffect가 실행되도록 설정한다.

      if (isLoading) return <div style={{ fontSize: 36 }}>로딩중...</div>;

      if (error) {
        console.error(error);
        return (
          <div style={{ fontSize: 24 }}>
            에러가 발생했습니다: {error.message}
          </div>
        );
      }

      return (
        <div>
          <button onClick={() => navigate("/")}>홈으로 이동</button>
          <p>제목: {data.title}</p>
          <p>내용: {data.contents}</p>
          <p>작성일자: {new Date(data.createdAt).toDateString()}</p>
        </div>
      );
      // 데이터를 성공적으로 가져오면 투두 항목의 세부 정보를 표시한다.
    }
    ```

    </details>

  - 적용 후: `useState`, `useEffect` 제거 (2_tanstack 브랜치)

    <details>
    <summary>Home.jsx</summary>

    ```jsx
    // src/pages/Home.jsx

    import TodoForm from "../components/TodoForm";
    import TodoList from "../components/TodoList";

    export default function Home() {
      return (
        <>
          <h2>서버통신 투두리스트</h2>
          <TodoForm />
          <TodoList />
        </>
      );
    }
    ```

    </details>

    <details>
    <summary>TodoForm.jsx</summary>

    ```jsx
    // src/components/TodoForm.jsx

    import { useMutation, useQueryClient } from "@tanstack/react-query";
    import { useState } from "react";
    import { todoApi } from "../api/todos";

    export default function TodoForm() {
      const [title, setTitle] = useState("");
      // 제목 입력 필드의 값을 관리하는 상태로, 초기값은 빈 문자열이다.
      const [contents, setContents] = useState("");
      // 내용 입력 필드의 값을 관리하는 상태로, 초기값은 빈 문자열이다.

      const queryClient = useQueryClient(); // 쿼리 클라이언트 객체를 가져온다.

      // useMutation 훅을 사용하여 투두 추가에 대한 mutate 함수를 생성한다.
      const addMutation = useMutation({
        mutationFn: (newTodo) => todoApi.post("/todos", newTodo),
        // mutationFn은 실제로 데이터를 변경하는 함수이다.
        // 여기서는 새로운 투두를 서버에 POST 요청하여 추가한다.
        onSuccess: () => {
          queryClient.invalidateQueries(["todos"]);
        },
        // onSuccess는 mutate 함수가 성공적으로 실행된 후에 실행될 콜백 함수이다.
        // 여기서는 todos 쿼리를 무효화하여 데이터를 다시 불러오도록 한다.
      });

      // handleAddTodo() 함수는 폼 제출 이벤트를 처리한다.
      const handleAddTodo = async (e) => {
        e.preventDefault(); // 폼 제출 시 리로드를 방지한다.
        setTitle(""); // 폼 제출 후 제목 입력 필드를 초기화한다.
        setContents(""); // 폼 제출 후 내용 입력 필드를 초기화한다.

        // mutate 함수를 호출하여 새로운 투두 항목을 추가한다.
        addMutation.mutate({
          id: Date.now().toString(),
          title,
          contents,
          isCompleted: false,
          createdAt: Date.now(),
        });
      };

      return (
        <form onSubmit={handleAddTodo}>
          <label htmlFor="title">제목:</label>
          <input
            type="text"
            id="title"
            name="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
          />
          <label htmlFor="contents">내용:</label>
          <input
            id="contents"
            name="contents"
            value={contents}
            onChange={(e) => setContents(e.target.value)}
            required
          />
          <button type="submit">추가하기</button>
        </form>
      );
    }
    ```

    </details>

    <details>
    <summary>TodoList.jsx</summary>

    ```jsx
    // src/components/TodoList.jsx

    import { useQuery } from "@tanstack/react-query";
    import { useNavigate } from "react-router-dom";
    import { todoApi } from "../api/todos";

    export default function TodoList() {
      const navigate = useNavigate();

      // useQuery 훅을 사용하여 todos 쿼리를 실행한다.
      const {
        isPending, // 데이터 요청이 진행 중인지 여부
        error, // 데이터 요청 중 발생한 오류
        data: todos, // 성공적으로 받아온 투두 데이터
      } = useQuery({
        queryKey: ["todos"], // 쿼리 키로 todos를 사용한다.
        queryFn: async () => {
          console.log("queryFn in Home");
          const response = await todoApi.get("/todos?_sort=-createdAt");
          // todoApi를 사용하여 서버에서 투두 데이터를 가져온다.
          return response.data; // 가져온 데이터를 반환한다.
        },
      });

      if (isPending) {
        return <div style={{ fontSize: 36 }}>로딩중...</div>;
      }

      if (error) {
        console.error(error);
        return (
          <div style={{ fontSize: 24 }}>
            에러가 발생했습니다: {error.message}
          </div>
        );
      }
      return (
        <ul style={{ listStyle: "none", width: 250 }}>
          {todos.map((todo) => (
            <li
              key={todo.id}
              style={{
                border: "1px solid black",
                padding: "10px",
                marginBottom: "10px",
              }}
            >
              <h3>{todo.title}</h3>
              <button onClick={() => navigate(`/detail/${todo.id}`)}>
                내용보기
              </button>
            </li>
          ))}
        </ul>
      );
      // 데이터를 성공적으로 가져오면 투두 리스트를 화면에 표시한다.
    }
    ```

    </details>

    <details>
    <summary>Detail.jsx</summary>

    ```jsx
    // src/pages/Detail.jsx

    import { useQuery } from "@tanstack/react-query";
    import { useNavigate, useParams } from "react-router-dom";
    import { getDetail } from "../api/todos";

    export default function Detail() {
      const { id } = useParams(); // URL 파라미터에서 id를 가져온다.
      const navigate = useNavigate(); // 페이지 이동을 위한 함수를 가져온다.

      // useQuery 훅을 사용하여 todos 쿼리를 실행한다.
      const { data, isPending, error } = useQuery({
        queryKey: ["todos", id], // 쿼리 키로 ["todos", id]를 사용한다.
        queryFn: getDetail, // getDetail() 함수를 사용하여 특정 투두 항목의 상세 정보를 가져온다.
      });
      console.log("data:", data);

      if (isPending) return <div style={{ fontSize: 36 }}>로딩중...</div>;

      if (error) {
        console.error(error);
        return (
          <div style={{ fontSize: 24 }}>
            에러가 발생했습니다: {error.message}
          </div>
        );
      }

      return (
        <div>
          <button onClick={() => navigate("/")}>홈으로 이동</button>
          <p>제목: {data.title}</p>
          <p>내용: {data.contents}</p>
          <p>작성일자: {new Date(data.createdAt).toDateString()}</p>
        </div>
      );
      // 데이터를 성공적으로 가져오면 투두 항목의 세부 정보를 표시한다.
    }
    ```

    </details>

    <details>
    <summary>todos.js</summary>

    ```javascript
    // src/api/todos.js

    import axios from "axios";

    export const todoApi = axios.create({
      baseURL: "http://localhost:4000",
    });
    // Axios의 create() 메서드를 사용하여 HTTP 클라이언트 인스턴스를 생성한다.

    export const getDetail = async ({ queryKey }) => {
      // useQuery 훅에서 사용될 쿼리의 키인 queryKey 객체를 매개변수로 받는다.
      const [_, id] = queryKey;
      // 배열 구조 분해 할당을 통해 queryKey 배열의 두 번째 요소인 id를 추출한다.
      // 첫 번째 요소는 여기서 사용되지 않는다.

      const response = await todoApi(`/todos/${id}`);
      // todoApi 객체를 사용하여 HTTP GET 요청을 보낸다.
      // 이 요청은 특정 투두 항목의 상세 정보를 요청한다.
      return response.data; // 서버에서 받아온 응답 데이터를 반환한다.
    };
    ```

    </details>

- TanStack Query에서 서버 상태가 설정되는 시점

  - **`queryFn`이 실행되어 값을 반환하는 즉시**, 그 값이 쿼리 클라이언트(QueryClient)의 서버 상태로 설정된다.

- `isPending`과 `isFetching`의 차이

  - **`isPending`**

    - v5부터 **`isLoading`의 명칭이 `isPending`으로 변경**되었다.

    - QueryClient에 **아직 데이터가 없고**, **쿼리가 아직 실행 대기 중인지**의 여부를 나타내는 boolean 값이다.

    - **데이터 요청이 아직 완료되지 않았을 때 `true`로 설정된다.**

    - **쿼리가 초기 데이터를 가져오는 중일 때나, 캐시에서 데이터를 다시 가져오는 중일 때도 `true`일 수 있다. (둘의 공통점)**

    - 요청이 완료되면 `false`로 변경된다.

    - 일반적으로 UI에서 **"로딩 중" 메시지**를 표시하는 용도로 사용된다.

  - **`isFetching`**

    - **쿼리가 현재 실행 중인지**의 여부를 나타내는 boolean 값이다.

    - 초기 로딩 및 refetching을 모두 포함한다.

    - **쿼리가 활성화되어 있고, 백그라운드에서 데이터를 다시 가져오는 동안 `true`로 설정된다.**

    - **쿼리가 초기 데이터를 가져오는 중일 때나, 캐시에서 데이터를 다시 가져오는 중일 때도 `true`일 수 있다. (둘의 공통점)**

    - 데이터를 캐시에서 다시 가져오는 중이거나, 인수를 사용하여 쿼리를 다시 실행할 때도 `true`일 수 있다.

    - **데이터가 캐시에서 다시 로드되는지 여부**를 실시간으로 알려주므로, UI에서 **데이터를 업데이트하는 중에 로딩 상태**를 표시하는 데 유용하다.

## 2. `useQuery` - 상세 데이터 처리 패턴

- **`QueryFunctionContext`**

  - TanStack Query의 내부에서 사용되는 컨텍스트(Context)

  - `useQuery` 훅에 의해 생성된 쿼리 인스턴스 내에서 **`queryFn`이 실행될 때 추가적인 맥락과 정보를 제공**하는 데 사용된다.

  - 즉, **`queryFn`의 매개변수로 전달되는 객체**이다.

  - 주요 속성

    1. `queryKey`

       - **쿼리를 고유하게 식별**하는 역할을 한다.

       - **배열 형태**로 전달되며, **첫 번째 요소는 쿼리의 식별자(이름)** 를 나타내고, **두 번째 요소부터는 추가적인 매개변수**를 포함할 수 있다.

    2. `meta`

       - **쿼리에 관련된 메타 데이터**를 포함하는 객체이다.

       - 주로 쿼리의 상태를 추적하거나 추가적인 정보를 제공하는 데 사용된다.

       - 쿼리의 로딩 상태, 데이터 캐시 만료 여부 등의 정보를 포함할 수 있다.

    3. `signal`

       - **쿼리의 실행을 취소하거나 정지**하는 데 사용되는 AbortController 신호이다.

       - 네트워크 중단을 요청하거나 취소할 때 유용하게 사용된다.

    4. `pageParam`

       - 페이지네이션(Pagination)을 지원하는 경우에 사용되는 매개변수이다.

       - **페이지네이션된 데이터**를 처리할 때 **현재 페이지의 매개변수를 전달**하고, **다음 페이지를 요청**할 때 이 값을 변경하여 다음 페이지의 데이터를 가져올 수 있다.

  - 예제: `QueryFunctionContext` 객체의 속성 중 `queryKey`만 추출하여 사용

    ```jsx
    // src/pages/Detail.jsx 일부

    const { id } = useParams();

    const { data, isPending, error } = useQuery({
      queryKey: ["todos", id],
      queryFn: getDetail,
    });
    ```

    ```javascript
    // src/api/todos.js 일부

    export const getDetail = async ({ queryKey }) => {
      const [_, id] = queryKey;

      const response = await todoApi(`/todos/${id}`);
      return response.data;
    };
    ```

    - `getDetail()` 함수

      - TanStack Query에서 사용되는 쿼리 함수

      - `QueryFunctionContext` 컨텍스트 객체를 매개변수로 받아서 동작한다.

      - 여기서는 객체 구조 분해 할당을 통해 `QueryFunctionContext` 객체의 `queryKey` 속성만을 추출하여 사용한다.

## 3. `useQuery` - `enabled`, `select` 옵션

- `enabled` 옵션

  - 쿼리를 활성화할지 여부를 결정하는 옵션

  - **`enabled` 옵션이 없거나 `enabled` 옵션을 `true`로 설정**한 경우, 컴포넌트가 마운트될 때 **자동으로 쿼리가 실행**된다.

  - **`enabled` 옵션을 `false`로 설정**한 경우, 초기 렌더링 시에 쿼리가 자동으로 시작되지 않고, 필요한 시점에 **수동으로 쿼리를 실행**시킬 수 있다.

  - 적용 예제

    - 예제 1: Disabling/Pausing Queries (**이벤트 발생 시**에만 수동으로 실행하고 싶을 때)

      ```jsx
      const { data, refetch } = useQuery({
        queryKey: ["todos"],
        queryFn: getTodos,
        enabled: false,
      });

      return (
        <div>
          <button onClick={() => refetch()}>데이터 불러오기</button>
        </div>
      );
      ```

      - 쿼리의 초기 활성화 여부(`enabled`)를 `false`로 설정하여 컴포넌트가 마운트될 때 자동으로 쿼리가 실행되지 않도록 한다.

      - `refetch`는 `useQuery` 훅에서 제공하는 메서드로, **`queryFn`을 실행하여 데이터를 가져오고, `queryKey`에 해당하는 데이터를 캐시에 저장**한다.

      - "데이터 불러오기" 버튼 클릭 시 `refetch()` 메서드를 호출하여 수동으로 쿼리를 다시 실행하여 데이터를 가져오게 된다.

    - 예제 2: Dependent Queries (**`useQuery` 훅이 2개 이상**이며 **실행 순서 설정**이 필요할 때)

      ```jsx
      const { data: user } = useQuery({
        queryKey: ["user", email],
        queryFn: getUserByEmail,
      });

      const userId = user?.id;

      const {
        status,
        fetchStatus,
        data: projects,
      } = useQuery({
        queryKey: ["projects", userId],
        queryFn: getProjectsByUser,
        enabled: !!userId,
      });
      ```

      - 첫 번째 쿼리

        - `useQuery` 훅이 실행되어 `email`을 기반으로 사용자 데이터를 가져온다.
        - `getUserByEmail()` 함수가 실행되어 사용자 데이터를 반환한다.
        - 반환된 사용자 데이터는 `user` 변수에 저장된다.

      - 사용자 ID 추출

        - `user` 객체에서 `id` 속성을 추출하여 `userId` 변수에 저장한다.
        - 만약 `user`가 존재하지 않으면, `userId`는 `undefined`가 된다.

      - 두 번째 쿼리

        - `useQuery` 훅이 실행되어 `userId`를 기반으로 프로젝트 데이터를 가져온다.
        - **`enabled` 옵션이 `!!userId`로 설정되어 있어, `userId`가 존재할 때만 쿼리가 실행된다.**
        - userId가 존재하면, `getProjectsByUser()` 함수가 실행되어 프로젝트 데이터를 반환한다.
        - 반환된 프로젝트 데이터는 `projects` 변수에 저장된다.

- `select` 옵션

  - 쿼리에서 가져온 **데이터를 변형하거나 선택적으로 처리**할 때 사용된다.

  - 주로 **데이터를 정제하거나 필요한 부분만 선택**하여 사용할 때 유용하다.

  - **UI에 특정 형식으로 데이터를 제공**할 때 유용하다.

  - **`queryFn`에 의해 리턴된 값을 매개변수로 받아서 변형시킨 후**에, **`useQuery` 훅의 리턴 `data` 값으로 넘겨준다.**

  - 주의: **쿼리 컨텍스트에 저장되는 쿼리 데이터(캐시 데이터)는 `select`의 리턴값이 아닌 `queryFn`의 리턴값이다.**

  - 예제

    ```jsx
    function User() {
      const { data } = useQuery({
        queryKey: ["user"],
        queryFn: fetchUser,
        select: (user) => user.username,
      });

      return <div>Username: {data}</div>;
    }
    ```

    - `fetchUser()` 함수가 성공적으로 데이터를 가져온 후, `select` 함수가 호출된다.

    - `select` 함수는 `user` 객체를 인수로 받아 `user` 객체의 `username` 속성을 반환한다.

    - `select` 함수의 반환값인 사용자 이름(`user.username`)은 `useQuery` 훅의 `data`에 저장된다.

## 4. Optimistic Update - 좋아요, 찜하기, 북마크, 팔로우

![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F8199403a-d0e7-44da-97c7-89f800e45557%2FUntitled.png?table=block&id=bc3929a4-14c4-4eba-8c76-23d3c13cc1b5&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1300&userId=&cache=v2)

- **서버 요청이 정상적으로 잘 될거라는 가정** 하에 **UI를 먼저 변경**하고 서버를 요청하는 방식

- 서버 요청이 실패하는 경우, UI를 빠르게 원상복구(revert/roll back)한다.

- Optimistic Update 적용 전 (4_beforeOptimistic 브랜치)

  ```jsx
  // src/components/TodoList.jsx 일부

  const queryClient = useQueryClient();

  const { mutate: handleLike } = useMutation({
    mutationFn: ({ id, currentLiked }) =>
      todoApi.patch(`/todos/${id}`, { liked: !currentLiked }),
    onSuccess: () => {
      queryClient.invalidateQueries(["todos"]);
    },
    onError: (err) => console.err(err),
  });
  ```

  1. `mutationFn` 실행

     - 서버에 PATCH 요청을 보내서 todo 항목의 `liked` 상태를 토글한다.

     - `mutationFn`의 매개변수는 `useMutation` 훅의 `mutate` 함수 또는 `mutateAsync` 함수가 호출될 때 전달된 인수이다.

  2. **서버 요청 성공 시 `onSuccess` 실행**

     - 쿼리 키가 `todos`인 데이터를 무효화하여 서버에서 최신 데이터를 가져오도록 한다.

     - 즉, **서버 요청이 완료된 후에만 UI를 업데이트**하므로 UI 업데이트가 느리다.

  3. 요청 실패 시 `onError` 실행

- Optimistic Update 적용 후 (5_optimistic 브랜치)

  ```jsx
  // src/components/TodoList.jsx 일부

  const queryClient = useQueryClient();

  const { mutate: handleLike } = useMutation({
    mutationFn: ({ id, currentLiked }) =>
      todoApi.patch(`/todos/${id}`, { liked: !currentLiked }),
    onMutate: async ({ id, currentLiked }) => {
      await queryClient.cancelQueries({ queryKey: ["todos"] });
      const previousTodos = queryClient.getQueryData(["todos"]);
      queryClient.setQueryData(["todos"], (oldTodos) =>
        oldTodos.map((todo) =>
          todo.id === id ? { ...todo, liked: !currentLiked } : todo
        )
      );
      return { previousTodos };
    },
    onError: (err, _, context) => {
      queryClient.setQueryData(["todos"], context.previousTodos);
    },
    onSettled: () => {
      queryClient.invalidateQueries(["todos"]);
    },
  });
  ```

  1. **`onMutate` 실행**

     - **`mutationFn`가 호출되기 전에 실행**된다. 이 부분에서 **낙관적 업데이트**를 처리한다.

     - **서버 요청 전에 UI를 미리 업데이트**하므로 UI 업데이트가 빠르다.

     - **쿼리 취소** : `queryClient.cancelQueries`를 사용하여 `todos` 쿼리를 일시 중지한다.

     - **이전 데이터 저장** : `queryClient.getQueryData`를 사용하여 현재 `todos` 데이터를 `previousTodos` 변수에 저장한다.

     - **UI 업데이트** : `queryClient.setQueryData`를 사용하여 `todos` 데이터를 업데이트한다. 해당 `todo` 항목의 `liked` 상태를 토글하여 즉시 UI에 반영한다.

     - **컨텍스트 반환** : `previousTodos`를 반환하여 나중에 참조할 수 있도록 한다.

  2. `mutationFn` 실행

     - 서버에 PATCH 요청을 보내서 todo 항목의 `liked` 상태를 토글한다.

     - `mutationFn`의 매개변수는 `useMutation` 훅의 `mutate` 함수 또는 `mutateAsync` 함수가 호출될 때 전달된 인수이다.

  3. 요청 실패 시 `onError` 실행

     - 요청이 실패하면, `context.previousTodos`를 사용하여 UI를 이전 상태로 재빠르게 되돌린다.

  4. 요청 완료 시 `onSettled` 실행

     - 성공이든 실패든 상관없이 요청이 완료되면, `todos` 쿼리를 무효화하여 서버에서 최신 데이터를 가져오도록 한다.

## 5. `useMutation`의 `mutationFn`은 매개변수를 한 개만 받을 수 있다.

- 문제점: `mutationFn`의 매개변수가 2개이다.

  ```jsx
  mutationFn: (id, currentLiked) =>
    todoApi.patch(`/todos/${id}`, { liked: !currentLiked }),
  ```

- 해결책: **객체 구조 분해 할당**을 이용해서 여러 개의 데이터를 매개변수로 받는다.

  ```jsx
  mutationFn: ({ id, currentLiked }) =>
    todoApi.patch(`/todos/${id}`, { liked: !currentLiked }),
  ```

<br>
<hr>
<br>

리액트 스탠다드 12일차 강의 내용 정리

## 6. 페이지네이션

- 대량의 데이터를 여러 페이지로 나누어 보여주는 기법

  ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fc99e787b-a037-4123-844d-18729790b342%2FUntitled.png?table=block&id=0abe8058-cfc9-4860-8ce7-7197846db1c3&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=250&userId=&cache=v2)

- 페이지네이션의 주요 요소

  - **페이지 당 항목 수(Items per Page)** : 한 페이지에 표시되는 데이터 항목의 수 -> 기획에 따라 사전에 정해진다.

  - **총 데이터 개수(Total Count)** : 전체 데이터의 총 개수 -> 서버에 물어봐야 한다.

  - **전체 페이지 수(Total Pages)** : 전체 데이터를 페이지당 항목 수로 나누어 얻은 총 페이지 수 -> 서버에 물어보거나, 총 데이터 개수와 페이지 당 항목 수를 알고 있다면 계산한다.

  - **페이지 번호(Page Number)** : 현재 페이지의 번호 -> 사용자가 번호를 클릭함에 따라 변경될 수 있는 값이므로 **상태로 관리**해야 한다.

  - **다음/이전 페이지(Next/Previous Page)** : 사용자가 다음 또는 이전 페이지로 이동할 수 있도록 하는 네비게이션 요소

- 페이지네이션 예제 (1_pagination 브랜치) - **전체 페이지 수, 현재 페이지 번호, 페이지 변경 함수**만 있으면 된다.

  - `TodoList.jsx` 파일

    ```jsx
    // src/components/TodoList.jsx

    import { useQuery } from "@tanstack/react-query";
    import { useState } from "react";
    import { todoApi } from "../api/todos";
    import Pagination from "./Pagination";
    import TodoItem from "./TodoItem";

    const ITEMS_PER_PAGE = 4; // 페이지 당 항목 수를 4개로 정의

    export default function TodoList() {
      const [page, setPage] = useState(1); // 현재 페이지 번호를 나타내는 상태

      const { isPending, error, data } = useQuery({
        queryKey: ["todos", page],
        queryFn: async () => {
          const response = await todoApi.get("/todos", {
            params: { _page: page, _limit: ITEMS_PER_PAGE },
          });
          return {
            todos: response.data,
            totalCount: response.headers["x-total-count"],
          };
        },
      });

      if (isPending) return <div>로딩중...</div>;

      if (error) {
        console.error(error);
        return <div>에러가 발생했습니다: {error.message}</div>;
      }

      const totalPages = Math.ceil(data.totalCount / ITEMS_PER_PAGE);
      // 총 페이지 수 계산

      return (
        <>
          <ul style={{ listStyle: "none", width: 250 }}>
            {data.todos.map((todo) => (
              <TodoItem key={todo.id} todo={todo} />
            ))}
          </ul>
          <Pagination page={page} setPage={setPage} totalPages={totalPages} />
        </>
      );
    }
    ```

    - `queryKey`

      - 배열의 첫 번째 요소 `todos`는 이 쿼리의 기본 식별자이다.

      - 배열의 두 번째 요소 `page`는 현재 페이지 번호이다. 페이지 번호가 바뀔 때마다 새로운 데이터를 가져오기 위해 포함된다.

    - `queryFn`

      - `params` 객체를 사용하여 쿼리 파라미터를 설정한다.

      - `_page: page`는 현재 페이지 번호를 나타내고, `_limit: ITEMS_PER_PAGE`는 한 페이지에 표시할 항목 수이다.

      - **서버에서 반환된 실제 데이터인 `response.data`** 를 `queryFn`이 반환하는 객체의 `todos` 속성값으로 정의한다.

      - **서버 응답 헤더에서 가져온 총 항목 수인 `response.headers["x-total-count"]`** 를 `queryFn`이 반환하는 객체의 `totalCount` 속성값으로 정의한다.

    - **`useQuery`에서 반환된 데이터인 `data`는 `todos`와 `totalCount`를 포함하는 객체**가 된다.

  - `Pagination.jsx` 파일

    ```jsx
    // src/components/Pagination.jsx

    export default function Pagination({ totalPages, page, setPage }) {
      return (
        <div
          style={{
            display: "flex",
            justifyContent: "center",
            marginTop: "20px",
          }}
        >
          {/* 이전 버튼 */}
          <button
            onClick={() => setPage((prev) => Math.max(prev - 1, 1))}
            disabled={page === 1}
          >
            prev
          </button>
          {/* 페이지 버튼들 */}
          {[...Array(totalPages)].map((_, index) => (
            <button
              key={index + 1}
              onClick={() => setPage(index + 1)}
              style={{
                fontWeight: page === index + 1 ? "bold" : "normal",
                margin: "0 5px",
              }}
            >
              {index + 1}
            </button>
          ))}
          {/* 다음 버튼 */}
          <button
            onClick={() => setPage((prev) => Math.min(prev + 1, totalPages))}
            disabled={page === totalPages}
          >
            next
          </button>
        </div>
      );
    }
    ```

    - 이전 버튼

      - `onClick` : 클릭 시 현재 페이지 번호를 1 감소시킨다. 단, 페이지 번호는 최소 1이다.

      - `disabled` : 현재 페이지가 1일 경우 버튼이 비활성화된다.

    - 페이지 버튼들

      - **`Array(totalPages)`를 사용해 페이지 수만큼의 빈 배열을 생성**하고, `map()` 메서드의 두 번째 인자인 `index`를 이용해 각 페이지 버튼을 렌더링한다.

      - `onClick` : 클릭 시 해당 페이지로 이동하도록 `setPage()` 함수를 호출한다.

      - `style` : 현재 페이지와 일치하는 버튼은 굵은 글씨체로 표시된다.

    - 다음 버튼

      - `onClick` : 클릭 시 현재 페이지 번호를 1 증가시킨다. 단, 페이지 번호는 최대 `totalPages`이다.

      - `disabled` : 현재 페이지가 `totalPages`일 경우 버튼이 비활성화된다.

## 7. 더보기, 무한 스크롤

![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F357a16c4-bb56-407f-a9b0-84a61a25f9e3%2FUntitled.png?table=block&id=6b8085ec-a05f-44bd-9e1d-8c6f6295fec9&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=600&userId=&cache=v2)

- 사용자 인터렉션에 따른 추가 데이터 로드하는 UI

- `useInfiniteQuery`를 이용하여 편리하게 구현이 가능하다.

- 더보기, 무한 스크롤의 공통 주요 특징

  1. 서버에서 불러온 **신규 데이터를 기존 데이터에 합친다.**

     - `useInfiniteQuery`의 **정형화된 캐시 데이터 형식**은 데이터 누적 관리를 용이하게 한다.

       ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F2eea2240-9428-4983-a727-1953aa3b4269%2FUntitled.png?table=block&id=1b59f3d0-a181-4024-87bc-46f3de955bf2&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=350&userId=&cache=v2)

       - **`pages`** : `queryFn` 요청 시마다 리턴값을 배열 안에 누적한다.
       - **`pageParams`** : `queryFn` 요청 시 매개변수로 넘겨준 `pageParam` 값을 배열 안에 누적한다.

  2. 서버에서 데이터를 불러온 뒤, **다음 페이지 존재 여부를 확인**한다.

     - `hasNextPage` : 추가로 불러온 다음 페이지가 있는지의 여부

       - `getNextPageParam` 함수의 리턴값이 `undefined`인 경우 `false`

     - 다음 페이지가 있을 경우에만 "더보기" 버튼이 노출되어야 한다.

       ```jsx
       {
         hasNextPage && (
           <button
             onClick={() => fetchNextPage()}
             disabled={isFetchingNextPage}
           >
             {isFetchingNextPage ? "로딩중..." : "더보기"}
           </button>
         );
       }
       ```

- 다음 페이지의 존재 여부를 미리 알 수 있을 때

  - 요청하는 데이터의 총 데이터 개수와 페이지 당 개수만 알아도 다음 페이지 존재 여부를 미리 알 수 있다.

    ```jsx
    getNextPageParam: (lastPage, allPages, lastPageParam) => {
      const nextPage = lastPageParam + 1;
      return nextPage <= lastPage.totalPages ? nextPage : undefined;
    };
    ```

    - **`lastPage`**

      - **가장 최근에 받아온 페이지 데이터**
      - 예를 들어, 1페이지부터 3페이지까지 데이터를 가져온 경우, `lastPage`는 3페이지의 데이터를 나타낸다.
      - 이 값은 일반적으로 서버에서 반환된 데이터와 동일한 구조를 가진다.

    - **`allPages`**

      - **현재까지 누적된 모든 페이지 데이터 배열**
      - 예를 들어, 1페이지부터 3페이지까지 데이터를 가져온 경우, `allPages`는 [page1Data, page2Data, page3Data]와 같은 구조를 가진다.
      - 이를 통해 지금까지 가져온 모든 페이지의 데이터를 참조할 수 있다.

    - **`lastPageParam`**

      - **가장 최근에 사용된 페이지 번호**
      - 예를 들어, 현재 3페이지의 데이터를 불러온 경우, `lastPageParam`은 3이 된다.
      - 이를 통해 다음에 불러올 페이지 번호를 계산할 수 있다.

    - 코드 해석

      - 현재 페이지 번호(`lastPageParam`)에 1을 더하여 다음 페이지 번호(`nextPage`)를 계산한다.

      - 계산된 다음 페이지 번호(`nextPage`)가 총 페이지 수(`lastPage.totalPages`)를 초과하지 않는지 확인한다.

        - `nextPage`가 `lastPage.totalPages`보다 작거나 같은 경우, 다음 페이지 번호를 반환한다.

        - `nextPage`가 `lastPage.totalPages`를 초과하면 `undefined`를 반환한다. `undefined`를 반환하면 더 이상 불러올 페이지가 없음을 의미한다.

- 다음 페이지의 존재 여부를 미리 알 수 없을 때

  ```jsx
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    const nextPage = lastPageParam + 1;
    return lastPage.length === ITEMS_PER_PAGE ? nextPage : undefined;
  };
  ```

  - 코드 해석

    - 현재 페이지 번호(`lastPageParam`)에 1을 더하여 다음 페이지 번호(`nextPage`)를 계산한다.

    - 다음 페이지의 존재 여부를 확인한다.

      - `lastPage.length`가 `ITEMS_PER_PAGE`와 같으면, 이는 현재 페이지가 가득 찼음을 의미하며, **다음 페이지가 있을 가능성이 높다.** 따라서 `nextPage`를 반환한다.

      - `lastPage.length`가 `ITEMS_PER_PAGE`와 같은데 다음 페이지가 없다면, 텅 빈 데이터를 불필요하게 한 번 요청해야 하는 상황이 발생한다.

      - `lastPage.length`가 `ITEMS_PER_PAGE`보다 작으면, 이는 현재 페이지가 가득 차지 않았음을 의미하며, **더 이상 불러올 페이지가 없음**을 나타낸다. 따라서 `undefined`를 반환한다.

  - 서버 응답에 total count 포함 여부에 따른 `queryFn` 리턴값 설정 차이

    - 서버의 response에 total count 데이터가 포함되어 있는 경우

      ```jsx
      queryFn: async ({ pageParam }) => {
        const response = await todoApi.get("/todos", {
          params: { _page: pageParam, _limit: ITEMS_PER_PAGE },
        });
        return {
          todos: response.data,
          totalPages: Math.ceil(
            response.headers["x-total=count"] / ITEMS_PER_PAGE
          ),
        };
      };
      ```

    - 서버의 response에 단순히 데이터만 들어있는 경우

      ```jsx
      queryFn: async ({ pageParam }) => {
        const response = await todoApi.get("/todos", {
          params: { _page: pageParam, _limit: ITEMS_PER_PAGE },
        });
        return response.data;
      };
      ```

- 더보기 예제

  - 다음 페이지의 존재 여부를 미리 알 수 있는 경우 (2_viewMore 브랜치)

    ```jsx
    // src/components/TodoList.jsx

    import { useInfiniteQuery } from "@tanstack/react-query";
    import { todoApi } from "../api/todos";
    import TodoItem from "./TodoItem";

    const ITEMS_PER_PAGE = 4;

    export default function TodoList() {
      const {
        data: todos,
        fetchNextPage,
        hasNextPage,
        isFetchingNextPage,
        isPending,
        error,
      } = useInfiniteQuery({
        queryKey: ["todos"],
        initialPageParam: 1,
        queryFn: async ({ pageParam }) => {
          const response = await todoApi.get("/todos", {
            params: { _page: pageParam, _limit: ITEMS_PER_PAGE },
          });
          return {
            todos: response.data,
            totalPages: Math.ceil(
              response.headers["x-total-count"] / ITEMS_PER_PAGE
            ),
          };
        },
        getNextPageParam: (lastPage, allPages, lastPageParam) => {
          const nextPage = lastPageParam + 1;
          return nextPage <= lastPage.totalPages ? nextPage : undefined;
        },
        select: ({ pages }) =>
          pages.map((todosperPage) => todosPerPage.todos).flat(),
      });

      if (isPending) {
        return (
          <div style={{ fontSize: 36 }}>
            <p>로딩중...</p>
          </div>
        );
      }

      if (error) {
        console.error(error);
        return (
          <div style={{ fontSize: 24 }}>
            에러가 발생했습니다: {error.message}
          </div>
        );
      }

      return (
        <>
          <ul style={{ listStyle: "none", width: 250 }}>
            {todos.map((todo) => (
              <TodoItem key={todo.id} todo={todo} />
            ))}
          </ul>
          {hasNextPage && (
            <button
              onClick={() => fetchNextPage()}
              disabled={isFetchingNextPage}
            >
              {isFetchingNextPage ? "로딩중..." : "더보기"}
            </button>
          )}
        </>
      );
    }
    ```

    - `useInfiniteQuery` 훅 사용

      - `queryKey`

        - 쿼리의 고유 식별자이다. 이는 캐시에서 데이터를 저장하고 검색하는 데 사용된다.

        - 여기서는 `todos`라는 키를 기준으로 캐싱되고 재사용된다.

      - `initialPageParam`

        - 첫 번째 페이지의 초기 매개변수를 설정한다.

        - 이 값은 **`queryFn`의 `pageParam`으로 전달**된다.

        - 여기서는 첫 페이지의 매개변수로 1을 설정했다.

      - `queryFn`

        - 페이지 데이터를 가져오는 함수이다.

        - **`pageParam`을 사용하여 현재 페이지 번호를 API 요청에 전달**한다.

        - API 요청 후, 받은 데이터를 반환한다. 여기서는 **총 페이지 수(`totalPages`)도 계산**하여 반환한다.

        - 즉, 이 함수는 `{todos, totalPages}` 형식의 객체를 반환한다.

      - `getNextPageParam`

        - **다음 페이지의 매개변수를 결정하는 함수**이다.

        - **현재 페이지 매개변수(`lastPageParam`)에 1을 더하여 다음 페이지 매개변수(`nextPage`)를 계산**한다.

        - 계산된 `nextPage`가 총 페이지 수(`lastPage.totalPages`)보다 작거나 같으면 다음 페이지 번호(`nextPage`)를 반환하고, 그렇지 않으면 `undefined`를 반환한다.

      - `select`

        - **`queryFn`에서 반환된 데이터를 변환**한다.

        - **각 페이지의 데이터 배열(`pages`)에서 `map()` 메서드를 이용하여 `todos` 배열을 추출**하고, **`flat()` 메서드를 이용하여 하나의 배열로 평탄화**한다.

        - 이렇게 **변환된 데이터는 `useInfiniteQuery`의 `data` 속성에 할당**되며, 여기서는 `todos`라는 변수로 사용된다.

    - 쿼리 결과

      - `data: todos` : 쿼리에서 반환된 데이터를 `todos`로 재명명하여 사용한다.

      - `fetchNextPage` : 다음 페이지를 가져오는 함수이다.

      - `hasNextPage` : 다음 페이지가 있는지 여부를 나타내는 boolean 값이다.

      - `isFetchingNextPage` : 다음 페이지를 가져오는 중인지 여부를 나타내는 boolean 값이다.

      - `isPending` : 초기 데이터 로딩 중인지 여부를 나타내는 boolean 값이다.

      - `error` : 쿼리 실행 중 발생한 오류이다.

  - 다음 페이지의 존재 여부를 미리 알 수 없는 경우 (3_viewMore_noTotal 브랜치)

    ```jsx
    // src/components/TodoList.jsx

    import { useInfiniteQuery } from "@tanstack/react-query";
    import { todoApi } from "../api/todos";
    import TodoItem from "./TodoItem";

    const ITEMS_PER_PAGE = 4;

    export default function TodoList() {
      const {
        data: todos,
        fetchNextPage,
        hasNextPage,
        isFetchingNextPage,
        isPending,
        error,
      } = useInfiniteQuery({
        queryKey: ["todos"],
        initialPageParam: 1,
        queryFn: async ({ pageParam }) => {
          const response = await todoApi.get("/todos", {
            params: { _page: pageParam, _limit: ITEMS_PER_PAGE },
          });
          return response.data; // 차이점 1
        },
        getNextPageParam: (lastPage, allPages, lastPageParam) => {
          const nextPage = lastPageParam + 1;
          return lastPage.length === ITEMS_PER_PAGE ? nextPage : undefined;
        }, // 차이점 2
        select: ({ pages }) => pages.flat(), // 차이점 3
      });

      if (isPending) {
        return (
          <div style={{ fontSize: 36 }}>
            <p>로딩중...</p>
          </div>
        );
      }

      if (error) {
        console.error(error);
        return (
          <div style={{ fontSize: 24 }}>
            에러가 발생했습니다: {error.message}
          </div>
        );
      }

      return (
        <>
          <ul style={{ listStyle: "none", width: 250 }}>
            {todos.map((todo) => (
              <TodoItem key={todo.id} todo={todo} />
            ))}
          </ul>
          {hasNextPage && (
            <button
              onClick={() => fetchNextPage()}
              disabled={isFetchingNextPage}
            >
              {isFetchingNextPage ? "로딩중..." : "더보기"}
            </button>
          )}
        </>
      );
    }
    ```

- 무한 스크롤에서 사용자가 스크롤을 내렸을 때 다음 페이지 로드를 트리거하는 방법

  - intersection observer를 이용하는 것이 표준으로 자리잡았고, 리액트에서는 `react-intersection-observer` 패키지의 `useInView` 훅을 이용하는 것을 권장한다.

  - 관찰 대상(`ref` 요소)의 맨 아래 부분과 화면(viewport)이 맞닿을 때 다음 페이지 로드

    ```jsx
    const { ref } = useInView({
      threshold: 1,
      onChange: (inView) => {
        if (inView && hasNextPage && !isFetchingNextPage) {
          fetchNextPage();
        }
      },
    });

    // 관찰 대상은 보통 리스트의 마지막 아이템으로 적용한다.
    return (
      <>
        <ul
          style={{ listStyle: "none", width: 250, backgroundColor: "beige" }}
        >
        {todos.map((todo, idx) => {
          const isLastItem = todos.length - 1 = idx;
          // 현재 항목이 마지막 항목인지 확인한다.
          return (
            <TodoItem ref={isLastItem ? ref : null} key={todo.id} todo={todo} />
            {/* isLastItem이 true이면 ref를 전달하여 이 항목을 관찰 대상으로 설정한다. */}
          )
        })}
        </ul>
      </>
    );
    ```

    - `useInView` 설정

      - `useInView`는 Intersection Observer API를 활용하는 React 훅으로, **요소가 뷰포트에 들어왔는지 여부를 감지**한다.

      - `threshold`

        - **관찰 대상 요소가 뷰포트에 들어왔는지(또는 나갔는지)를 판단하는 기준을 설정**한다.

        - 값은 0과 1 사이의 숫자이거나, 숫자들의 배열일 수 있다.

        - 각각의 값은 **요소의 가시 부분이 뷰포트에 어느 정도로 들어왔을 때 콜백 함수가 호출될지를 결정**한다.

        - 여기서는 1로 설정하여 요소가 100% 뷰포트에 들어올 때 `onChange` 콜백이 호출된다.

      - `onChange`

        - **요소가 뷰포트에 들어오거나 나갈 때 호출되는 콜백 함수**

        - `inView` : 요소가 뷰포트에 들어왔는지 여부를 나타내는 boolean 값

        - `hasNextPage` : 다음 페이지가 있는지 여부를 나타내는 boolean 값

        - `isFetchingNextPage` : 다음 페이지를 가져오는 중인지 여부를 나타내는 boolean 값

        - **요소가 뷰포트에 들어왔고, 다음 페이지가 있으며, 다음 페이지를 가져오고 있지 않는 상태이면 `fetchNextPage()`를 호출**한다.

        - `fetchNextPage` : 다음 페이지의 데이터를 가져오는 함수

- 무한 스크롤 예제 (4_infiniteScroll 브랜치)

  - `TodoList.jsx`

    ```jsx
    // src/components/TodoList.jsx

    import { useInfiniteQuery } from "@tanstack/react-query";
    import { useInView } from "react-intersection-observer";
    import { todoApi } from "../api/todos";
    import TodoItem from "./TodoItem";

    const ITEMS_PER_PAGE = 4; // 한 페이지에 보여질 투두 항목의 개수 정의

    export default function TodoList() {
      // useInfiniteQuery 훅을 이용해 데이터를 가져오고 관리한다.
      const {
        data: todos,
        fetchNextPage,
        hasNextPage,
        isFetchingNextPage,
        isPending,
        error,
      } = useInfiniteQuery({
        queryKey: ["todos"], // 쿼리 키
        initialPageParam: 1, // 초기 페이지 매개변수
        queryFn: async ({ pageParam }) => { // 데이터를 가져오는 비동기 함수수
          const response = await todoApi.get("/todos", {
            params: { _page: pageParam, _limit: ITEMS_PER_PAGE },
          });
          return response.data; // 가져온 데이터 반환
        },
        getNextPageParam: (lastPage, allPages, lastPageParam) => { // 다음 페이지 매개변수 계산
          const nextPage = lastPageParam + 1;
          return lastPage.length === ITEMS_PER_PAGE ? nextPage : undefined;
        },
        select: ({ pages }) => pages.flat(), // 페이지에서 데이터를 선택하는 함수
      });

      // useInView 훅을 이용해 무한 스크롤링을 위한 가시성 감지 ref를 설정한다.
      const { ref } = useInView({
        threshold: 1,
        onChange: (inView) => {
          if (inView && hasNextPage && !isFetchingNextPage) {
            fetchNextPage(); // 다음 페이지 데이터를 가져오는 함수 호출
          }
        },
      });

      // 데이터 로딩 중인 경우
      if (isPending) {
        return (
          <div style={{ fontSize: 36 }}>
            <p>로딩중...</p>
          </div>
        );
      }

      // 데이터 로딩 중 에러가 발생한 경우
      if (error) {
        console.error(error);
        return (
          <div style={{ fontSize: 24 }}>
            에러가 발생했습니다: {error.message}
          </div>
        );
      }

      // 정상적으로 데이터가 로드된 경우 투두 항목을 렌더링한다.
      return (
        <>
          <ul
            style={{ listStyle: "none", width: 250, backgroundColor: "beige" }}
          >
            {todos.map((todo, idx) => {
              const isLastItem = todos.length - 1 === idx;
              return (
                <TodoItem
                  ref={isLastItem ? ref : null}
                  {/* 가장 마지막 항목에 ref를 설정하여 무한 스크롤링을 위한 가시성 감지를 가능하게 한다. */}
                  key={todo.id}
                  todo={todo}
                />
              );
            })}
          </ul>
        </>
      );
    }
    ```

  - `TodoItem.jsx`

    ```jsx
    // src/components/TodoItem.jsx

    import { forwardRef } from "react";
    import { useNavigate } from "react-router-dom";

    function TodoItem({ todo }, ref) {
      const navigate = useNavigate();

      return (
        <li
          ref={ref}
          {/* 외부(부모 컴포넌트)에서 전달된 ref를 할당한다. */}
          key={todo.id}
          style={{
            border: "1px solid black",
            padding: "16px",
            marginBottom: "10px",
          }}
        >
          <h3>{todo.title}</h3>
          <div style={{ display: "flex", justifyContent: "space-between" }}>
            <button onClick={() => navigate(`/detail/${todo.id}`)}>
              내용보기
            </button>
          </div>
        </li>
      );
    }

    export default forwardRef(TodoItem);
    ```

    - `forwardRef`

      - 리액트에서 **함수형 컴포넌트가 `ref`를 사용**할 수 있도록 도와주는 함수

      - 함수형 컴포넌트에서는 기본적으로 `ref`를 직접 다루기가 어려운데, 이런 상황에서 `forwardRef`를 사용하면 `ref`를 해당 컴포넌트로 전달할 수 있다.

      - 위 예제에서는 **`forWardRef` 함수를 사용하여 `TodoItem` 컴포넌트를 `ref` 전달이 가능한 형태로 감싸서 내보낸다.**

      - 이로써 **`TodoList` 컴포넌트에서 `TodoItem`을 렌더링할 때 `ref`를 전달할 수 있다.**
