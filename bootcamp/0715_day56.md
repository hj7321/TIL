## 0715_Day56

리액트 스탠다드 14일차 강의 내용 정리

## 1. `isLoading` -> `isPending`

- TanStack Query v5부터는 `isLoading` 대신 `isPending`을 사용한다.

  ```jsx
  const { isLoading, error, data } = useQuery({
    queryKey: ["todos"],
    queryFn: async () => {
      const response = await todoApi.get("/todos");
      return response.data;
    },
  });
  ```

  - **`isLoading`** 은 `isPending`과 `isFetching`을 합친 의미로, **데이터가 페칭되기 시작한 후 데이터를 불러오는 동안**의 상태를 의미한다.

  - **`isPending`** 은 **데이터가 페칭되기 전부터 데이터를 불러오기까지**의 상태를 의미한다.

## 2. 상세 데이터를 상태로 관리할 때 `queryKey` 주의

- **`queryKey`는 관리해야 하는 상태별로 unique하게 관리**한다.

- TanStack Query에서 관리하는 상태를 캐시(쿼리 데이터, 서버상태)라고 부른다.

  - 캐시의 기능

    1. **데이터 저장소 역할**

       - 데이터를 서버에서 가져와서 클라이언트 측에 저장한다.

       - 이 저장소는 **특정 데이터에 대한 최신 복사본**을 보유하고 있으며, 필요할 때 빠르게 접근할 수 있도록 한다.

    2. **메모리 내 저장**

       - 일반적으로 캐시는 메모리 내에 저장된다.

       - 이는 데이터에 접근하는 데 빠르고 효율적인 방법을 제공하며, 필요에 따라 자동으로 업데이트된다.

    3. **자동 관리 및 갱신**

       - 캐시는 내부적으로 관리되며, 데이터의 변경 사항을 감지하여 필요할 때 자동으로 새로운 데이터로 업데이트된다.

       - 이로 인해 개발자는 수동으로 데이터를 관리하거나 업데이트할 필요가 없어진다.

    4. **최적화된 데이터 흐름 제공**

       - 캐시는 **데이터 요청의 반복적인 작업을 최소화**하고, **성능을 향상**시키며, **애플리케이션의 사용자 경험을 개선**하는 데 기여한다.

       - 이는 데이터의 로딩 시간을 줄이고, 네트워크 요청을 최적화하여 전체적인 성능을 향상시킨다.

- 특정 id에 대한 데이터를 상태로 관리해야 할 때 `queryKey`는 `["todos", id]`와 같은 형식으로 작성해야 한다.

  ```jsx
  const { id } = useParams();
  const { isPending, error, data } = useQuery({
    queryKey: ["todos", id],
    queryFn: async () => {
      const response = await todoApi.get(`/todos/${id}`);
      return response.data;
    },
  });
  ```

  - `Home` 페이지 컴포넌트에서 전체 데이터를 불러올 때 `queryKey`를 `["todos"]`로 사용했기 때문에, `Detail` 페이지 컴포넌트에서 특정 데이터를 불러올 때는 `queryKey`를 다르게 사용해야 한다.

## 3. 어떤 mutation을 하는지 명시해야 한다.

- `useMutation`을 사용할 때, 리턴값을 구조 분해 할당 없이 `addMutation`과 같이 어떤 mutation을 하는지 명시해서 `addMutation.mutate`로 사용하는 것이 더 가독성이 좋다.

  ```jsx
  // useMutation의 리턴값(객체)에 이름 지정
  const addMutation = useMutation({
    mutationFn: (newTodo) => todoApi.post("/todos", newTodo),
    onSuccess: () => {
      queryClient.invalidateQueries(["todos"]);
    },
  });

  const handleAddTodo = async (e) => {
    e.preventDefault();
    const newTodo = {
      id: Date.now().toString(),
      title,
      contents,
      isComplete: false,
      createdAt: Date.now(),
    };
    addMutation.mutate(newTodo);
  };
  ```

- 또는 구조 분해 할당을 한 후, `mutate`에 `mutate: addTodo`와 같이 새로운 이름을 지정하여 어떤 mutation을 하는지 명시한다.

  ```jsx
  const {
    mutate: addTodo, // mutate 함수에 새로운 이름 지정
    isPending,
    isError,
    error,
  } = useMutation({
    mutationFn: (newTodo) => todoApi.post("/todos", newTodo),
    onSuccess: () => {
      queryClient.invalidateQueries(["todos"]);
    },
  });

  const handleAddTodo = async (e) => {
    e.preventDefault();
    const newTodo = {
      id: Date.now().toString(),
      title,
      contents,
      isComplete: false,
      createdAt: Date.now(),
    };
    addTodo(newTodo);
  };
  ```

## 4. mutate 실행 시 전달 인자는 `mutationFn`과 `onMutate`의 매개변수로 할당된다.

```jsx
const queryClient = useQueryClient();

const likeMutation = useMutation({
  mutationFn: ({ id, currentLiked }) =>
    // 실제로 데이터를 갱신하고 서버로 요청을 보내는 작업
    // 특정 Todo 의 liked 상태를 토글함
    todoApi.patch(`/todos/${id}`, {
      liked: !currentLiked,
    }),
  onMutate: async ({ id }) => {
    // 데이터 갱신 요청 전에 실행할 작업들
    await queryClient.cancelQueries({ queryKey: ["todos"] }); // "todos" 쿼리 취소
    const previousTodos = queryClient.getQueryData(["todos"]); // 이전 "todos" 데이터 가져오기
    queryClient.setQueryData(["todos"], (prevTodos) =>
      // 새로운 "todos" 데이터 설정
      prevTodos.map((todo) =>
        todo.id === id ? { ...todo, liked: !todo.liked } : todo
      )
    );
    return { previousTodos }; // 롤백을 위해 이전 데이터 반환
  },
  onError: (err, newTodo, context) => {
    // 에러 발생 시 실행할 작업
    console.error(err);
    queryClient.setQueryData(["todos"], context.previousTodos); // 이전 데이터로 "todos" 데이터 복원
  },
  onSettled: () => {
    // mutate 함수가 끝난 후 실행할 작업
    queryClient.invalidateQueries({ queryKey: ["todos"] }); // "todos" 쿼리 무효화 (다시 불러오기)
  },
});

const handleLike = async ({ id, currentLiked }) => {
  likeMutation.mutate({ id, currentLiked });
  // 이 전달 인자는 mutationFn과 onMutation의 매개변수로 할당됨
  // mutate 함수에 여러 개의 인자를 전달하고 싶으면 위와 같이 하나의 객체 안에 값을 넣어서 전달함
};
```

## 5. 타입스크립트란?

타입스크립트는 자바스크립트의 상위 집합(superset)으로, 자바스크립트 문법에 타입 체크를 위한 문법들이 추가된 것이다.

![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F8b8bb8c0-2b74-4097-b249-e7beae3a0a75%2FUntitled.png?table=block&id=35d1778e-f7ed-414e-9145-add305da344c&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=200&userId=&cache=v2)

## 6. 타입스크립트 사용 이유

- **보다 신뢰할 수 있는 코드** : 타입 체크를 통해 런타임 오류를 줄이고, 코드의 예측 가능성을 높인다.

- **규모 확장성** : 코드베이스가 커질수록 타입 시스템 덕분에 안전하고 효율적으로 관리가 가능하다. (faster safely)

- **개발 도구 지원** : 강력한 코드 자동 완성을 지원하여 생산성을 높인다.

## 7. 타입스크립트 동작 패턴

- VSCode의 경우, 실시간 개발환경에서 타입 체크가 동작한다.

  - Editor와 결합되어 코드 실행 전에 에디터 내에서 바로 에러를 확인할 수 있다.

    ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F9e78284d-0a1f-45d9-8ba4-277e2eebfc7d%2FUntitled.png?table=block&id=fa334c9b-9b2c-4b54-b973-e9f22ada2c93&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=600&userId=&cache=v2)

  - VSCode에서는 타입스크립트 파일을 열거나 편집할 때 자동으로 타입 체크가 이루어진다. 이는 실시간으로 코드의 오류를 발견하고 수정할 수 있게 해준다.

  - 만약 프로젝트에 `tsconfig.json`이라는 타입 시스템 설정 파일이 없으면, VSCode는 기본 타입 설정을 사용하여 타입 체크를 진행한다.

    - 기본 설정은 TypeScript 컴파일러의 기본값을 따르며, 이를 통해 최소한의 타입 체크를 수행한다.

  - 그러나, 타입 체크를 보다 세밀하게 제어하고 프로젝트에 맞는 커스터마이징된 타입 시스템을 만들고자 할 때는 `tsconfig.json` 파일이 필요하다.

    - 이 파일을 통해 TypeScript 컴파일러의 다양한 옵션을 설정할 수 있다.

    - `tsconfig.json` 파일을 사용하려면 타입스크립트 패키지가 프로젝트에 설치되어 있어야 한다.

      - 이 패키지는 TypeScript 컴파일러를 포함하며, 이를 통해 VSCode가 `tsconfig.json` 설정을 읽고 타입 체크를 수행할 수 있다.

## 8. 기본적인 타입 지정

- 원시값(기본값) 타입 지정

  - 문자열 타입

    ```typescript
    const name: string = "John";
    ```

  - 숫자 타입

    ```typescript
    const age: number = 24;
    ```

  - 불리언(boolean) 타입

    ```typescript
    const isStudent: boolean = true;
    ```

  - null 타입

    ```typescript
    const nothing: null = null;
    ```

  - undefined 타입

    ```typescript
    const notDefined: undefined = undefined;
    ```

  - **any 타입** : 어떤 타입이든 될 수 있다. (사용 지양)

    ```typescript
    const anyValue: any = "Hello";
    ```

  - **unknown 타입** : 어떤 타입이든 될 수 있지만, 사용 전에 **타입 검사**가 필요하다.

    ```typescript
    const unknownValue: unknown = 42;
    if (typeof unknownValue === "number") {
      console.log(`unknownValue의 숫자 ${unknownValue}입니다.`);
    }
    ```

- 배열 타입 지정

  - 숫자 타입 배열

    ```typescript
    const numbers: number[] = [1, 2, 3, 4, 5];
    ```

  - 문자열 타입 배열

    ```typescript
    const names: string[] = ["Alice", "Bob", "Charlie"];
    ```

  - 불리언(boolean) 타입 배열

    ```typescript
    const bools: boolean[] = [true, false, true];
    ```

  - **튜플(tuple) 타입 배열** : 각 요소에 대해 **정확한 타입과 순서**를 지정한다. (요소 개수 제한됨)

    ```typescript
    const tupleArr: [string, number] = ["123", 123];
    ```

    - 튜플 : **고정된 개수의 요소**를 가지며, **각 요소의 타입이 미리 정의된 배열**

  - **유니온(union) 타입 배열** : 각 요소가 **여러 가지 타입 중 하나임**을 나타낼 수 있다.

    ```typescript
    const unionArr: (string | number)[] = [123, "123", 123, 123, "123"];
    ```

- 객체 타입 지정 : **type alias** 또는 **interface**로 지정이 가능하다.

  - 단순 객체 타입

    ```typescript
    type Person = {
      name: string;
      age: number;
      isStudent: boolean;
    };

    // 단순 객체
    const student: Person = {
      name: "Jane",
      age: 22,
      isStudent: true,
    };
    ```

  - 중첩 객체 타입

    ```typescript
    type Address = {
      street: string;
      city: string;
      country: string;
    };

    type PersonWithAddress = Person & {
      address: Address;
    };

    // 중첩 객체
    const studentWithAddress: PersonWithAddress = {
      name: "John",
      age: 25,
      isStudent: false,
      address: {
        street: "123 Main St",
        city: "Anytown",
        country: "USA",
      },
    };
    ```

- 함수 타입 지정 : **매개변수**와 **return 값**에 대한 타입 지정이 필요하다.

  - 매개변수 타입은 매개변수가 없는 경우를 제외하고는 반드시 지정이 필요하다.

  - return 타입은 지정을 생략할 경우 타입 추론이 된다. 그러나 명시적으로 타입을 지정하는 습관을 들이는 것이 좋다.

  - 함수 선언문에서의 타입 지정

    ```typescript
    function greet(name: string): string {
      return `Hello, ${name}!`;
    }
    ```

    ```typescript
    function add(a: number, b: number): number {
      return a + b;
    }
    ```

    ```typescript
    // 반환 값이 없는 경우, 타입으로 void를 지정한다.
    function printName(name: string): void {
      return console.log(name);
    }
    ```

  - 화살표 함수에서의 타입 지정

    ```typescript
    // 방법 1
    const logMessage1 = (message: string): void => {
      console.log(message);
    };
    ```

    ```typescript
    // 방법 2
    const logMessage2: (message: string): void => = (message) {
      console.log(message);
    };
    ```

    ```typescript
    // 방법 3
    type LogMessageType = (message: string) => void;

    const logMessage3: LogMessageType = (message) => {
      console.log(message);
    };
    ```

  - async 함수에서의 타입 지정

    ```typescript
    type Todo = {
      id: string;
      title: string;
      content: string;
      isDone: boolean;
      createdAt: number;
    };

    const getTodos = async (): Promise<Todo[]> => {
      const response = await axios.get("http://localhost:4000/todos");
      return response.data;
    };
    ```

## 9. Vite로 리액트 타입스크립트 보일러 플레이트 셋업 시 주의사항

- 가장 먼저 VSCode 1.77.3 이상인지 확인한다. 그 이하 버전인 경우 아래와 같은 오류 문구가 나온다.

  ![alt text](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F8403cc69-a66c-4e7b-95c3-d810d2059da9%2FUntitled.png?table=block&id=2874758c-fb15-4e79-a37e-564a99cbadca&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1400&userId=&cache=v2)

## 10. 리액트에서 자주 사용되는 타입스크립트 작업 패턴

- 타입 단언 (Type Assertion)

  - VSCode Editor가 추론하지 못하는 타입을 알고 있을 때 **`as` 키워드**를 통해 에디터에게 타입을 알려줄 수 있다.

  - **`!`** 는 **non-null assertion 연산자**로 **`null` 타입이 아님을 단언**한다.

    ```tsx
    ReactDOM.createRoot(document.getElementById("root")!).render(<App />);
    ```

    - `id`가 "root"인 요소가 `null`이거나 `undefined`일 가능성을 제거하고, 해당 요소가 실제로 존재한다고 단언한다.

    - `!` 대신 `as` 키워드로도 타입 단언이 가능하다.

      ```tsx
      ReactDOM.createRoot(
        document.getElementById("root") as HTMLDivElement
      ).render(<App />);
      ```

- API Response에 대한 타입 지정

- 인덱스 시그니처 (index signature)

- props에 대한 타입 지정

- `useState`에 대한 타입 지정

- 제네릭 타입 (Generic Types)

- event에 대한 타입 지정

- 인덱스 접근 타입 (indexed access type)

- 인터섹션 타입
