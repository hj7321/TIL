## 0503_Day15

<프로그래머스 코딩테스트> 자바스크립트 문법 정리 부분
## 1. [최소직사각형] `reduce()` 메서드에서의 구조 분해 할당
- 공부 계기
  - 이 문제를 한 줄만에 푼 사람이 있었는데, 코드를 보니 구조 분해 할당과 `reduce()` 메서드를 활용하였다.
    ```javascript
    function solution(sizes) {
      const [hor, ver] = sizes.reduce(
        ([h, v], [a, b]) => [
          Math.max(h, Math.max(a, b)),
          Math.max(v, Math.min(a, b)),
        ],
        [0, 0]
      );
      return hor * ver;
    }
    ```
  - 나는 `reduce()` 메서드 내에서 구조 분해 할당 문법을 쓸 수 있는지 몰랐는데, 구조 분해 할당을 잘 활용하니까 코드가 간단해져서 `reduce()` 메서드에서 구조 분해 할당을 쓰는 코드를 분석해보면 좋을 것 같았다.

- **구조 분해 할당**
  - 배열이나 객체의 값들을 추출하여 변수에 할당하는 방법
  - 배열이나 객체의 구조를 파악하여, 그 구조에 맞게 값을 추출하여 변수에 할당하는 것

- 위 코드 분석
  - sizes 배열을 `reduce()` 메서드로 순회한다.
  - `reduce()` 메서드의 초기값은 [0, 0]이다. 즉, h = 0, v = 0이다.
  - `reduce()` 메서드는 배열의 각 요소를 하나씩 순회하면서 누적값을 계산하는 데 사용된다.
  - 여기에서 `reduce()` 메서드의 콜백 함수는 '누적값'과 '현재값'이라는 두 개의 인자를 받는다.
    - `[h, v]` : 누적값이 요소가 2개인(길이가 2인) 배열 형태로 들어오는데, 이를 'h'와 'v'라는 변수에 각각 할당한다.
    - `[a, b]` : 현재값이 요소가 2개인(길이가 2인) 배열 형태로 들어오는데, 이를 'a'와 'b'라는 변수에 각각 할당한다.
  - `reduce()` 메서드는 각 사각형 배열 `[a, b]`마다 현재까지의 최대 가로 길이 'h'와 최대 세로 길이 'v'와 비교하여 더 큰 값을 선택하여 업데이트한다.
    - 이때, `[a, b]` 중에서 큰 값(`Math.max(a, b)`)을 최대 가로 길이 'h'로, 작은 값(`Math.min(a, b)`)을 최대 세로 길이 'v'로 선택한다.
    - 각 요소를 순회하면서 콜백 함수가 호출될 때마다 'h'와 'v'는 새로운 값으로 갱신되어서 계속해서 이전 값과 현재 요소를 기반으로 최대 가로 길이와 최대 세로 길이를 업데이트한다.
  - 최종적으로 h, v에는 각각 sizes 배열의 각 사각형을 모두 고려하여 게산된 최대 가로 길이와 최대 세로 길이가 들어간다.
  - 이를 구조 분해 할당을 이용하여 hor과 ver 변수에 할당한다.

- 다른 예제
  ```javascript
  // 배열 내의 모든 숫자를 더함

  const numbers = [[1, 2], [3, 4], [5, 6]];

  // 배열 안의 배열을 현재값으로 받고, 배열의 요소를 구조 분해함
  let result = numbers.reduce((acc, [a, b]) => {
    const sum = a + b; // 각 배열의 요소를 더함
    return acc + sum; // 누적값에 sum을 더한 후 반환함
  }, 0); // 초기값: 0

  console.log(result); // 21
  ```

## 2. [최소직사각형] `forEach()` 메서드와 `map()` 메서드에서의 구조 분해 할당
- 공부 계기
  - 이 문제를 어떤 사람은 구조 분해 할당과 `forEach()`, `map()` 메서드를 활용하여 풀었다.
    ```javascript
    function solution(sizes) {
      const rotated = sizes.map(([w, h]) => (w < h ? [h, w] : [w, h]));

      let maxSize = [0, 0];
      rotated.forEach(([w, h]) => {
        if (w > maxSize[0]) maxSize[0] = w;
        if (h > maxSize[1]) maxSize[1] = h;
      });
      return maxSize[0] * maxSize[1];
    }
    ```
  - `forEach()` 메서드와 `map()` 메서드에서 구조 분해 할당을 사용하는 게 익숙하지 않아서 이 코드도 분석해보기로 했다.

- 위 코드 분석
  - sizes 배열을 `map()` 메서드로 순회한다.
  - `map()` 메서드의 인자로는 배열 구조 분해 할당을 사용하여 현재 요소를 `[w, h]` 형태로 받는다. 이것은 각 사각형의 가로와 세로를 각각 'w'와 'h' 변수에 할당하는 것이다.
  - 삼항 연산자를 사용하여 가로와 세로를 비교한다.
    - 만약 가로('w')가 세로('h')보다 작으면, `[h, w]`로 배열을 생성하여 사각형을 회전시킨다.
    - 그렇지 않으면, 원래의 가로와 세로를 그대로 유지한다.
  - 따라서 rotated 배열에는 각 사각형의 가로와 세로를 가로가 더 긴 형태로 회전시킨 결과가 담긴다.
  - maxSize 배열은 현재까지의 가장 큰 가로와 세로를 저장한다. 초기값은 [0, 0]으로 설정한다.
  - rotated 배열을 `forEach()` 메서드로 순회한다.
  - `forEach()` 메서드의 인자로는 배열 구조 분해 할당을 사용하여 현재 요소를 `[w, h]` 형태로 받는다. 이것은 각 사각형의 가로와 세로를 각각 'w'와 'h' 변수에 할당하는 것이다.
  - 만약 'w'가 maxSize[0] 값보다 크면, maxSize[0]을 'w'로 갱신한다.
  - 만약 'h'가 maxSize[1] 값보다 크면, maxSize[1]을 'h'로 갱신한다.
  - 최종적으로 maxSize[0], maxSize[1]에는 각각 rotated 배열의 각 사각형을 모두 고려하여 게산된 최대 가로 길이와 최대 세로 길이가 들어간다.

- 다른 예제
  ```javascript
  // 각 요소의 내부 구조를 가져와서 객체 형태로 변환함

  const coordinates = [
    [1, 2],
    [3, 4],
    [5, 6]
  ];

  const mappedCoordinates = coordinates.map([x, y] => {x , y});
  // 해당 요소에서 구조 분해 할당을 함
  // 내부 배열의 첫 번째 요소를 'x', 두 번째 요소를 'y'에 할당함
  // 그런 다음 새로운 객체를 반환하여 이를 새로운 배열인 mappedCoordinates에 담음

  console.log(mappedCoordinates);
  // 실행 결과
  // [
  //  { x: 1, y: 2 },
  //  { x: 3, y: 4 },
  //  { x: 5, y: 6 }
  // ]
  ```
  ```javascript
  // 해당 요소의 객체를 구조 분해 할당하여 'name'과 'age' 속성을 가져와서 각 객체의 'name', 'age' 값을 출력함 

  const people = [
    {name: "John", age: 30},
    {name: "Alice", age: 25},
    {name: "Bob", age: 35},
  ];

  people.forEach(({name, age}) => {
    console.log(`${name} is ${age} years old.`);
  });
  // 실행 결과
  // John is 30 years old.
  // Alice is 25 years old.
  // Bob is 35 years old.
  ```

## 3. [최소직사각형] `Math.max.apply()` 함수
- 공부 계기
  - 어떤 사람이 이 문제를 풀때 `Math.max.apply()` 함수를 사용하였는데, `apply()`가 붙어서 첫 번째 인자로 `null`을 주는 부분이 생소해서 이 함수에 대해서 공부해야겠다고 생각했다.
    ```javascript
    function solution(sizes) {
      sizes.map((item) => item.sort((a, b) => b - a));
      let hMax = Math.max.apply(
        null,
        sizes.map((item) => item[0])
      );
      let vMax = Math.max.apply(
        null,
        sizes.map((item) => item[1])
      );
      return hMax * vMax;
    }
    ```
- 위 코드 분석
  - sizes 배열을 `map()` 메서드로 순회하면서, 각 사각형의 가로와 세로를 비교하여 큰 값이 앞으로 오도록 정렬한다.
  - `map()` 메서드를 사용하여 각 사각형의 길이 중 큰 값을 추출한 새로운 배열을 생성한다.
  - `Math.max.apply()` 함수를 사용하여 위에서 생성한 배열에서 가장 큰 값을 구해서 hMax 변수에 할당한다.
  - `map()` 메서드를 사용하여 각 사각형의 길이 중 작은 값을 추출한 새로운 배열을 생성한다.
  - `Math.max.apply()` 함수를 사용하여 위에서 생성한 배열에서 가장 큰 값을 구해서 vMax 변수에 할당한다.

- `Math.max.apply()` 함수
  - 배열의 요소 중에서 최대값을 구하는 함수이다.
  - `apply()` 함수를 사용하여 배열을 함수의 매개변수로 전달할 수 있다.
  - `Math.max()` 함수는 임의의 개수의 숫자를 받아 그 중에서 가장 큰 수를 반환한다.
  - `Math.max()`는 배열을 직접 받지 않기 때문에, 배열을 이 함수에 바로 전달할 수는 없다.
  - 이때 `apply()` 메서드를 사용하여 배열을 `Math.num()` 함수에 전달할 수 있다.
  - `apply()` 메서드는 첫 번째 인자로 함수의 호출 컨텍스트를 지정하고, 두 번째 인자로 배열을 받는다. 이때 배열의 각 요소가 함수의 매개변수로 전달된다.
  - 예를 들어, 다음과 같이 배열의 최댓값을 구할 수 있다.
    ```javascript
    const numbers = [1, 2, 3, 4, 5];
    const maxNumber = Math.max.apply(null, numbers);
    console.log(maxNumber); // 5
    ```
    `Math.max.apply(null, numbers)`는 `Math.max()` 함수에 'numbers' 배열을 전달한다.
    - 이때, `null`은 `Math.max()` 함수 내에서의 호출 컨텍스트를 지정하는 것으로, 이 코드에서는 필요하지 않으므로 `null`로 설정되었다.
    - 'numbers' 배열의 각 요소가 `Math.max()` 함수의 매개변수로 전달되고, 해당 배열의 최댓값인 5가 반환된다.
  - **호출 컨텍스트**
    - 함수가 호출될 때 함수 내부에서 사용되는 `this` 키워드가 어떤 값을 참조할지를 결정하는 것을 말한다.
    - 자바스크립트에서 함수는 객체지향 프로그래밍 언어의 관점에서 보면 "메서드"라는 것이 있다. 이 메서드는 특정 객체에 속해 있다.
    - 함수가 메서드로서 호출될 때, `this` 키워드는 그 메서드가 속해 있는 객체를 가리킨다.
    - 하지만 자바스크립트에서는 함수가 객체에 속해 있지 않을 수도 있다. 이런 경우에는 호출 컨텍스트가 결정한다.
    - 호출 컨텍스트는 함수가 호출되는 방법에 따라 `this` 키워드가 참조하는 대상을 결정하는 것이다.
    - 호출 컨텍스트의 구분
      - **전역 컨텍스트(Global Context)**
        - 전역에서 호출된 함수의 호출 컨텍스트
        - 전역 컨텍스트에서 `this`는 전역 객체를 가리킨다.
        - 브라우저에서는 전역 객체가 `window` 객체이고, Node.js에서는 `global` 객체이다.
      - **함수 컨텍스트(Function Context)**
        - 함수 내부에서 호출된 함수의 호출 컨텍스트
        - 함수가 메서드로서 호출된 경우, `this`는 그 메서드가 속해 있는 객체를 가리킨다.
        - 그렇지 않은 경우에는 호출한 객체(호출한 함수가 속해 있는 객체)를 가리킨다.
        - 만약 해당 함수가 전역에서 호출되었다면, 전역 객체를 가리킨다.
    - `apply()` 메서드에서 첫 번째 인자로 전달되는 것이 바로 호출 컨텍스트이다. 
    - 일반적으로 함수 내부에서 사용되지 않는 경우, `null`로 지정된다.
    - `Math.max()` 함수는 객체지향 프로그래밍의 관점에서 보면 메서드가 아니라 단순히 전역에서 호출되는 함수이다.
      - **정적 메서드**
        - `Math.max()` 함수는 Math 객체의 메서드가 아닌 정적 메서드로서 정의된다.
        - 정적 메서드는 특정 객체의 인스턴스가 아니라 해당 객체의 생성 없이 직접 호출할 수 있는 메서드이다.
      - **상태를 변경하지 않음**
        - `Math.max()` 함수는 호출할 때마다 동일한 결과를 반환하며, 어떠한 객체에 종속되지 않는다.
        - 즉, 이 함수는 객체의 상태를 변경하지 않고 독립적으로 동작한다.
      - **객체의 속성이나 메서드로 정의되어 있지 않음**
        - 일반적으로 메서드는 특정 객체의 속성으로 정의된다.
        - 하지만 Math 객체의 경우 `max()` 메서드가 아니라 함수로서 정의되어 있다.
        - 따라서 `Math.max()` 함수는 Math 객체의 메서드가 아니라 일반적인 함수이다.
    - 따라서 해당 함수는 어떠한 객체에 속해 있지 않기 때문에, 호출 컨텍스트를 지정할 필요가 없어서 보통 `null`을 전달한다.

## 4. [시저 암호] `charCodeAt()` 메서드와 `charAt()` 매서드
- 공부 계기
  - 문자열을 암호화하는 문제인데, 이때 문자를 아스키 코드로 바꾸면 쉽게 풀 수 있을 것 같았다.
  - 문자를 아스키 코드로 바꾸는 메서드를 몰랐어서 문제를 풀기 전에 찾아보았다.
  - 문자를 아스키 코드로 바꾸는 메서드는 `charCodeAt()`인데, 공부하는 김에 이 메서드와 비슷한 철자를 가진 `charAt()` 메서드도 같이 공부했다.

- `charCodeAt()` 메서드와 `charAt()` 메서드는 둘 다 문자열에서 특정 위치에 있는 문자를 가져오는 역할을 하지만, 반환하는 값에 차이가 있다.

- **`charCodeAt()` 메서드**
  - 문자열에서 주어진 인덱스에 해당하는 **문자의 유니코드 코드 포인트 값**을 반환한다.
  - 문자열 내에서 특정 위치에 있는 문자의 아스키 코드 값을 얻을 때 사용된다.
    ```javascript
    const str = "Hello";
    const firstCharCode = str.charCodeAt(0); // 첫 번째 문자 'H'의 아스키 코드 값
    console.log(firstCharCode); // 72
    ```
    - `charCodeAt(0)`은 문자열의 첫 번째 문자 'H'의 아스키 코드 값을 반환한다.
    - 반환된 값은 문자 'H'의 아스키 코드 값인 72가 된다.
  - 주어진 인덱스에 해당하는 문자가 없는 경우, 즉 문자열의 범위를 벗어나는 인덱스를 지정한 경우, `NaN`을 반환한다.
    ```javascript
    const str = "Hello";
    const nonExistentCharCode = str.charCodeAt(10); // 존재하지 않는 인덱스에 해당하는 문자의 아스키 코드 값
    console.log(nonExistentCharCode); // NaN
    ```
    - `charCodeAt(10)`은 존재하지 않는 인덱스에 해당하는 문자의 아스키 코드 값을 반환하므로 `NaN`이 출력된다.

- **`charAt()` 메서드**
  - 문자열에서 주어진 인덱스에 위치한 **문자**를 반환한다.
    ```javascript
    const str = "Hello";
    const firstChar = str.charAt(0); // 첫 번째 문자 'H'를 가져옴
    console.log(firstChar); // H
    ```
    - `charAt(0)`은 문자열의 첫 번째 문자 'H'를 반환한다.
    - 반환된 값은 문자 "H"가 된다.
  - 주어진 인덱스에 해당하는 문자가 없는 경우, 즉 문자열의 범위를 벗어나는 인덱스를 지정한 경우, 빈 문자열("")을 반환한다.
    ```javascript
    const str = "Hello";
    const nonExistentChar = str.charAt(10); // 존재하지 않는 인덱스에 해당하는 문자
    console.log(nonExistentChar); // ""(빈 문자열)
    ```
    - `charAt(10)`은 존재하지 않는 인덱스에 해당하는 문자의 아스키 코드 값을 반환하므로 빈 문자열("")이 출력된다.

## 5. [시저 암호] `String.fromCharCode()` 메서드
- 공부 계기
  - 문자열을 암호화하는 문제에서 문자를 아스키 코드로 바꾼 후, 숫자로 바뀐 아스키 코드에서 연산을 수행한 후에 다시 문자로 바꾸는 과정이 필요했다.
  - 아스키 코드를 문자로 바꾸는 메서드를 몰랐어서 문제를 풀기 전에 찾아보았다.

- 주어진 유니코드 값에 해당하는 문자를 반환한다.

- String 객체의 정적 메서드로 사용된다.

- 예제
  ```javascript
  console.log(String.fromCharCode(65, 66, 67)); // ABC
  ```
  - `fromCharCode()` 메서드는 유니코드 값인 65, 66, 67에 해당하는 문자들을 연결하여 "ABC"라는 문자열을 생성한다.

<br>
<hr>
<br>
팀 프로젝트(영화 상세 사이트 제작) 관련 자바스크립트 개념 정리 부분

## 6. 파이어베이스 사용 방법
- 공부 계기
  - 우리 팀은 영화 리뷰 작성 기능을 로컬 스토리지를 사용하는 방법과 파이어베이스를 사용하는 방법 모두 구현해보기로 했다.
  - 나는 그 중에서 파이어베이스를 이용하여 영화 리뷰 작성 기능을 구현하는 것을 담당했는데, 파이어베이스를 다루면서 파이어베이스를 사용하는 방법 및 절차를 정리하면 좋을 것 같다는 생각을 했다.

- **파이어베이스**
  - 구글이 개발한 모바일 및 웹 애플리케이션 개발 플랫폼
  - 개발자들이 백엔드 인프라를 구축하거나 관리하는 복잡한 작업 없이 핵심 기능에 집중할 수 있도록 도와준다.

- **데이터베이스**
  - 데이터를 저장하고 여러 사람들이 관리하는 데이터의 모음
  - 데이터베이스를 사용하면 정보를 쉽게 찾고, 업데이트 하기가 편리하며, 많은 양의 정보를 효율적으로 관리할 수 있다.
  - **관계형 데이터베이스(SQL)** : 정리된 정보를 다룰 때 사용한다. 예) 은행, 대기업
  - **비관계형 데이터베이스(NoSQL)** : 복잡하거나 유연한 정보를 다룰 때 사용한다. 예) 스타트업
  - 각각의 데이터베이스 유형은 다른 용도와 장단점을 가지고 있으므로, 데이터의 구조와 요구 사항에 맞춰서 적절한 데이터베이스 유형을 선택하는 것이 중요하다.

- **파이어스토어(Firestore)**
  - 구글의 클라우드 기반 NoSQL 데이터베이스
  - 최신 클라우드 데이터베이스 서비스로, 데이터를 저장하고 관리할 수 있는 기능을 제공한다.
  - **컬렉션(Collection)**
    - 여러 개의 문서들이 특정한 주제 또는 유형으로 그룹화되어 있다.
    - 서랍장 그룹과도 같다.
  - **문서(Document)**
    - 하나의 컬렉션에 저장된 데이터
    - 서랍장 안에 들어 있는 작은 종이들과도 같다.
  - **필드(Field)**
    - 문서 안에 있는 데이터의 작은 부분
    - 각 필드는 값으로 구성된다.
    - 예를 들어, '사용자' **문서**의 **필드**로는 "내용", "날짜", "이미지 주소", "제목" 등이 있을 수 있다.

- 파이어베이스, 파이어스토어로 데이터 다루는 방법
  - 파이어베이스 사이트에 접속해서 로그인을 한다.
  - '콘솔로 이동' 버튼을 누른다.
  - '프로젝트 만들기' 버튼을 누른다.
  - 프로젝트 이름을 입력하고 약관에 모두 동의한 후, '계속' 버튼을 누른다.
  - 애널리틱스 사용 설정을 해제한 후, '프로젝트 만들기' 버튼을 클릭한다.
  - 새 프로젝트가 준비되었다는 메시지가 뜨면, '계속' 버튼을 누른다.
  - '앱에 Firebase를 추가하여 시작하기' 문구 바로 밑에 있는 세 번째 아이콘(웹 표시)을 누른다.
  - 앱 닉네임을 입력한 후, '앱 등록' 버튼을 누른다.
  - '콘솔로 이동' 버튼을 누른다.
  - 왼쪽 네비게이션 바의 '빌드' 탭에서 'Firestore Database' 항목을 누른다.
  - '데이터베이스 만들기' 버튼을 누른다.
  - '프로덕션 모드에서 시작'에 체크하고, '다음' 버튼을 누른다.
  - Cloud Firestore 위치는 "Seoul"로 설정하고, '사용 설정' 버튼을 누른다.
  - '규칙' 탭을 눌러서 `if false` 부분을 `if true`로 변경한 후, '게시' 버튼을 누른다.
  - 파이어베이스 세팅 코드를 자바스크립트 파일에 붙여넣으면 데이터를 넣고 가져올 준비가 끝났다.
    ```javascript
    // Firebase SDK 라이브러리 가져오기
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getFirestore } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    import { collection, addDoc } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    import { getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

    // Firebase 구성 정보 설정
    const firebaseConfig = {
      // 본인 설정 내용 채우기 
    };

    // Firebase 인스턴스 초기화
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    ```
    - `firebaseConfig` 내용은 왼쪽 네비게이션 바의 '프로젝트 개요' 옆에 있는 설정 아이콘을 누른 후, '프로젝트 설정' 카테고리를 누르면 알 수 있다.